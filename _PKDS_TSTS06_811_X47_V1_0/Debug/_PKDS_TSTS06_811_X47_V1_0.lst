
_PKDS_TSTS06_811_X47_V1_0.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .app_info     00000400  08020000  0c020000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00008888  08020400  0c020400  00010400  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 Stack         00000800  1ffe8000  1ffe8000  00038000  2**0
                  ALLOC
  3 .ram_code     000009c0  1ffe8800  0c028c88  00028800  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .data         00000704  1ffe91c0  0c029648  000291c0  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          000009fc  1ffe98c4  0c029d4c  000298c4  2**2
                  ALLOC
  6 USB_RAM       00000000  20000000  20000000  000298c4  2**0
                  CONTENTS
  7 ETH_RAM       00000000  20000000  20000000  000298c4  2**0
                  CONTENTS
  8 .no_init      00000014  2003ffc0  2003ffc0  0002ffc0  2**2
                  ALLOC
  9 .debug_aranges 00001e98  00000000  00000000  000298c8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_info   0003a53e  00000000  00000000  0002b760  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_abbrev 00007c02  00000000  00000000  00065c9e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_line   000142d1  00000000  00000000  0006d8a0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_frame  000074d8  00000000  00000000  00081b74  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_str    00011ee8  00000000  00000000  0008904c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_loc    0000faaa  00000000  00000000  0009af34  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_ranges 00001a18  00000000  00000000  000aa9de  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .build_attributes 00000e08  00000000  00000000  000ac3f6  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

08020400 <__Vectors>:
 8020400:	00 88 fe 1f 01 06 02 08 99 06 02 08 99 06 02 08     ................
 8020410:	99 06 02 08 99 06 02 08 99 06 02 08 00 00 00 00     ................
	...
 802042c:	99 06 02 08 99 06 02 08 00 00 00 00 99 06 02 08     ................
 802043c:	25 65 02 08 99 06 02 08 99 06 02 08 99 06 02 08     %e..............
 802044c:	99 06 02 08 99 06 02 08 99 06 02 08 99 06 02 08     ................
 802045c:	99 06 02 08 99 06 02 08 00 00 00 00 00 00 00 00     ................
 802046c:	00 00 00 00 99 06 02 08 00 00 00 00 19 20 02 08     ............. ..
 802047c:	99 06 02 08 ed 80 02 08 99 06 02 08 99 06 02 08     ................
 802048c:	99 06 02 08 99 06 02 08 99 06 02 08 99 06 02 08     ................
 802049c:	99 06 02 08 99 06 02 08 99 06 02 08 99 06 02 08     ................
 80204ac:	99 06 02 08 99 06 02 08 99 06 02 08 99 06 02 08     ................
 80204bc:	99 06 02 08 99 06 02 08 99 06 02 08 99 06 02 08     ................
 80204cc:	99 06 02 08 99 06 02 08 99 06 02 08 99 06 02 08     ................
 80204dc:	99 06 02 08 99 06 02 08 99 06 02 08 99 06 02 08     ................
 80204ec:	99 06 02 08 99 06 02 08 99 06 02 08 99 06 02 08     ................
 80204fc:	99 06 02 08 99 06 02 08 99 06 02 08 99 06 02 08     ................
 802050c:	99 06 02 08 99 06 02 08 99 06 02 08 99 06 02 08     ................
 802051c:	99 06 02 08 05 2f 02 08 a5 80 02 08 e5 2e 02 08     ...../..........
 802052c:	7d 80 02 08 89 8b fe 1f 99 06 02 08 99 06 02 08     }...............
 802053c:	99 06 02 08 99 06 02 08 99 06 02 08 99 06 02 08     ................
 802054c:	99 06 02 08 29 8d fe 1f f5 8d fe 1f 99 06 02 08     ....)...........
 802055c:	99 06 02 08 00 00 00 00 00 00 00 00 00 00 00 00     ................
 802056c:	00 00 00 00 99 06 02 08 3d 81 02 08 99 2d 02 08     ........=....-..
 802057c:	79 2b 02 08 dd 2d 02 08 f1 2c 02 08 45 2d 02 08     y+...-...,..E-..
 802058c:	99 06 02 08 99 06 02 08 99 06 02 08 99 06 02 08     ................
 802059c:	99 06 02 08 99 06 02 08 99 06 02 08 99 06 02 08     ................
 80205ac:	99 06 02 08 99 06 02 08 99 06 02 08 99 06 02 08     ................
 80205bc:	99 06 02 08 99 06 02 08 99 06 02 08 99 06 02 08     ................
 80205cc:	99 06 02 08 99 06 02 08 99 06 02 08 99 06 02 08     ................
 80205dc:	00 00 00 00 99 06 02 08 99 06 02 08 99 06 02 08     ................
 80205ec:	99 06 02 08 99 06 02 08 00 00 00 00 99 06 02 08     ................
 80205fc:	00 00 00 00                                         ....

08020600 <Reset_Handler>:
/* Reset Handler */
    .thumb_func
    .globl  Reset_Handler
    .type   Reset_Handler, %function
Reset_Handler:
    ldr sp,=__initial_sp
 8020600:	f8df d074 	ldr.w	sp, [pc, #116]	; 8020678 <__zero_table_end__>

#ifndef __SKIP_SYSTEM_INIT
    ldr  r0, =SystemInit
 8020604:	481d      	ldr	r0, [pc, #116]	; (802067c <__zero_table_end__+0x4>)
    blx  r0
 8020606:	4780      	blx	r0
 *    offset 4: VMA of start of a section to copy to
 *    offset 8: size of the section to copy. Must be multiply of 4
 *
 *  All addresses must be aligned to 4 bytes boundary.
 */
	ldr	r4, =__copy_table_start__
 8020608:	4c1d      	ldr	r4, [pc, #116]	; (8020680 <__zero_table_end__+0x8>)
	ldr	r5, =__copy_table_end__
 802060a:	4d1e      	ldr	r5, [pc, #120]	; (8020684 <__zero_table_end__+0xc>)

.L_loop0:
	cmp	r4, r5
 802060c:	42ac      	cmp	r4, r5
	bge	.L_loop0_done
 802060e:	da09      	bge.n	8020624 <Reset_Handler+0x24>
	ldr	r1, [r4]
 8020610:	6821      	ldr	r1, [r4, #0]
	ldr	r2, [r4, #4]
 8020612:	6862      	ldr	r2, [r4, #4]
	ldr	r3, [r4, #8]
 8020614:	68a3      	ldr	r3, [r4, #8]

.L_loop0_0:
	subs	r3, #4
 8020616:	3b04      	subs	r3, #4
	ittt	ge
 8020618:	bfa2      	ittt	ge
	ldrge	r0, [r1, r3]
 802061a:	58c8      	ldrge	r0, [r1, r3]
	strge	r0, [r2, r3]
 802061c:	50d0      	strge	r0, [r2, r3]
	bge	.L_loop0_0
 802061e:	e7fa      	bge.n	8020616 <Reset_Handler+0x16>

	adds	r4, #12
 8020620:	340c      	adds	r4, #12
	b	.L_loop0
 8020622:	e7f3      	b.n	802060c <Reset_Handler+0xc>
 *    offset 4: Size of this BSS section. Must be multiply of 4
 *
 *  Define __SKIP_BSS_CLEAR to disable zeroing uninitialzed data in startup.
 */    
#ifndef __SKIP_BSS_CLEAR
	ldr	r3, =__zero_table_start__
 8020624:	4b18      	ldr	r3, [pc, #96]	; (8020688 <__zero_table_end__+0x10>)
	ldr	r4, =__zero_table_end__
 8020626:	4c19      	ldr	r4, [pc, #100]	; (802068c <__zero_table_end__+0x14>)

.L_loop2:
	cmp	r3, r4
 8020628:	42a3      	cmp	r3, r4
	bge	.L_loop2_done
 802062a:	da08      	bge.n	802063e <Reset_Handler+0x3e>
	ldr	r1, [r3]
 802062c:	6819      	ldr	r1, [r3, #0]
	ldr	r2, [r3, #4]
 802062e:	685a      	ldr	r2, [r3, #4]
	movs	r0, 0
 8020630:	2000      	movs	r0, #0

.L_loop2_0:
	subs	r2, #4
 8020632:	3a04      	subs	r2, #4
	itt	ge
 8020634:	bfa4      	itt	ge
	strge	r0, [r1, r2]
 8020636:	5088      	strge	r0, [r1, r2]
	bge	.L_loop2_0
 8020638:	e7fb      	bge.n	8020632 <Reset_Handler+0x32>

	adds	r3, #8
 802063a:	3308      	adds	r3, #8
	b	.L_loop2
 802063c:	e7f4      	b.n	8020628 <Reset_Handler+0x28>
.L_loop2_done:    
#endif /* __SKIP_BSS_CLEAR */
   
#ifndef __SKIP_LIBC_INIT_ARRAY
    ldr  r0, =__libc_init_array
 802063e:	4814      	ldr	r0, [pc, #80]	; (8020690 <__zero_table_end__+0x18>)
    blx  r0
 8020640:	4780      	blx	r0
#endif

    ldr  r0, =main
 8020642:	4814      	ldr	r0, [pc, #80]	; (8020694 <__zero_table_end__+0x1c>)
    blx  r0
 8020644:	4780      	blx	r0
	...

08020648 <__copy_table_start__>:
 8020648:	0c029648 	.word	0x0c029648
 802064c:	1ffe91c0 	.word	0x1ffe91c0
 8020650:	00000704 	.word	0x00000704
 8020654:	0c028c88 	.word	0x0c028c88
 8020658:	1ffe8800 	.word	0x1ffe8800
 802065c:	000009c0 	.word	0x000009c0

08020660 <__copy_table_end__>:
 8020660:	1ffe98c4 	.word	0x1ffe98c4
 8020664:	000009fc 	.word	0x000009fc
 8020668:	20000000 	.word	0x20000000
 802066c:	00000000 	.word	0x00000000
 8020670:	20000000 	.word	0x20000000
 8020674:	00000000 	.word	0x00000000

08020678 <__zero_table_end__>:
    ldr sp,=__initial_sp
 8020678:	1ffe8800 	.word	0x1ffe8800
    ldr  r0, =SystemInit
 802067c:	0802069d 	.word	0x0802069d
	ldr	r4, =__copy_table_start__
 8020680:	08020648 	.word	0x08020648
	ldr	r5, =__copy_table_end__
 8020684:	08020660 	.word	0x08020660
	ldr	r3, =__zero_table_start__
 8020688:	08020660 	.word	0x08020660
	ldr	r4, =__zero_table_end__
 802068c:	08020678 	.word	0x08020678
    ldr  r0, =__libc_init_array
 8020690:	080282fd 	.word	0x080282fd
    ldr  r0, =main
 8020694:	08028265 	.word	0x08028265

08020698 <BusFault_Handler>:
	.align	1
    .thumb_func
    .weak Default_Handler
    .type Default_Handler, %function
Default_Handler:
    b .
 8020698:	e7fe      	b.n	8020698 <BusFault_Handler>
	...

0802069c <SystemInit>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

__WEAK void SystemInit(void)
{
 802069c:	b598      	push	{r3, r4, r7, lr}
 802069e:	af00      	add	r7, sp, #0
  memcpy(g_chipid, CHIPID_LOC, 16);
 80206a0:	4a06      	ldr	r2, [pc, #24]	; (80206bc <SystemInit+0x20>)
 80206a2:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 80206a6:	4614      	mov	r4, r2
 80206a8:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80206aa:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  
  SystemCoreSetup();
 80206ae:	f006 fd91 	bl	80271d4 <SystemCoreSetup>
  SystemCoreClockSetup(); 
 80206b2:	f006 fdfd 	bl	80272b0 <SystemCoreClockSetup>
}
 80206b6:	bf00      	nop
 80206b8:	bd98      	pop	{r3, r4, r7, pc}
 80206ba:	bf00      	nop
 80206bc:	2003ffc4 	.word	0x2003ffc4

080206c0 <SystemCoreClockUpdate>:

  SystemCoreClockUpdate();
}

__WEAK void SystemCoreClockUpdate(void)
{
 80206c0:	b580      	push	{r7, lr}
 80206c2:	b084      	sub	sp, #16
 80206c4:	af00      	add	r7, sp, #0
  uint32_t pdiv;
  uint32_t ndiv;
  uint32_t kdiv;
  uint32_t temp;

  if (SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSSEL_Msk)
 80206c6:	4b2f      	ldr	r3, [pc, #188]	; (8020784 <SystemCoreClockUpdate+0xc4>)
 80206c8:	68db      	ldr	r3, [r3, #12]
 80206ca:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80206ce:	2b00      	cmp	r3, #0
 80206d0:	d03e      	beq.n	8020750 <SystemCoreClockUpdate+0x90>
  {
    /* fPLL is clock source for fSYS */
    if(SCU_PLL->PLLCON2 & SCU_PLL_PLLCON2_PINSEL_Msk)
 80206d2:	4b2d      	ldr	r3, [pc, #180]	; (8020788 <SystemCoreClockUpdate+0xc8>)
 80206d4:	68db      	ldr	r3, [r3, #12]
 80206d6:	f003 0301 	and.w	r3, r3, #1
 80206da:	2b00      	cmp	r3, #0
 80206dc:	d002      	beq.n	80206e4 <SystemCoreClockUpdate+0x24>
    {
      /* PLL input clock is the backup clock (fOFI) */
      temp = OFI_FREQUENCY;
 80206de:	4b2b      	ldr	r3, [pc, #172]	; (802078c <SystemCoreClockUpdate+0xcc>)
 80206e0:	60fb      	str	r3, [r7, #12]
 80206e2:	e002      	b.n	80206ea <SystemCoreClockUpdate+0x2a>
    }
    else
    {
      /* PLL input clock is the high performance osicllator (fOSCHP) */
      temp = OSCHP_GetFrequency();
 80206e4:	f006 fdda 	bl	802729c <OSCHP_GetFrequency>
 80206e8:	60f8      	str	r0, [r7, #12]
    }

    /* check if PLL is locked */
    if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)
 80206ea:	4b27      	ldr	r3, [pc, #156]	; (8020788 <SystemCoreClockUpdate+0xc8>)
 80206ec:	681b      	ldr	r3, [r3, #0]
 80206ee:	f003 0304 	and.w	r3, r3, #4
 80206f2:	2b00      	cmp	r3, #0
 80206f4:	d020      	beq.n	8020738 <SystemCoreClockUpdate+0x78>
    {
      /* PLL normal mode */
      /* read back divider settings */
      pdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_PDIV_Msk) >> SCU_PLL_PLLCON1_PDIV_Pos) + 1;
 80206f6:	4b24      	ldr	r3, [pc, #144]	; (8020788 <SystemCoreClockUpdate+0xc8>)
 80206f8:	689b      	ldr	r3, [r3, #8]
 80206fa:	0e1b      	lsrs	r3, r3, #24
 80206fc:	f003 030f 	and.w	r3, r3, #15
 8020700:	3301      	adds	r3, #1
 8020702:	607b      	str	r3, [r7, #4]
      ndiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_NDIV_Msk) >> SCU_PLL_PLLCON1_NDIV_Pos) + 1;
 8020704:	4b20      	ldr	r3, [pc, #128]	; (8020788 <SystemCoreClockUpdate+0xc8>)
 8020706:	689b      	ldr	r3, [r3, #8]
 8020708:	0a1b      	lsrs	r3, r3, #8
 802070a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 802070e:	3301      	adds	r3, #1
 8020710:	603b      	str	r3, [r7, #0]
      kdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K2DIV_Msk) >> SCU_PLL_PLLCON1_K2DIV_Pos) + 1;
 8020712:	4b1d      	ldr	r3, [pc, #116]	; (8020788 <SystemCoreClockUpdate+0xc8>)
 8020714:	689b      	ldr	r3, [r3, #8]
 8020716:	0c1b      	lsrs	r3, r3, #16
 8020718:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 802071c:	3301      	adds	r3, #1
 802071e:	60bb      	str	r3, [r7, #8]

      temp = (temp / (pdiv * kdiv)) * ndiv;
 8020720:	687b      	ldr	r3, [r7, #4]
 8020722:	68ba      	ldr	r2, [r7, #8]
 8020724:	fb02 f303 	mul.w	r3, r2, r3
 8020728:	68fa      	ldr	r2, [r7, #12]
 802072a:	fbb2 f2f3 	udiv	r2, r2, r3
 802072e:	683b      	ldr	r3, [r7, #0]
 8020730:	fb02 f303 	mul.w	r3, r2, r3
 8020734:	60fb      	str	r3, [r7, #12]
 8020736:	e00d      	b.n	8020754 <SystemCoreClockUpdate+0x94>
    }
    else
    {
      /* PLL prescalar mode */
      /* read back divider settings */
      kdiv  = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K1DIV_Msk) >> SCU_PLL_PLLCON1_K1DIV_Pos) + 1;
 8020738:	4b13      	ldr	r3, [pc, #76]	; (8020788 <SystemCoreClockUpdate+0xc8>)
 802073a:	689b      	ldr	r3, [r3, #8]
 802073c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8020740:	3301      	adds	r3, #1
 8020742:	60bb      	str	r3, [r7, #8]
      
      temp = (temp / kdiv);
 8020744:	68fa      	ldr	r2, [r7, #12]
 8020746:	68bb      	ldr	r3, [r7, #8]
 8020748:	fbb2 f3f3 	udiv	r3, r2, r3
 802074c:	60fb      	str	r3, [r7, #12]
 802074e:	e001      	b.n	8020754 <SystemCoreClockUpdate+0x94>
    }
  }
  else
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
 8020750:	4b0e      	ldr	r3, [pc, #56]	; (802078c <SystemCoreClockUpdate+0xcc>)
 8020752:	60fb      	str	r3, [r7, #12]
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 8020754:	4b0b      	ldr	r3, [pc, #44]	; (8020784 <SystemCoreClockUpdate+0xc4>)
 8020756:	68db      	ldr	r3, [r3, #12]
 8020758:	b2db      	uxtb	r3, r3
 802075a:	3301      	adds	r3, #1
 802075c:	68fa      	ldr	r2, [r7, #12]
 802075e:	fbb2 f3f3 	udiv	r3, r2, r3
 8020762:	60fb      	str	r3, [r7, #12]
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);
 8020764:	4b07      	ldr	r3, [pc, #28]	; (8020784 <SystemCoreClockUpdate+0xc4>)
 8020766:	691b      	ldr	r3, [r3, #16]
 8020768:	f003 0301 	and.w	r3, r3, #1
 802076c:	3301      	adds	r3, #1
 802076e:	68fa      	ldr	r2, [r7, #12]
 8020770:	fbb2 f3f3 	udiv	r3, r2, r3
 8020774:	60fb      	str	r3, [r7, #12]

  SystemCoreClock = temp;
 8020776:	4a06      	ldr	r2, [pc, #24]	; (8020790 <SystemCoreClockUpdate+0xd0>)
 8020778:	68fb      	ldr	r3, [r7, #12]
 802077a:	6013      	str	r3, [r2, #0]
}
 802077c:	bf00      	nop
 802077e:	3710      	adds	r7, #16
 8020780:	46bd      	mov	sp, r7
 8020782:	bd80      	pop	{r7, pc}
 8020784:	50004600 	.word	0x50004600
 8020788:	50004710 	.word	0x50004710
 802078c:	016e3600 	.word	0x016e3600
 8020790:	2003ffc0 	.word	0x2003ffc0

08020794 <XMC_VADC_GROUP_QueueTriggerConversion>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_VADC_GROUP_QueueInsertChannel()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueTriggerConversion(XMC_VADC_GROUP_t *const group_ptr)
{
 8020794:	b480      	push	{r7}
 8020796:	b083      	sub	sp, #12
 8020798:	af00      	add	r7, sp, #0
 802079a:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_VADC_GROUP_QueueTriggerConversion:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->QMR0 |= (uint32_t)((uint32_t)1 << VADC_G_QMR0_TREV_Pos);
 802079c:	687b      	ldr	r3, [r7, #4]
 802079e:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 80207a2:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 80207a6:	687b      	ldr	r3, [r7, #4]
 80207a8:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
}
 80207ac:	bf00      	nop
 80207ae:	370c      	adds	r7, #12
 80207b0:	46bd      	mov	sp, r7
 80207b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80207b6:	4770      	bx	lr

080207b8 <XMC_VADC_GROUP_QueueInsertChannel>:
 * \par<b>Related APIs:</b><br>
 *  XMC_VADC_GROUP_QueueRemoveChannel()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueInsertChannel(XMC_VADC_GROUP_t *const group_ptr,
    const XMC_VADC_QUEUE_ENTRY_t entry)
{
 80207b8:	b480      	push	{r7}
 80207ba:	b083      	sub	sp, #12
 80207bc:	af00      	add	r7, sp, #0
 80207be:	6078      	str	r0, [r7, #4]
 80207c0:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_VADC_GROUP_QueueInsertChannel:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  /* Insert the channel physically and get the length of the queue*/
  group_ptr->QINR0 = entry.qinr0;
 80207c2:	683a      	ldr	r2, [r7, #0]
 80207c4:	687b      	ldr	r3, [r7, #4]
 80207c6:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
}
 80207ca:	bf00      	nop
 80207cc:	370c      	adds	r7, #12
 80207ce:	46bd      	mov	sp, r7
 80207d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80207d4:	4770      	bx	lr

080207d6 <XMC_VADC_GROUP_ResultInit>:
 * XMC_VADC_GROUP_AddResultToFifo()<BR> XMC_VADC_GROUP_EnableResultEvent()<br> XMC_VADC_GROUP_DisableResultEvent()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ResultInit(XMC_VADC_GROUP_t *const group_ptr,
    const uint32_t res_reg_num,
    const XMC_VADC_RESULT_CONFIG_t *config)
{
 80207d6:	b480      	push	{r7}
 80207d8:	b085      	sub	sp, #20
 80207da:	af00      	add	r7, sp, #0
 80207dc:	60f8      	str	r0, [r7, #12]
 80207de:	60b9      	str	r1, [r7, #8]
 80207e0:	607a      	str	r2, [r7, #4]
  XMC_ASSERT("XMC_VADC_GROUP_ResultInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->RCR[res_reg_num] = config->g_rcr;
 80207e2:	687b      	ldr	r3, [r7, #4]
 80207e4:	6819      	ldr	r1, [r3, #0]
 80207e6:	68fb      	ldr	r3, [r7, #12]
 80207e8:	68ba      	ldr	r2, [r7, #8]
 80207ea:	32a0      	adds	r2, #160	; 0xa0
 80207ec:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

}
 80207f0:	bf00      	nop
 80207f2:	3714      	adds	r7, #20
 80207f4:	46bd      	mov	sp, r7
 80207f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80207fa:	4770      	bx	lr

080207fc <XMC_VADC_GROUP_GetResult>:
 * \par<b>Related APIs:</b><br>
 * XMC_VADC_GROUP_GetDetailedResult().
 */
__STATIC_INLINE XMC_VADC_RESULT_SIZE_t XMC_VADC_GROUP_GetResult(XMC_VADC_GROUP_t *const group_ptr,
    const uint32_t res_reg)
{
 80207fc:	b480      	push	{r7}
 80207fe:	b083      	sub	sp, #12
 8020800:	af00      	add	r7, sp, #0
 8020802:	6078      	str	r0, [r7, #4]
 8020804:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_VADC_GROUP_GetResult:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_GetResult:Wrong Result Register", ((res_reg) < XMC_VADC_NUM_RESULT_REGISTERS))

  return ((XMC_VADC_RESULT_SIZE_t)group_ptr->RES[res_reg]);
 8020806:	687b      	ldr	r3, [r7, #4]
 8020808:	683a      	ldr	r2, [r7, #0]
 802080a:	32c0      	adds	r2, #192	; 0xc0
 802080c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8020810:	b29b      	uxth	r3, r3
}
 8020812:	4618      	mov	r0, r3
 8020814:	370c      	adds	r7, #12
 8020816:	46bd      	mov	sp, r7
 8020818:	f85d 7b04 	ldr.w	r7, [sp], #4
 802081c:	4770      	bx	lr

0802081e <VADC_GetResult>:
 *
 * \par<b>Description:</b><br>
 * Returns the VADC conversion result by reading result register from selected group number.
 */
__STATIC_INLINE XMC_VADC_RESULT_SIZE_t VADC_GetResult(XMC_VADC_GROUP_t *const group_ptr, const uint32_t res_reg)
{
 802081e:	b580      	push	{r7, lr}
 8020820:	b084      	sub	sp, #16
 8020822:	af00      	add	r7, sp, #0
 8020824:	6078      	str	r0, [r7, #4]
 8020826:	6039      	str	r1, [r7, #0]
  XMC_VADC_RESULT_SIZE_t result;
  result = (XMC_VADC_RESULT_SIZE_t) XMC_VADC_GROUP_GetResult(group_ptr,res_reg);
 8020828:	6839      	ldr	r1, [r7, #0]
 802082a:	6878      	ldr	r0, [r7, #4]
 802082c:	f7ff ffe6 	bl	80207fc <XMC_VADC_GROUP_GetResult>
 8020830:	4603      	mov	r3, r0
 8020832:	81fb      	strh	r3, [r7, #14]
  return(result);
 8020834:	89fb      	ldrh	r3, [r7, #14]
}
 8020836:	4618      	mov	r0, r3
 8020838:	3710      	adds	r7, #16
 802083a:	46bd      	mov	sp, r7
 802083c:	bd80      	pop	{r7, pc}
	...

08020840 <Motor0_BLDC_SCALAR_Current_Measurment_Init>:
/*********************************************************************************************************************/
#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U)


void Motor0_BLDC_SCALAR_Current_Measurment_Init(void)
{
 8020840:	b580      	push	{r7, lr}
 8020842:	af00      	add	r7, sp, #0
#if (MOTOR0_BLDC_SCALAR_OFFSET_DAC == 1U)
  volatile uint32_t delay;       /* DAC settlement delay counter */
  uint32_t dac_settlement_dealy = BLDC_SCALAR_DAC_SETTLEMENT_DELAY;  /* required DAC settlement delay */
#endif
  /* Initialize VADC channel */
  XMC_VADC_GROUP_ChannelInit(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP, MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_CH_NUM,
 8020844:	4a0d      	ldr	r2, [pc, #52]	; (802087c <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x3c>)
 8020846:	2105      	movs	r1, #5
 8020848:	480d      	ldr	r0, [pc, #52]	; (8020880 <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x40>)
 802084a:	f005 fb93 	bl	8025f74 <XMC_VADC_GROUP_ChannelInit>
      &Motor0_BLDC_SCALAR_VADC_IDCLink_CH_handle);

  /* Initialize VADC result */
  XMC_VADC_GROUP_ResultInit(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP, MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_RES_REG_NUM,
 802084e:	4a0d      	ldr	r2, [pc, #52]	; (8020884 <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x44>)
 8020850:	2105      	movs	r1, #5
 8020852:	480b      	ldr	r0, [pc, #44]	; (8020880 <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x40>)
 8020854:	f7ff ffbf 	bl	80207d6 <XMC_VADC_GROUP_ResultInit>
      &Motor0_BLDC_SCALAR_VADC_IDCLink_Res_handle);

  /* Request the LLD to insert the channel in queue.*/
  XMC_VADC_GROUP_QueueInsertChannel(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP, Motor0_BLDC_SCALAR_VADC_IDCLink_queue_entry);
 8020858:	4b0b      	ldr	r3, [pc, #44]	; (8020888 <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x48>)
 802085a:	6819      	ldr	r1, [r3, #0]
 802085c:	4808      	ldr	r0, [pc, #32]	; (8020880 <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x40>)
 802085e:	f7ff ffab 	bl	80207b8 <XMC_VADC_GROUP_QueueInsertChannel>
  /*Initialize DAC data register for generating amplifier bias voltage of 1.65V*/
  XMC_DAC_CH_Write((XMC_DAC_t  *)(void *)DAC,DAC_CHANNEL_0,BLDC_SCALAR_DAC_VOLTAGE_COUNT);
#endif
  #if((MOTOR0_BLDC_SCALAR_ENABLE_OVER_CURRENT == 1U) && (BLDC_SCALAR_IDC_DIRECT_CURRENT == MOTOR0_BLDC_SCALAR_OVER_CURRENT_SOURCE))
  /* If over current protection is enabled then configure group boundaries accordingly and enable interrupt */
   XMC_VADC_GROUP_SetBoundaries(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP, MOTOR0_BLDC_SCALAR_OVER_CURRENT_VADC_BOUND0_T,
 8020862:	f641 7205 	movw	r2, #7941	; 0x1f05
 8020866:	2100      	movs	r1, #0
 8020868:	4805      	ldr	r0, [pc, #20]	; (8020880 <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x40>)
 802086a:	f005 fa8b 	bl	8025d84 <XMC_VADC_GROUP_SetBoundaries>
       MOTOR0_BLDC_SCALAR_OVER_CURRENT_VADC_BOUND1_T);
  /* Bind the channel event to shared service request line */
  XMC_VADC_GROUP_ChannelSetEventInterruptNode(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP, MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_CH_NUM,
 802086e:	2204      	movs	r2, #4
 8020870:	2105      	movs	r1, #5
 8020872:	4803      	ldr	r0, [pc, #12]	; (8020880 <Motor0_BLDC_SCALAR_Current_Measurment_Init+0x40>)
 8020874:	f005 fbed 	bl	8026052 <XMC_VADC_GROUP_ChannelSetEventInterruptNode>
      MOTOR0_BLDC_SCALAR_VADC_CHEVT_SR);
  #endif
}
 8020878:	bf00      	nop
 802087a:	bd80      	pop	{r7, pc}
 802087c:	1ffe9240 	.word	0x1ffe9240
 8020880:	40005000 	.word	0x40005000
 8020884:	1ffe98c4 	.word	0x1ffe98c4
 8020888:	1ffe923c 	.word	0x1ffe923c

0802088c <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration>:

#if ((MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U) || (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_AVERAGE_MEASUREMENT == 1U))
#if (MOTOR0_BLDC_SCALAR_ENABLE_AMPLIFIER_OFFSET_CALIBRATION == 1U)

void Motor0_BLDC_SCALAR_AmpBiasVoltCalibration(void)
{
 802088c:	b580      	push	{r7, lr}
 802088e:	b086      	sub	sp, #24
 8020890:	af00      	add	r7, sp, #0
  uint32_t amp_offset = 0U;      /* current amplifier offset value */
 8020892:	2300      	movs	r3, #0
 8020894:	617b      	str	r3, [r7, #20]
  uint32_t count;                /* for loop count */
  volatile uint32_t delay;       /* ADC conversion delay counter */
  uint32_t vadc_conversion_time_dealy = BLDC_SCALAR_VADC_CONVERSION_DELAY;  /* ADC conversion delay */
 8020896:	230f      	movs	r3, #15
 8020898:	60fb      	str	r3, [r7, #12]
  Motor0_BLDC_SCALAR_CurrentMeasurement.avg_dc_amplifier_offset = (int32_t) temp_ampoffset;
#endif  /* end of MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_AVERAGE_MEASUREMENT */

  /* Direct DC link current */
#if(MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U)
  amp_offset = 0U;
 802089a:	2300      	movs	r3, #0
 802089c:	617b      	str	r3, [r7, #20]
  /* SW trigger for direct DC link current channel and measure the amplifier bias voltage */
  /* Calibration is done with average of 16 measurements */
  for (count = 0U; count < BLDC_SCALAR_ADCCAL_COUNT; count++)
 802089e:	2300      	movs	r3, #0
 80208a0:	613b      	str	r3, [r7, #16]
 80208a2:	e019      	b.n	80208d8 <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration+0x4c>
  {
    XMC_VADC_GROUP_QueueTriggerConversion(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP);
 80208a4:	4813      	ldr	r0, [pc, #76]	; (80208f4 <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration+0x68>)
 80208a6:	f7ff ff75 	bl	8020794 <XMC_VADC_GROUP_QueueTriggerConversion>
    /* VADC queue measurements conversion time delay */
    for (delay = 0U; delay < vadc_conversion_time_dealy; delay++)
 80208aa:	2300      	movs	r3, #0
 80208ac:	607b      	str	r3, [r7, #4]
 80208ae:	e002      	b.n	80208b6 <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration+0x2a>
 80208b0:	687b      	ldr	r3, [r7, #4]
 80208b2:	3301      	adds	r3, #1
 80208b4:	607b      	str	r3, [r7, #4]
 80208b6:	687b      	ldr	r3, [r7, #4]
 80208b8:	68fa      	ldr	r2, [r7, #12]
 80208ba:	429a      	cmp	r2, r3
 80208bc:	d8f8      	bhi.n	80208b0 <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration+0x24>
    {

    }
    temp_ampoffset = (uint32_t) (VADC_GetResult(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP, MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_RES_REG_NUM));
 80208be:	2105      	movs	r1, #5
 80208c0:	480c      	ldr	r0, [pc, #48]	; (80208f4 <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration+0x68>)
 80208c2:	f7ff ffac 	bl	802081e <VADC_GetResult>
 80208c6:	4603      	mov	r3, r0
 80208c8:	60bb      	str	r3, [r7, #8]
    amp_offset = amp_offset + temp_ampoffset;
 80208ca:	697a      	ldr	r2, [r7, #20]
 80208cc:	68bb      	ldr	r3, [r7, #8]
 80208ce:	4413      	add	r3, r2
 80208d0:	617b      	str	r3, [r7, #20]
  for (count = 0U; count < BLDC_SCALAR_ADCCAL_COUNT; count++)
 80208d2:	693b      	ldr	r3, [r7, #16]
 80208d4:	3301      	adds	r3, #1
 80208d6:	613b      	str	r3, [r7, #16]
 80208d8:	693b      	ldr	r3, [r7, #16]
 80208da:	2b0f      	cmp	r3, #15
 80208dc:	d9e2      	bls.n	80208a4 <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration+0x18>
  }
  temp_ampoffset = ((uint32_t)amp_offset >> (uint32_t)BLDC_SCALAR_ADCCAL_SHIFT_4);
 80208de:	697b      	ldr	r3, [r7, #20]
 80208e0:	091b      	lsrs	r3, r3, #4
 80208e2:	60bb      	str	r3, [r7, #8]
  Motor0_BLDC_SCALAR_CurrentMeasurement.direct_dc_amplifier_offset = (int32_t) temp_ampoffset;
 80208e4:	68bb      	ldr	r3, [r7, #8]
 80208e6:	4a04      	ldr	r2, [pc, #16]	; (80208f8 <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration+0x6c>)
 80208e8:	6013      	str	r3, [r2, #0]
#endif /* end of MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT */


}
 80208ea:	bf00      	nop
 80208ec:	3718      	adds	r7, #24
 80208ee:	46bd      	mov	sp, r7
 80208f0:	bd80      	pop	{r7, pc}
 80208f2:	bf00      	nop
 80208f4:	40005000 	.word	0x40005000
 80208f8:	1ffe92e8 	.word	0x1ffe92e8

080208fc <XMC_SCU_SetCcuTriggerLow>:
 * the timer using this API.<BR>
 * \par<b>Related APIs:</b><BR>
 * XMC_CCU4_SLICE_StartConfig(), XMC_CCU4_SLICE_SetInput(), XMC_SCU_SetCcuTriggerHigh()\n\n\n
 */
__STATIC_INLINE void XMC_SCU_SetCcuTriggerLow(const uint32_t trigger)
{
 80208fc:	b480      	push	{r7}
 80208fe:	b083      	sub	sp, #12
 8020900:	af00      	add	r7, sp, #0
 8020902:	6078      	str	r0, [r7, #4]
  SCU_GENERAL->CCUCON &= (uint32_t)~trigger;
 8020904:	4b06      	ldr	r3, [pc, #24]	; (8020920 <XMC_SCU_SetCcuTriggerLow+0x24>)
 8020906:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8020908:	687b      	ldr	r3, [r7, #4]
 802090a:	43db      	mvns	r3, r3
 802090c:	4904      	ldr	r1, [pc, #16]	; (8020920 <XMC_SCU_SetCcuTriggerLow+0x24>)
 802090e:	4013      	ands	r3, r2
 8020910:	64cb      	str	r3, [r1, #76]	; 0x4c
}
 8020912:	bf00      	nop
 8020914:	370c      	adds	r7, #12
 8020916:	46bd      	mov	sp, r7
 8020918:	f85d 7b04 	ldr.w	r7, [sp], #4
 802091c:	4770      	bx	lr
 802091e:	bf00      	nop
 8020920:	50004000 	.word	0x50004000

08020924 <XMC_GPIO_SetOutputHigh>:
 * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value of 0.
 *
 */

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
 8020924:	b480      	push	{r7}
 8020926:	b083      	sub	sp, #12
 8020928:	af00      	add	r7, sp, #0
 802092a:	6078      	str	r0, [r7, #4]
 802092c:	460b      	mov	r3, r1
 802092e:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8020930:	78fb      	ldrb	r3, [r7, #3]
 8020932:	2201      	movs	r2, #1
 8020934:	409a      	lsls	r2, r3
 8020936:	687b      	ldr	r3, [r7, #4]
 8020938:	605a      	str	r2, [r3, #4]
}
 802093a:	bf00      	nop
 802093c:	370c      	adds	r7, #12
 802093e:	46bd      	mov	sp, r7
 8020940:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020944:	4770      	bx	lr

08020946 <XMC_GPIO_SetOutputLow>:
 * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value of 0.\n
 *
 */

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
 8020946:	b480      	push	{r7}
 8020948:	b083      	sub	sp, #12
 802094a:	af00      	add	r7, sp, #0
 802094c:	6078      	str	r0, [r7, #4]
 802094e:	460b      	mov	r3, r1
 8020950:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8020952:	78fb      	ldrb	r3, [r7, #3]
 8020954:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8020958:	409a      	lsls	r2, r3
 802095a:	687b      	ldr	r3, [r7, #4]
 802095c:	605a      	str	r2, [r3, #4]
}
 802095e:	bf00      	nop
 8020960:	370c      	adds	r7, #12
 8020962:	46bd      	mov	sp, r7
 8020964:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020968:	4770      	bx	lr

0802096a <Motor0_BLDC_SCALAR_CCU8_PWM_Stop>:
 *
 * \par<b>Description:</b><br>
 * Set CCUCON trigger signal to low to stop all slices.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_CCU8_PWM_Stop(void)
{
 802096a:	b580      	push	{r7, lr}
 802096c:	af00      	add	r7, sp, #0
  /* Pull CCUCON signal to low */
  XMC_SCU_SetCcuTriggerLow((uint32_t)MOTOR0_BLDC_SCALAR_CCU8_SYNC_START);
 802096e:	f44f 7080 	mov.w	r0, #256	; 0x100
 8020972:	f7ff ffc3 	bl	80208fc <XMC_SCU_SetCcuTriggerLow>
}
 8020976:	bf00      	nop
 8020978:	bd80      	pop	{r7, pc}

0802097a <Motor0_BLDC_SCALAR_CCU8_EnableDeadTime>:
 *
 * \par<b>Description:</b><br>
 * Enable the dead time for compare channel and ST path.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_CCU8_EnableDeadTime(XMC_CCU8_SLICE_t * phase_ptr, const uint8_t channel_mask)
{
 802097a:	b480      	push	{r7}
 802097c:	b083      	sub	sp, #12
 802097e:	af00      	add	r7, sp, #0
 8020980:	6078      	str	r0, [r7, #4]
 8020982:	460b      	mov	r3, r1
 8020984:	70fb      	strb	r3, [r7, #3]
  phase_ptr->DTC |= (uint32_t)channel_mask;
 8020986:	687b      	ldr	r3, [r7, #4]
 8020988:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 802098a:	78fb      	ldrb	r3, [r7, #3]
 802098c:	431a      	orrs	r2, r3
 802098e:	687b      	ldr	r3, [r7, #4]
 8020990:	64da      	str	r2, [r3, #76]	; 0x4c

}
 8020992:	bf00      	nop
 8020994:	370c      	adds	r7, #12
 8020996:	46bd      	mov	sp, r7
 8020998:	f85d 7b04 	ldr.w	r7, [sp], #4
 802099c:	4770      	bx	lr

0802099e <Motor0_BLDC_SCALAR_CCU8_DisableDeadTime>:
 *
 * \par<b>Description:</b><br>
 * Disable the dead time for compare channel and ST path.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_CCU8_DisableDeadTime(XMC_CCU8_SLICE_t * phase_ptr, const uint8_t channel_mask)
{
 802099e:	b480      	push	{r7}
 80209a0:	b083      	sub	sp, #12
 80209a2:	af00      	add	r7, sp, #0
 80209a4:	6078      	str	r0, [r7, #4]
 80209a6:	460b      	mov	r3, r1
 80209a8:	70fb      	strb	r3, [r7, #3]
  phase_ptr->DTC &= ~(uint32_t)channel_mask;
 80209aa:	687b      	ldr	r3, [r7, #4]
 80209ac:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80209ae:	78fb      	ldrb	r3, [r7, #3]
 80209b0:	43db      	mvns	r3, r3
 80209b2:	401a      	ands	r2, r3
 80209b4:	687b      	ldr	r3, [r7, #4]
 80209b6:	64da      	str	r2, [r3, #76]	; 0x4c
}
 80209b8:	bf00      	nop
 80209ba:	370c      	adds	r7, #12
 80209bc:	46bd      	mov	sp, r7
 80209be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80209c2:	4770      	bx	lr

080209c4 <Motor0_BLDC_SCALAR_PWM_BC_Init>:
 * -Trap pin and
 * -Inverter pin as per user configurations.
 * Initialize the variable ph_cmpval[1] with (period value + 1), Used for 0% duty cycle
 */
void Motor0_BLDC_SCALAR_PWM_BC_Init(void)
{
 80209c4:	b580      	push	{r7, lr}
 80209c6:	af00      	add	r7, sp, #0
  /*initialize PWM timer slices*/
  Motor0_BLDC_SCALAR_CCU8_PWM_Init();
 80209c8:	f000 faac 	bl	8020f24 <Motor0_BLDC_SCALAR_CCU8_PWM_Init>
  /*initialize PWM output pins*/
  Motor0_BLDC_SCALAR_GPIO_PWM_Init();
 80209cc:	f000 fae0 	bl	8020f90 <Motor0_BLDC_SCALAR_GPIO_PWM_Init>
  /*initialize Trap pin*/
  Motor0_BLDC_SCALAR_GPIO_Trap_Init();
#endif
#if (MOTOR0_BLDC_SCALAR_INVERTER_ENABLE_CONF != BLDC_SCALAR_INV_DISABLED)
  /*initialize Inverter pin*/
  Motor0_BLDC_SCALAR_GPIO_Inverter_Init();
 80209d0:	f000 fb28 	bl	8021024 <Motor0_BLDC_SCALAR_GPIO_Inverter_Init>
#endif

  /*configure variable ph_cmpval[1] with 0% duty*/
  Motor0_BLDC_SCALAR_PWM_BC.ph_cmpval[1] = Motor0_BLDC_SCALAR_CCU8_PWM_Config.period + (uint16_t)1;
 80209d4:	4b03      	ldr	r3, [pc, #12]	; (80209e4 <Motor0_BLDC_SCALAR_PWM_BC_Init+0x20>)
 80209d6:	8a5b      	ldrh	r3, [r3, #18]
 80209d8:	3301      	adds	r3, #1
 80209da:	b29a      	uxth	r2, r3
 80209dc:	4b02      	ldr	r3, [pc, #8]	; (80209e8 <Motor0_BLDC_SCALAR_PWM_BC_Init+0x24>)
 80209de:	841a      	strh	r2, [r3, #32]

}
 80209e0:	bf00      	nop
 80209e2:	bd80      	pop	{r7, pc}
 80209e4:	1ffe9228 	.word	0x1ffe9228
 80209e8:	1ffe9294 	.word	0x1ffe9294

080209ec <Motor0_BLDC_SCALAR_PWM_BC_Stop>:
/*
 * This function reset the inverter pin output level and
 * stop the CCU8 slices.
 */
void  Motor0_BLDC_SCALAR_PWM_BC_Stop(void)
{
 80209ec:	b580      	push	{r7, lr}
 80209ee:	af00      	add	r7, sp, #0
  /*Disable Inverter*/
#if (MOTOR0_BLDC_SCALAR_INVERTER_ENABLE_CONF != BLDC_SCALAR_INV_DISABLED)
  Motor0_BLDC_SCALAR_PWM_BC_InverterDisable();
 80209f0:	f000 f81c 	bl	8020a2c <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable>
#endif
  /* Stop pwm timers*/
  Motor0_BLDC_SCALAR_CCU8_PWM_Stop();
 80209f4:	f7ff ffb9 	bl	802096a <Motor0_BLDC_SCALAR_CCU8_PWM_Stop>
}
 80209f8:	bf00      	nop
 80209fa:	bd80      	pop	{r7, pc}

080209fc <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable>:
/*
 * This function set the inverter pin output level low and high
 * Based on inverter_pin configuration.
 */
void Motor0_BLDC_SCALAR_PWM_BC_InverterEnable(void)
{
 80209fc:	b580      	push	{r7, lr}
 80209fe:	af00      	add	r7, sp, #0
  if (PWM_BC_IPIN_HIGH == Motor0_BLDC_SCALAR_PWM_BC.inverter_pin)
 8020a00:	4b08      	ldr	r3, [pc, #32]	; (8020a24 <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable+0x28>)
 8020a02:	7b5b      	ldrb	r3, [r3, #13]
 8020a04:	2b01      	cmp	r3, #1
 8020a06:	d103      	bne.n	8020a10 <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable+0x14>
  {
    XMC_GPIO_SetOutputHigh(MOTOR0_BLDC_SCALAR_GPIO_INV_ENABLE);
 8020a08:	210b      	movs	r1, #11
 8020a0a:	4807      	ldr	r0, [pc, #28]	; (8020a28 <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable+0x2c>)
 8020a0c:	f7ff ff8a 	bl	8020924 <XMC_GPIO_SetOutputHigh>
  }
  if (PWM_BC_IPIN_LOW == Motor0_BLDC_SCALAR_PWM_BC.inverter_pin)
 8020a10:	4b04      	ldr	r3, [pc, #16]	; (8020a24 <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable+0x28>)
 8020a12:	7b5b      	ldrb	r3, [r3, #13]
 8020a14:	2b02      	cmp	r3, #2
 8020a16:	d103      	bne.n	8020a20 <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable+0x24>
  {
    XMC_GPIO_SetOutputLow(MOTOR0_BLDC_SCALAR_GPIO_INV_ENABLE);
 8020a18:	210b      	movs	r1, #11
 8020a1a:	4803      	ldr	r0, [pc, #12]	; (8020a28 <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable+0x2c>)
 8020a1c:	f7ff ff93 	bl	8020946 <XMC_GPIO_SetOutputLow>
  }
}
 8020a20:	bf00      	nop
 8020a22:	bd80      	pop	{r7, pc}
 8020a24:	1ffe9294 	.word	0x1ffe9294
 8020a28:	48028200 	.word	0x48028200

08020a2c <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable>:
/*
 * This function set the inverter pin output level low
 * if inverter_pin is high and vice versa.
 */
void Motor0_BLDC_SCALAR_PWM_BC_InverterDisable(void)
{
 8020a2c:	b580      	push	{r7, lr}
 8020a2e:	af00      	add	r7, sp, #0
  if (PWM_BC_IPIN_HIGH == Motor0_BLDC_SCALAR_PWM_BC.inverter_pin)
 8020a30:	4b08      	ldr	r3, [pc, #32]	; (8020a54 <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable+0x28>)
 8020a32:	7b5b      	ldrb	r3, [r3, #13]
 8020a34:	2b01      	cmp	r3, #1
 8020a36:	d103      	bne.n	8020a40 <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable+0x14>
  {
    XMC_GPIO_SetOutputLow(MOTOR0_BLDC_SCALAR_GPIO_INV_ENABLE);
 8020a38:	210b      	movs	r1, #11
 8020a3a:	4807      	ldr	r0, [pc, #28]	; (8020a58 <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable+0x2c>)
 8020a3c:	f7ff ff83 	bl	8020946 <XMC_GPIO_SetOutputLow>
  }
  if (PWM_BC_IPIN_LOW == Motor0_BLDC_SCALAR_PWM_BC.inverter_pin)
 8020a40:	4b04      	ldr	r3, [pc, #16]	; (8020a54 <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable+0x28>)
 8020a42:	7b5b      	ldrb	r3, [r3, #13]
 8020a44:	2b02      	cmp	r3, #2
 8020a46:	d103      	bne.n	8020a50 <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable+0x24>
  {
    XMC_GPIO_SetOutputHigh(MOTOR0_BLDC_SCALAR_GPIO_INV_ENABLE);
 8020a48:	210b      	movs	r1, #11
 8020a4a:	4803      	ldr	r0, [pc, #12]	; (8020a58 <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable+0x2c>)
 8020a4c:	f7ff ff6a 	bl	8020924 <XMC_GPIO_SetOutputHigh>
  }
}
 8020a50:	bf00      	nop
 8020a52:	bd80      	pop	{r7, pc}
 8020a54:	1ffe9294 	.word	0x1ffe9294
 8020a58:	48028200 	.word	0x48028200

08020a5c <__NVIC_ClearPendingIRQ>:
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
 8020a5c:	b480      	push	{r7}
 8020a5e:	b083      	sub	sp, #12
 8020a60:	af00      	add	r7, sp, #0
 8020a62:	4603      	mov	r3, r0
 8020a64:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8020a66:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8020a6a:	2b00      	cmp	r3, #0
 8020a6c:	db0c      	blt.n	8020a88 <__NVIC_ClearPendingIRQ+0x2c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8020a6e:	79fb      	ldrb	r3, [r7, #7]
 8020a70:	f003 021f 	and.w	r2, r3, #31
 8020a74:	4907      	ldr	r1, [pc, #28]	; (8020a94 <__NVIC_ClearPendingIRQ+0x38>)
 8020a76:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8020a7a:	095b      	lsrs	r3, r3, #5
 8020a7c:	2001      	movs	r0, #1
 8020a7e:	fa00 f202 	lsl.w	r2, r0, r2
 8020a82:	3360      	adds	r3, #96	; 0x60
 8020a84:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
 8020a88:	bf00      	nop
 8020a8a:	370c      	adds	r7, #12
 8020a8c:	46bd      	mov	sp, r7
 8020a8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020a92:	4770      	bx	lr
 8020a94:	e000e100 	.word	0xe000e100

08020a98 <XMC_CCU4_SLICE_StartTimer>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StartTimer(XMC_CCU4_SLICE_t *const slice)
{
 8020a98:	b480      	push	{r7}
 8020a9a:	b083      	sub	sp, #12
 8020a9c:	af00      	add	r7, sp, #0
 8020a9e:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
 8020aa0:	687b      	ldr	r3, [r7, #4]
 8020aa2:	2201      	movs	r2, #1
 8020aa4:	60da      	str	r2, [r3, #12]
}
 8020aa6:	bf00      	nop
 8020aa8:	370c      	adds	r7, #12
 8020aaa:	46bd      	mov	sp, r7
 8020aac:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020ab0:	4770      	bx	lr

08020ab2 <XMC_CCU4_SLICE_StopTimer>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StopTimer(XMC_CCU4_SLICE_t *const slice)
{
 8020ab2:	b480      	push	{r7}
 8020ab4:	b083      	sub	sp, #12
 8020ab6:	af00      	add	r7, sp, #0
 8020ab8:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_StopTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TRBC_Msk;
 8020aba:	687b      	ldr	r3, [r7, #4]
 8020abc:	2201      	movs	r2, #1
 8020abe:	611a      	str	r2, [r3, #16]
}
 8020ac0:	bf00      	nop
 8020ac2:	370c      	adds	r7, #12
 8020ac4:	46bd      	mov	sp, r7
 8020ac6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020aca:	4770      	bx	lr

08020acc <XMC_CCU4_SLICE_ClearTimer>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_ClearTimer(XMC_CCU4_SLICE_t *const slice)
{
 8020acc:	b480      	push	{r7}
 8020ace:	b083      	sub	sp, #12
 8020ad0:	af00      	add	r7, sp, #0
 8020ad2:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TCC_Msk;
 8020ad4:	687b      	ldr	r3, [r7, #4]
 8020ad6:	2202      	movs	r2, #2
 8020ad8:	611a      	str	r2, [r3, #16]
}
 8020ada:	bf00      	nop
 8020adc:	370c      	adds	r7, #12
 8020ade:	46bd      	mov	sp, r7
 8020ae0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020ae4:	4770      	bx	lr

08020ae6 <XMC_POSIF_Start>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_POSIF_Stop(),XMC_POSIF_IsRunning() \n\n\n
 */
__STATIC_INLINE void XMC_POSIF_Start(XMC_POSIF_t *const peripheral)
{
 8020ae6:	b480      	push	{r7}
 8020ae8:	b083      	sub	sp, #12
 8020aea:	af00      	add	r7, sp, #0
 8020aec:	6078      	str	r0, [r7, #4]
  peripheral->PRUNS = (uint32_t)POSIF_PRUNS_SRB_Msk;
 8020aee:	687b      	ldr	r3, [r7, #4]
 8020af0:	2201      	movs	r2, #1
 8020af2:	609a      	str	r2, [r3, #8]
}
 8020af4:	bf00      	nop
 8020af6:	370c      	adds	r7, #12
 8020af8:	46bd      	mov	sp, r7
 8020afa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020afe:	4770      	bx	lr

08020b00 <XMC_POSIF_Stop>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_POSIF_Start(),XMC_POSIF_IsRunning() \n\n\n
 */
__STATIC_INLINE void XMC_POSIF_Stop(XMC_POSIF_t *const peripheral)
{
 8020b00:	b480      	push	{r7}
 8020b02:	b083      	sub	sp, #12
 8020b04:	af00      	add	r7, sp, #0
 8020b06:	6078      	str	r0, [r7, #4]
  peripheral->PRUNC = (uint32_t)(POSIF_PRUNC_CRB_Msk | POSIF_PRUNC_CSM_Msk);
 8020b08:	687b      	ldr	r3, [r7, #4]
 8020b0a:	2203      	movs	r2, #3
 8020b0c:	60da      	str	r2, [r3, #12]
}
 8020b0e:	bf00      	nop
 8020b10:	370c      	adds	r7, #12
 8020b12:	46bd      	mov	sp, r7
 8020b14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020b18:	4770      	bx	lr

08020b1a <XMC_GPIO_GetInput>:
 * Prior to this api, user has to configure port pin to input mode using XMC_GPIO_SetMode().
 *
 */

__STATIC_INLINE uint32_t XMC_GPIO_GetInput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
 8020b1a:	b480      	push	{r7}
 8020b1c:	b083      	sub	sp, #12
 8020b1e:	af00      	add	r7, sp, #0
 8020b20:	6078      	str	r0, [r7, #4]
 8020b22:	460b      	mov	r3, r1
 8020b24:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_GPIO_GetInput: Invalid port", XMC_GPIO_CHECK_PORT(port));

  return (((port->IN) >> pin) & 0x1U);
 8020b26:	687b      	ldr	r3, [r7, #4]
 8020b28:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8020b2a:	78fb      	ldrb	r3, [r7, #3]
 8020b2c:	fa22 f303 	lsr.w	r3, r2, r3
 8020b30:	f003 0301 	and.w	r3, r3, #1
}
 8020b34:	4618      	mov	r0, r3
 8020b36:	370c      	adds	r7, #12
 8020b38:	46bd      	mov	sp, r7
 8020b3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020b3e:	4770      	bx	lr

08020b40 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter>:
 *
 * \par<b>Description:</b><br>
 * Resets variables related to speed calculation.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter(void)
{
 8020b40:	b480      	push	{r7}
 8020b42:	af00      	add	r7, sp, #0
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex = 0U;
 8020b44:	4b12      	ldr	r3, [pc, #72]	; (8020b90 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b46:	2200      	movs	r2, #0
 8020b48:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedcheck = 0U;
 8020b4c:	4b10      	ldr	r3, [pc, #64]	; (8020b90 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b4e:	2200      	movs	r2, #0
 8020b50:	61da      	str	r2, [r3, #28]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[0] = 0U;
 8020b52:	4b0f      	ldr	r3, [pc, #60]	; (8020b90 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b54:	2200      	movs	r2, #0
 8020b56:	601a      	str	r2, [r3, #0]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[1] = 0U;
 8020b58:	4b0d      	ldr	r3, [pc, #52]	; (8020b90 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b5a:	2200      	movs	r2, #0
 8020b5c:	605a      	str	r2, [r3, #4]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[2] = 0U;
 8020b5e:	4b0c      	ldr	r3, [pc, #48]	; (8020b90 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b60:	2200      	movs	r2, #0
 8020b62:	609a      	str	r2, [r3, #8]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[3] = 0U;
 8020b64:	4b0a      	ldr	r3, [pc, #40]	; (8020b90 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b66:	2200      	movs	r2, #0
 8020b68:	60da      	str	r2, [r3, #12]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[4] = 0U;
 8020b6a:	4b09      	ldr	r3, [pc, #36]	; (8020b90 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b6c:	2200      	movs	r2, #0
 8020b6e:	611a      	str	r2, [r3, #16]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[5] = 0U;
 8020b70:	4b07      	ldr	r3, [pc, #28]	; (8020b90 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b72:	2200      	movs	r2, #0
 8020b74:	615a      	str	r2, [r3, #20]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.capval = Motor0_BLDC_SCALAR_SPEED_POS_HALL.speed_constant;
 8020b76:	4b06      	ldr	r3, [pc, #24]	; (8020b90 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b78:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8020b7a:	4a05      	ldr	r2, [pc, #20]	; (8020b90 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b7c:	6193      	str	r3, [r2, #24]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum = 0U;
 8020b7e:	4b04      	ldr	r3, [pc, #16]	; (8020b90 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8020b80:	2200      	movs	r2, #0
 8020b82:	621a      	str	r2, [r3, #32]
}
 8020b84:	bf00      	nop
 8020b86:	46bd      	mov	sp, r7
 8020b88:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020b8c:	4770      	bx	lr
 8020b8e:	bf00      	nop
 8020b90:	1ffe92bc 	.word	0x1ffe92bc

08020b94 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Init>:
/*
 * Initialize POSIF and CCU4 peripherals
 * Initialize hall sensor input pins.
 */
void Motor0_BLDC_SCALAR_SPEED_POS_HALL_Init()
{
 8020b94:	b580      	push	{r7, lr}
 8020b96:	af00      	add	r7, sp, #0
  Motor0_BLDC_SCALAR_POSIF_3Hall_Init();
 8020b98:	f000 fb10 	bl	80211bc <Motor0_BLDC_SCALAR_POSIF_3Hall_Init>
  Motor0_BLDC_SCALAR_CCU4_3Hall_Init();
 8020b9c:	f000 f8c4 	bl	8020d28 <Motor0_BLDC_SCALAR_CCU4_3Hall_Init>
  Motor0_BLDC_SCALAR_GPIO_3Hall_Init();
 8020ba0:	f000 fa28 	bl	8020ff4 <Motor0_BLDC_SCALAR_GPIO_3Hall_Init>
}
 8020ba4:	bf00      	nop
 8020ba6:	bd80      	pop	{r7, pc}

08020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start>:

/*
 * Start POSIF and CCU4 timer.
 */
void Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start()
{
 8020ba8:	b580      	push	{r7, lr}
 8020baa:	af00      	add	r7, sp, #0
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter();
 8020bac:	f7ff ffc8 	bl	8020b40 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter>

  /*
   * Set RUN bit of the POSIF and
   * CC41 First slice will be started on external start trigger
   */
  XMC_POSIF_Start(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8020bb0:	4806      	ldr	r0, [pc, #24]	; (8020bcc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start+0x24>)
 8020bb2:	f7ff ff98 	bl	8020ae6 <XMC_POSIF_Start>

  XMC_CCU4_SLICE_ClearTimer(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE);
 8020bb6:	4806      	ldr	r0, [pc, #24]	; (8020bd0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start+0x28>)
 8020bb8:	f7ff ff88 	bl	8020acc <XMC_CCU4_SLICE_ClearTimer>
  XMC_CCU4_SLICE_ClearTimer(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE);
 8020bbc:	4805      	ldr	r0, [pc, #20]	; (8020bd4 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start+0x2c>)
 8020bbe:	f7ff ff85 	bl	8020acc <XMC_CCU4_SLICE_ClearTimer>

  XMC_CCU4_SLICE_StartTimer(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE);
 8020bc2:	4804      	ldr	r0, [pc, #16]	; (8020bd4 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start+0x2c>)
 8020bc4:	f7ff ff68 	bl	8020a98 <XMC_CCU4_SLICE_StartTimer>

}
 8020bc8:	bf00      	nop
 8020bca:	bd80      	pop	{r7, pc}
 8020bcc:	40028000 	.word	0x40028000
 8020bd0:	4000c100 	.word	0x4000c100
 8020bd4:	4000c200 	.word	0x4000c200

08020bd8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Stop>:

/*
 * Stop POSIF and CCU4 timer.
 */
void Motor0_BLDC_SCALAR_SPEED_POS_HALL_Stop()
{
 8020bd8:	b580      	push	{r7, lr}
 8020bda:	af00      	add	r7, sp, #0
  XMC_POSIF_Stop(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8020bdc:	4806      	ldr	r0, [pc, #24]	; (8020bf8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Stop+0x20>)
 8020bde:	f7ff ff8f 	bl	8020b00 <XMC_POSIF_Stop>
  NVIC_ClearPendingIRQ(MOTOR0_BLDC_SCALAR_HALL_EVENT_NODE);
 8020be2:	2044      	movs	r0, #68	; 0x44
 8020be4:	f7ff ff3a 	bl	8020a5c <__NVIC_ClearPendingIRQ>
  XMC_CCU4_SLICE_StopTimer(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE);
 8020be8:	4804      	ldr	r0, [pc, #16]	; (8020bfc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Stop+0x24>)
 8020bea:	f7ff ff62 	bl	8020ab2 <XMC_CCU4_SLICE_StopTimer>
  XMC_CCU4_SLICE_StopTimer(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE);
 8020bee:	4804      	ldr	r0, [pc, #16]	; (8020c00 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Stop+0x28>)
 8020bf0:	f7ff ff5f 	bl	8020ab2 <XMC_CCU4_SLICE_StopTimer>
}
 8020bf4:	bf00      	nop
 8020bf6:	bd80      	pop	{r7, pc}
 8020bf8:	40028000 	.word	0x40028000
 8020bfc:	4000c100 	.word	0x4000c100
 8020c00:	4000c200 	.word	0x4000c200

08020c04 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition>:
 * This function will return the current state of the POSIF input pins to
 * which hall sensors are connected. This information is required before
 * starting the motor to know the start position of the motor.
 */
uint32_t Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition(void)
{
 8020c04:	b580      	push	{r7, lr}
 8020c06:	b084      	sub	sp, #16
 8020c08:	af00      	add	r7, sp, #0
  uint32_t hallposition;
  uint32_t hall[3] = { 0U };
 8020c0a:	463b      	mov	r3, r7
 8020c0c:	2200      	movs	r2, #0
 8020c0e:	601a      	str	r2, [r3, #0]
 8020c10:	605a      	str	r2, [r3, #4]
 8020c12:	609a      	str	r2, [r3, #8]

  /*Read the input pins.*/
  hall[0] = XMC_GPIO_GetInput(MOTOR0_BLDC_SCALAR_GPIO_HALL_1);
 8020c14:	2103      	movs	r1, #3
 8020c16:	4811      	ldr	r0, [pc, #68]	; (8020c5c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition+0x58>)
 8020c18:	f7ff ff7f 	bl	8020b1a <XMC_GPIO_GetInput>
 8020c1c:	4603      	mov	r3, r0
 8020c1e:	603b      	str	r3, [r7, #0]
  hall[1] = XMC_GPIO_GetInput(MOTOR0_BLDC_SCALAR_GPIO_HALL_2);
 8020c20:	2102      	movs	r1, #2
 8020c22:	480e      	ldr	r0, [pc, #56]	; (8020c5c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition+0x58>)
 8020c24:	f7ff ff79 	bl	8020b1a <XMC_GPIO_GetInput>
 8020c28:	4603      	mov	r3, r0
 8020c2a:	607b      	str	r3, [r7, #4]
  hallposition = (uint32_t)(hall[0] | ((uint32_t) hall[1] << 1U));
 8020c2c:	683a      	ldr	r2, [r7, #0]
 8020c2e:	687b      	ldr	r3, [r7, #4]
 8020c30:	005b      	lsls	r3, r3, #1
 8020c32:	4313      	orrs	r3, r2
 8020c34:	60fb      	str	r3, [r7, #12]

  hall[2] = XMC_GPIO_GetInput(MOTOR0_BLDC_SCALAR_GPIO_HALL_3);
 8020c36:	2101      	movs	r1, #1
 8020c38:	4808      	ldr	r0, [pc, #32]	; (8020c5c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition+0x58>)
 8020c3a:	f7ff ff6e 	bl	8020b1a <XMC_GPIO_GetInput>
 8020c3e:	4603      	mov	r3, r0
 8020c40:	60bb      	str	r3, [r7, #8]
  hallposition |= ((uint32_t)(hall[2] << BLDC_SCALAR_SPEED_POS_HALL_2_POS));
 8020c42:	68bb      	ldr	r3, [r7, #8]
 8020c44:	009b      	lsls	r3, r3, #2
 8020c46:	68fa      	ldr	r2, [r7, #12]
 8020c48:	4313      	orrs	r3, r2
 8020c4a:	60fb      	str	r3, [r7, #12]


  return ((uint32_t)(hallposition & BLDC_SCALAR_SPEED_POS_HALL_MASK));
 8020c4c:	68fb      	ldr	r3, [r7, #12]
 8020c4e:	f003 0307 	and.w	r3, r3, #7
}
 8020c52:	4618      	mov	r0, r3
 8020c54:	3710      	adds	r7, #16
 8020c56:	46bd      	mov	sp, r7
 8020c58:	bd80      	pop	{r7, pc}
 8020c5a:	bf00      	nop
 8020c5c:	48028100 	.word	0x48028100

08020c60 <XMC_CCU4_EnableClock>:
{
 8020c60:	b480      	push	{r7}
 8020c62:	b083      	sub	sp, #12
 8020c64:	af00      	add	r7, sp, #0
 8020c66:	6078      	str	r0, [r7, #4]
 8020c68:	460b      	mov	r3, r1
 8020c6a:	70fb      	strb	r3, [r7, #3]
  module->GIDLC = ((uint32_t) 1) << slice_number;
 8020c6c:	78fb      	ldrb	r3, [r7, #3]
 8020c6e:	2201      	movs	r2, #1
 8020c70:	409a      	lsls	r2, r3
 8020c72:	687b      	ldr	r3, [r7, #4]
 8020c74:	60da      	str	r2, [r3, #12]
}
 8020c76:	bf00      	nop
 8020c78:	370c      	adds	r7, #12
 8020c7a:	46bd      	mov	sp, r7
 8020c7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020c80:	4770      	bx	lr

08020c82 <XMC_CCU4_SLICE_SetTimerPeriodMatch>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t period_val)
{
 8020c82:	b480      	push	{r7}
 8020c84:	b083      	sub	sp, #12
 8020c86:	af00      	add	r7, sp, #0
 8020c88:	6078      	str	r0, [r7, #4]
 8020c8a:	460b      	mov	r3, r1
 8020c8c:	807b      	strh	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 8020c8e:	887a      	ldrh	r2, [r7, #2]
 8020c90:	687b      	ldr	r3, [r7, #4]
 8020c92:	635a      	str	r2, [r3, #52]	; 0x34
}
 8020c94:	bf00      	nop
 8020c96:	370c      	adds	r7, #12
 8020c98:	46bd      	mov	sp, r7
 8020c9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020c9e:	4770      	bx	lr

08020ca0 <XMC_CCU4_SLICE_SetTimerCompareMatch>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t compare_val)
{
 8020ca0:	b480      	push	{r7}
 8020ca2:	b083      	sub	sp, #12
 8020ca4:	af00      	add	r7, sp, #0
 8020ca6:	6078      	str	r0, [r7, #4]
 8020ca8:	460b      	mov	r3, r1
 8020caa:	807b      	strh	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->CRS = (uint32_t) compare_val;
 8020cac:	887a      	ldrh	r2, [r7, #2]
 8020cae:	687b      	ldr	r3, [r7, #4]
 8020cb0:	63da      	str	r2, [r3, #60]	; 0x3c
}
 8020cb2:	bf00      	nop
 8020cb4:	370c      	adds	r7, #12
 8020cb6:	46bd      	mov	sp, r7
 8020cb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020cbc:	4770      	bx	lr

08020cbe <XMC_CCU4_EnableShadowTransfer>:
 *
 * \par<b>Related APIs:</b><br>
 *  None.
 */
__STATIC_INLINE void XMC_CCU4_EnableShadowTransfer(XMC_CCU4_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
 8020cbe:	b480      	push	{r7}
 8020cc0:	b083      	sub	sp, #12
 8020cc2:	af00      	add	r7, sp, #0
 8020cc4:	6078      	str	r0, [r7, #4]
 8020cc6:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU4_EnableShadowTransfer:Invalid Slice Pointer", XMC_CCU4_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;
 8020cc8:	687b      	ldr	r3, [r7, #4]
 8020cca:	683a      	ldr	r2, [r7, #0]
 8020ccc:	611a      	str	r2, [r3, #16]
}
 8020cce:	bf00      	nop
 8020cd0:	370c      	adds	r7, #12
 8020cd2:	46bd      	mov	sp, r7
 8020cd4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020cd8:	4770      	bx	lr

08020cda <XMC_CCU4_SLICE_EnableFloatingPrescaler>:
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_SetFloatingPrescalerCompareValue()<BR> XMC_CCU4_SLICE_DisableFloatingPrescaler()<BR>
 *  XMC_CCU4_SLICE_SetPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_EnableFloatingPrescaler(XMC_CCU4_SLICE_t *const slice)
{
 8020cda:	b480      	push	{r7}
 8020cdc:	b083      	sub	sp, #12
 8020cde:	af00      	add	r7, sp, #0
 8020ce0:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_EnableFloatingPrescaler:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TC |= (uint32_t) CCU4_CC4_TC_FPE_Msk;
 8020ce2:	687b      	ldr	r3, [r7, #4]
 8020ce4:	695b      	ldr	r3, [r3, #20]
 8020ce6:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 8020cea:	687b      	ldr	r3, [r7, #4]
 8020cec:	615a      	str	r2, [r3, #20]
}
 8020cee:	bf00      	nop
 8020cf0:	370c      	adds	r7, #12
 8020cf2:	46bd      	mov	sp, r7
 8020cf4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020cf8:	4770      	bx	lr

08020cfa <XMC_CCU4_SLICE_EnableEvent>:
 *  XMC_CCU4_SLICE_SetInterruptNode()<BR> XMC_CCU4_SLICE_EnableMultipleEvents()<BR> XMC_CCU4_SLICE_DisableEvent()<BR>
 *  XMC_CCU4_SLICE_DisableMultipleEvents().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_EnableEvent(XMC_CCU4_SLICE_t *const slice,
    const XMC_CCU4_SLICE_IRQ_ID_t event)
{
 8020cfa:	b480      	push	{r7}
 8020cfc:	b083      	sub	sp, #12
 8020cfe:	af00      	add	r7, sp, #0
 8020d00:	6078      	str	r0, [r7, #4]
 8020d02:	460b      	mov	r3, r1
 8020d04:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
 8020d06:	687b      	ldr	r3, [r7, #4]
 8020d08:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
 8020d0c:	78fb      	ldrb	r3, [r7, #3]
 8020d0e:	2101      	movs	r1, #1
 8020d10:	fa01 f303 	lsl.w	r3, r1, r3
 8020d14:	431a      	orrs	r2, r3
 8020d16:	687b      	ldr	r3, [r7, #4]
 8020d18:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
}
 8020d1c:	bf00      	nop
 8020d1e:	370c      	adds	r7, #12
 8020d20:	46bd      	mov	sp, r7
 8020d22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020d26:	4770      	bx	lr

08020d28 <Motor0_BLDC_SCALAR_CCU4_3Hall_Init>:
 *
 * \par<b>Description:</b><br>
 * CCU4 slices initialization for 3 hall feedback configuration.
 */
void Motor0_BLDC_SCALAR_CCU4_3Hall_Init(void)
{
 8020d28:	b580      	push	{r7, lr}
 8020d2a:	af00      	add	r7, sp, #0
  /* Enable CCU4 module */
  XMC_CCU4_Init(MOTOR0_BLDC_SCALAR_CCU4_MODULE,XMC_CCU4_SLICE_MCMS_ACTION_TRANSFER_PR_CR);
 8020d2c:	2100      	movs	r1, #0
 8020d2e:	4804      	ldr	r0, [pc, #16]	; (8020d40 <Motor0_BLDC_SCALAR_CCU4_3Hall_Init+0x18>)
 8020d30:	f003 ff83 	bl	8024c3a <XMC_CCU4_Init>
#if (MOTOR0_BLDC_SCALAR_ENABLE_FAST_SYNCH_CCU4 == 1U)
  /* Enable CCU4 Fast Sync module */
  XMC_CCU4_Init(MOTOR0_BLDC_SCALAR_CCU4_MODULE_FAST_SYNC,XMC_CCU4_SLICE_MCMS_ACTION_TRANSFER_PR_CR);
#endif
  /*Phase delay slice initialization*/
  Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init();
 8020d34:	f000 f806 	bl	8020d44 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init>
  /*Speed capture slice initialization*/
  Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init();
 8020d38:	f000 f83e 	bl	8020db8 <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init>
#if(1U == MOTOR0_BLDC_SCALAR_ENABLE_FAST_SYNCH_CCU4)
  /*Fast sync slice initialization*/
  Motor0_BLDC_SCALAR_CCU4_MCMSync_Init();
#endif
}
 8020d3c:	bf00      	nop
 8020d3e:	bd80      	pop	{r7, pc}
 8020d40:	4000c000 	.word	0x4000c000

08020d44 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init>:
 *
 * \par<b>Description:</b><br>
 * Initializes phase delay CCU4 slice for MCM pattern update .
 */
void Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init(void)
{
 8020d44:	b580      	push	{r7, lr}
 8020d46:	af00      	add	r7, sp, #0
  /*Phase delay slice compare timer initiation*/
  XMC_CCU4_SLICE_CompareInit(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE,
 8020d48:	4916      	ldr	r1, [pc, #88]	; (8020da4 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x60>)
 8020d4a:	4817      	ldr	r0, [pc, #92]	; (8020da8 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x64>)
 8020d4c:	f003 ffb0 	bl	8024cb0 <XMC_CCU4_SLICE_CompareInit>
      &Motor0_BLDC_SCALAR_CCU4_3HALL_PhaseDelay_CompareConfig);

  /*Phase delay blanking time configuration*/
  XMC_CCU4_SLICE_SetTimerCompareMatch(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE,
 8020d50:	4b16      	ldr	r3, [pc, #88]	; (8020dac <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x68>)
 8020d52:	881b      	ldrh	r3, [r3, #0]
 8020d54:	4619      	mov	r1, r3
 8020d56:	4814      	ldr	r0, [pc, #80]	; (8020da8 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x64>)
 8020d58:	f7ff ffa2 	bl	8020ca0 <XMC_CCU4_SLICE_SetTimerCompareMatch>
      Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Config.blanking_time);

  /*Phase delay slice period value(phase delay timing) configuration*/
  XMC_CCU4_SLICE_SetTimerPeriodMatch(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE,
 8020d5c:	4b13      	ldr	r3, [pc, #76]	; (8020dac <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x68>)
 8020d5e:	885b      	ldrh	r3, [r3, #2]
 8020d60:	4619      	mov	r1, r3
 8020d62:	4811      	ldr	r0, [pc, #68]	; (8020da8 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x64>)
 8020d64:	f7ff ff8d 	bl	8020c82 <XMC_CCU4_SLICE_SetTimerPeriodMatch>
      Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Config.phase_delay);

  /*enable shadow transfer for compare and period value*/
  XMC_CCU4_EnableShadowTransfer(MOTOR0_BLDC_SCALAR_CCU4_MODULE,MOTOR0_BLDC_SCALAR_CCU4_DELAY_SHADOWTRANSFER);
 8020d68:	2101      	movs	r1, #1
 8020d6a:	4811      	ldr	r0, [pc, #68]	; (8020db0 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x6c>)
 8020d6c:	f7ff ffa7 	bl	8020cbe <XMC_CCU4_EnableShadowTransfer>

  /*Configure Event 0 signal for phase delay slice*/
  XMC_CCU4_SLICE_ConfigureEvent(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE, XMC_CCU4_SLICE_EVENT_0,
 8020d70:	4a10      	ldr	r2, [pc, #64]	; (8020db4 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x70>)
 8020d72:	2101      	movs	r1, #1
 8020d74:	480c      	ldr	r0, [pc, #48]	; (8020da8 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x64>)
 8020d76:	f004 f9ce 	bl	8025116 <XMC_CCU4_SLICE_ConfigureEvent>
      &Motor0_BLDC_SCALAR_CCU4_3HALL_PhaseDelay_StartEventconfig);

  /*Configure Event 0 signal as start signal for phase delay slice*/
  XMC_CCU4_SLICE_StartConfig(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE, XMC_CCU4_SLICE_EVENT_0,
 8020d7a:	2201      	movs	r2, #1
 8020d7c:	2101      	movs	r1, #1
 8020d7e:	480a      	ldr	r0, [pc, #40]	; (8020da8 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x64>)
 8020d80:	f003 fff4 	bl	8024d6c <XMC_CCU4_SLICE_StartConfig>
      XMC_CCU4_SLICE_START_MODE_TIMER_START_CLEAR);

  /* Clear IDLE mode.*/
  XMC_CCU4_EnableClock(MOTOR0_BLDC_SCALAR_CCU4_MODULE, MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE_NUM);
 8020d84:	2100      	movs	r1, #0
 8020d86:	480a      	ldr	r0, [pc, #40]	; (8020db0 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x6c>)
 8020d88:	f7ff ff6a 	bl	8020c60 <XMC_CCU4_EnableClock>

  /*bind interrupt node for period match of phase delay*/
  XMC_CCU4_SLICE_SetInterruptNode(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH,
 8020d8c:	2200      	movs	r2, #0
 8020d8e:	2100      	movs	r1, #0
 8020d90:	4805      	ldr	r0, [pc, #20]	; (8020da8 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x64>)
 8020d92:	f004 fa5b 	bl	802524c <XMC_CCU4_SLICE_SetInterruptNode>
      MOTOR0_BLDC_SCALAR_CCU4_PHASE_DELAY_PM_SR);

  /*Enable period match interrupt of slice 0*/
  XMC_CCU4_SLICE_EnableEvent(MOTOR0_BLDC_SCALAR_CCU4_DELAY_SLICE, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 8020d96:	2100      	movs	r1, #0
 8020d98:	4803      	ldr	r0, [pc, #12]	; (8020da8 <Motor0_BLDC_SCALAR_CCU4_3Hall_PhaseDelay_Init+0x64>)
 8020d9a:	f7ff ffae 	bl	8020cfa <XMC_CCU4_SLICE_EnableEvent>
}
 8020d9e:	bf00      	nop
 8020da0:	bd80      	pop	{r7, pc}
 8020da2:	bf00      	nop
 8020da4:	1ffe9200 	.word	0x1ffe9200
 8020da8:	4000c100 	.word	0x4000c100
 8020dac:	1ffe920c 	.word	0x1ffe920c
 8020db0:	4000c000 	.word	0x4000c000
 8020db4:	1ffe9208 	.word	0x1ffe9208

08020db8 <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init>:
 *
 * \par<b>Description:</b><br>
 * Initializes capture CCU4 slice for motor speed calculations from HALL events.
 */
void Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init(void)
{
 8020db8:	b580      	push	{r7, lr}
 8020dba:	af00      	add	r7, sp, #0
  /*capture slice initiation*/
  XMC_CCU4_SLICE_CaptureInit(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, &Motor0_BLDC_SCALAR_CCU4_3HALL_CaptureConfig);
 8020dbc:	490c      	ldr	r1, [pc, #48]	; (8020df0 <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x38>)
 8020dbe:	480d      	ldr	r0, [pc, #52]	; (8020df4 <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x3c>)
 8020dc0:	f003 ffad 	bl	8024d1e <XMC_CCU4_SLICE_CaptureInit>

  /*Set prescaler value*/
  XMC_CCU4_SLICE_SetPrescaler(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, MOTOR0_BLDC_SCALAR_CCU4_PRESCALER);
 8020dc4:	2105      	movs	r1, #5
 8020dc6:	480b      	ldr	r0, [pc, #44]	; (8020df4 <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x3c>)
 8020dc8:	f004 fa21 	bl	802520e <XMC_CCU4_SLICE_SetPrescaler>
  /* enable floating prescaler for capture slice*/
  XMC_CCU4_SLICE_EnableFloatingPrescaler(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE);
 8020dcc:	4809      	ldr	r0, [pc, #36]	; (8020df4 <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x3c>)
 8020dce:	f7ff ff84 	bl	8020cda <XMC_CCU4_SLICE_EnableFloatingPrescaler>

  /* configure Event 0 signal as capture event*/
  XMC_CCU4_SLICE_ConfigureEvent(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, XMC_CCU4_SLICE_EVENT_0,
 8020dd2:	4a09      	ldr	r2, [pc, #36]	; (8020df8 <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x40>)
 8020dd4:	2101      	movs	r1, #1
 8020dd6:	4807      	ldr	r0, [pc, #28]	; (8020df4 <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x3c>)
 8020dd8:	f004 f99d 	bl	8025116 <XMC_CCU4_SLICE_ConfigureEvent>
      &Motor0_BLDC_SCALAR_CCU4_3HALL_Capture_ExtCaptureEventConfig);

  /* configure channel for speed capture*/
  XMC_CCU4_SLICE_Capture1Config(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, XMC_CCU4_SLICE_EVENT_0);
 8020ddc:	2101      	movs	r1, #1
 8020dde:	4805      	ldr	r0, [pc, #20]	; (8020df4 <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x3c>)
 8020de0:	f004 f8af 	bl	8024f42 <XMC_CCU4_SLICE_Capture1Config>

  /* Clear IDLE mode.*/
  XMC_CCU4_EnableClock(MOTOR0_BLDC_SCALAR_CCU4_MODULE, MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE_NUM);
 8020de4:	2101      	movs	r1, #1
 8020de6:	4805      	ldr	r0, [pc, #20]	; (8020dfc <Motor0_BLDC_SCALAR_CCU4_3Hall_SpeedCapture_Init+0x44>)
 8020de8:	f7ff ff3a 	bl	8020c60 <XMC_CCU4_EnableClock>

}
 8020dec:	bf00      	nop
 8020dee:	bd80      	pop	{r7, pc}
 8020df0:	1ffe9210 	.word	0x1ffe9210
 8020df4:	4000c200 	.word	0x4000c200
 8020df8:	1ffe9218 	.word	0x1ffe9218
 8020dfc:	4000c000 	.word	0x4000c000

08020e00 <XMC_CCU8_EnableClock>:
 *
 * \par<b>Related APIs:</b><br>
 * XMC_CCU8_DisableClock()<BR>  XMC_CCU8_EnableMultipleClocks()<BR>  XMC_CCU8_StartPrescaler()<BR>  XMC_CCU8_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU8_EnableClock(XMC_CCU8_MODULE_t *const module, const uint8_t slice_number)
{
 8020e00:	b480      	push	{r7}
 8020e02:	b083      	sub	sp, #12
 8020e04:	af00      	add	r7, sp, #0
 8020e06:	6078      	str	r0, [r7, #4]
 8020e08:	460b      	mov	r3, r1
 8020e0a:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_CCU8_EnableClock:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  XMC_ASSERT("XMC_CCU8_EnableClock:Invalid Slice Number", (slice_number < 4U));

  module->GIDLC = ((uint32_t) 1 << slice_number);
 8020e0c:	78fb      	ldrb	r3, [r7, #3]
 8020e0e:	2201      	movs	r2, #1
 8020e10:	409a      	lsls	r2, r3
 8020e12:	687b      	ldr	r3, [r7, #4]
 8020e14:	60da      	str	r2, [r3, #12]
}
 8020e16:	bf00      	nop
 8020e18:	370c      	adds	r7, #12
 8020e1a:	46bd      	mov	sp, r7
 8020e1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020e20:	4770      	bx	lr

08020e22 <XMC_CCU8_EnableShadowTransfer>:
 *
 * \par<b>Related APIs:</b><br>
 *  None.
 */
__STATIC_INLINE void XMC_CCU8_EnableShadowTransfer(XMC_CCU8_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
 8020e22:	b480      	push	{r7}
 8020e24:	b083      	sub	sp, #12
 8020e26:	af00      	add	r7, sp, #0
 8020e28:	6078      	str	r0, [r7, #4]
 8020e2a:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU8_EnableShadowTransfer:Invalid module Pointer", XMC_CCU8_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;
 8020e2c:	687b      	ldr	r3, [r7, #4]
 8020e2e:	683a      	ldr	r2, [r7, #0]
 8020e30:	611a      	str	r2, [r3, #16]
}
 8020e32:	bf00      	nop
 8020e34:	370c      	adds	r7, #12
 8020e36:	46bd      	mov	sp, r7
 8020e38:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020e3c:	4770      	bx	lr

08020e3e <XMC_CCU8_SLICE_EnableEvent>:
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU8_SLICE_SetInterruptNode()<BR>  XMC_CCU8_SLICE_EnableMultipleEvents()<BR>  XMC_CCU8_SLICE_DisableEvent()<BR>
 *  XMC_CCU8_SLICE_DisableMultipleEvents().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_EnableEvent(XMC_CCU8_SLICE_t *const slice, const XMC_CCU8_SLICE_IRQ_ID_t event)
{
 8020e3e:	b480      	push	{r7}
 8020e40:	b083      	sub	sp, #12
 8020e42:	af00      	add	r7, sp, #0
 8020e44:	6078      	str	r0, [r7, #4]
 8020e46:	460b      	mov	r3, r1
 8020e48:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_CCU8_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_EnableEvent:Invalid SR event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
 8020e4a:	687b      	ldr	r3, [r7, #4]
 8020e4c:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
 8020e50:	78fb      	ldrb	r3, [r7, #3]
 8020e52:	2101      	movs	r1, #1
 8020e54:	fa01 f303 	lsl.w	r3, r1, r3
 8020e58:	431a      	orrs	r2, r3
 8020e5a:	687b      	ldr	r3, [r7, #4]
 8020e5c:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
}
 8020e60:	bf00      	nop
 8020e62:	370c      	adds	r7, #12
 8020e64:	46bd      	mov	sp, r7
 8020e66:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020e6a:	4770      	bx	lr

08020e6c <BLDC_SCALAR_CCU8_Event_Init>:
 *
 * \par<b>Description:</b><br>
 * Initialize CCU8 slice for enable event and SR binding to the node.
 */
static void BLDC_SCALAR_CCU8_Event_Init(XMC_CCU8_SLICE_t* slice_ptr, XMC_CCU8_SLICE_IRQ_ID_t irq_id, XMC_CCU8_SLICE_SR_ID_t sr_id)
{
 8020e6c:	b580      	push	{r7, lr}
 8020e6e:	b082      	sub	sp, #8
 8020e70:	af00      	add	r7, sp, #0
 8020e72:	6078      	str	r0, [r7, #4]
 8020e74:	460b      	mov	r3, r1
 8020e76:	70fb      	strb	r3, [r7, #3]
 8020e78:	4613      	mov	r3, r2
 8020e7a:	70bb      	strb	r3, [r7, #2]
  /*Bind slice event SR(service request) to interrupt node*/
  XMC_CCU8_SLICE_SetInterruptNode(slice_ptr,irq_id,sr_id);
 8020e7c:	78ba      	ldrb	r2, [r7, #2]
 8020e7e:	78fb      	ldrb	r3, [r7, #3]
 8020e80:	4619      	mov	r1, r3
 8020e82:	6878      	ldr	r0, [r7, #4]
 8020e84:	f004 fbf0 	bl	8025668 <XMC_CCU8_SLICE_SetInterruptNode>

  /* Enable slice event */
  XMC_CCU8_SLICE_EnableEvent(slice_ptr,irq_id);
 8020e88:	78fb      	ldrb	r3, [r7, #3]
 8020e8a:	4619      	mov	r1, r3
 8020e8c:	6878      	ldr	r0, [r7, #4]
 8020e8e:	f7ff ffd6 	bl	8020e3e <XMC_CCU8_SLICE_EnableEvent>
}
 8020e92:	bf00      	nop
 8020e94:	3708      	adds	r7, #8
 8020e96:	46bd      	mov	sp, r7
 8020e98:	bd80      	pop	{r7, pc}
	...

08020e9c <Motor0_BLDC_SCALAR_CCU8_Slice_Init>:
 * Initialize CCU8 slice.
 */


static void Motor0_BLDC_SCALAR_CCU8_Slice_Init(uint32_t count)
{
 8020e9c:	b580      	push	{r7, lr}
 8020e9e:	b084      	sub	sp, #16
 8020ea0:	af00      	add	r7, sp, #0
 8020ea2:	6078      	str	r0, [r7, #4]
  XMC_CCU8_SLICE_t* const slice_ptr = Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[count];
 8020ea4:	4a19      	ldr	r2, [pc, #100]	; (8020f0c <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x70>)
 8020ea6:	687b      	ldr	r3, [r7, #4]
 8020ea8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8020eac:	60fb      	str	r3, [r7, #12]

  /*Enable clock for slice*/
  XMC_CCU8_EnableClock(MOTOR0_BLDC_SCALAR_CCU8_MODULE,Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_number[count]);
 8020eae:	4a17      	ldr	r2, [pc, #92]	; (8020f0c <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x70>)
 8020eb0:	687b      	ldr	r3, [r7, #4]
 8020eb2:	4413      	add	r3, r2
 8020eb4:	330c      	adds	r3, #12
 8020eb6:	781b      	ldrb	r3, [r3, #0]
 8020eb8:	4619      	mov	r1, r3
 8020eba:	4815      	ldr	r0, [pc, #84]	; (8020f10 <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x74>)
 8020ebc:	f7ff ffa0 	bl	8020e00 <XMC_CCU8_EnableClock>

  /* CCU8 Slice configuration */
  XMC_CCU8_SLICE_CompareInit(slice_ptr, &Motor0_BLDC_SCALAR_CCU8CompareConf);
 8020ec0:	4914      	ldr	r1, [pc, #80]	; (8020f14 <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x78>)
 8020ec2:	68f8      	ldr	r0, [r7, #12]
 8020ec4:	f004 faaa 	bl	802541c <XMC_CCU8_SLICE_CompareInit>
  /* Update CCU8 slice period registers */
  XMC_CCU8_SLICE_SetTimerPeriodMatch(slice_ptr,Motor0_BLDC_SCALAR_CCU8_PWM_Config.period);
 8020ec8:	4b10      	ldr	r3, [pc, #64]	; (8020f0c <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x70>)
 8020eca:	8a5b      	ldrh	r3, [r3, #18]
 8020ecc:	4619      	mov	r1, r3
 8020ece:	68f8      	ldr	r0, [r7, #12]
 8020ed0:	f004 fba2 	bl	8025618 <XMC_CCU8_SLICE_SetTimerPeriodMatch>
  /*
   * Mapped slice to EVENT-0 (sync start event)
   * External Start Function triggered by Event-0 rising edge
   * Clears the timer and sets run bit.
   */
  XMC_CCU8_SLICE_ConfigureEvent(slice_ptr,(XMC_CCU8_SLICE_EVENT_t)XMC_CCU8_SLICE_EVENT_0,
 8020ed4:	4a10      	ldr	r2, [pc, #64]	; (8020f18 <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x7c>)
 8020ed6:	2101      	movs	r1, #1
 8020ed8:	68f8      	ldr	r0, [r7, #12]
 8020eda:	f004 fb33 	bl	8025544 <XMC_CCU8_SLICE_ConfigureEvent>
      &Motor0_BLDC_SCALAR_CCU8ExtStartEventConf);
  XMC_CCU8_SLICE_StartConfig(slice_ptr,XMC_CCU8_SLICE_EVENT_0, XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
 8020ede:	2201      	movs	r2, #1
 8020ee0:	2101      	movs	r1, #1
 8020ee2:	68f8      	ldr	r0, [r7, #12]
 8020ee4:	f004 fad4 	bl	8025490 <XMC_CCU8_SLICE_StartConfig>
  /*
   * Mapped slice to EVENT-1 (sync stop event)
   * External Stop Function triggered by Event-1 falling edge
   * Clears the timer and run bit
   */
  XMC_CCU8_SLICE_ConfigureEvent(slice_ptr,(XMC_CCU8_SLICE_EVENT_t)XMC_CCU8_SLICE_EVENT_1,
 8020ee8:	4a0c      	ldr	r2, [pc, #48]	; (8020f1c <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x80>)
 8020eea:	2102      	movs	r1, #2
 8020eec:	68f8      	ldr	r0, [r7, #12]
 8020eee:	f004 fb29 	bl	8025544 <XMC_CCU8_SLICE_ConfigureEvent>
      &Motor0_BLDC_SCALAR_CCU8ExtStopEventConf);
  XMC_CCU8_SLICE_StopConfig(slice_ptr,XMC_CCU8_SLICE_EVENT_1,  XMC_CCU8_SLICE_END_MODE_TIMER_STOP_CLEAR);
 8020ef2:	2202      	movs	r2, #2
 8020ef4:	2102      	movs	r1, #2
 8020ef6:	68f8      	ldr	r0, [r7, #12]
 8020ef8:	f004 faf8 	bl	80254ec <XMC_CCU8_SLICE_StopConfig>
      &Motor0_BLDC_SCALAR_CCU8TrapEventConf);
  slice_ptr->CMC |= ((uint32_t) 1) << CCU8_CC8_CMC_TS_Pos;
  #endif

  /* Configure the dead time value */
  XMC_CCU8_SLICE_DeadTimeInit(slice_ptr,&Motor0_BLDC_SCALAR_CCU8_DeadTimeConfig);
 8020efc:	4908      	ldr	r1, [pc, #32]	; (8020f20 <Motor0_BLDC_SCALAR_CCU8_Slice_Init+0x84>)
 8020efe:	68f8      	ldr	r0, [r7, #12]
 8020f00:	f004 fc1c 	bl	802573c <XMC_CCU8_SLICE_DeadTimeInit>
}
 8020f04:	bf00      	nop
 8020f06:	3710      	adds	r7, #16
 8020f08:	46bd      	mov	sp, r7
 8020f0a:	bd80      	pop	{r7, pc}
 8020f0c:	1ffe9228 	.word	0x1ffe9228
 8020f10:	40020000 	.word	0x40020000
 8020f14:	080283a8 	.word	0x080283a8
 8020f18:	080283a0 	.word	0x080283a0
 8020f1c:	080283a4 	.word	0x080283a4
 8020f20:	1ffe921c 	.word	0x1ffe921c

08020f24 <Motor0_BLDC_SCALAR_CCU8_PWM_Init>:
 *
 * \par<b>Description:</b><br>
 * Initialize CCU8 slice for all 3 phases PWM generation.
 */
void Motor0_BLDC_SCALAR_CCU8_PWM_Init(void)
{
 8020f24:	b580      	push	{r7, lr}
 8020f26:	b082      	sub	sp, #8
 8020f28:	af00      	add	r7, sp, #0
  /*
   * Enable CCU8 module
   * Start the pre-scaler
   * Configure multi channel Shadow transfer request
   */
  XMC_CCU8_Init(MOTOR0_BLDC_SCALAR_CCU8_MODULE,XMC_CCU8_SLICE_MCMS_ACTION_TRANSFER_PR_CR);
 8020f2a:	2100      	movs	r1, #0
 8020f2c:	4816      	ldr	r0, [pc, #88]	; (8020f88 <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x64>)
 8020f2e:	f004 fa56 	bl	80253de <XMC_CCU8_Init>

  /*Initialize CCU8 Phase-U, V and W Slice*/
  for (count = 0U; count < CCU8_MAXPHASE_COUNT;count++)
 8020f32:	2300      	movs	r3, #0
 8020f34:	607b      	str	r3, [r7, #4]
 8020f36:	e005      	b.n	8020f44 <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x20>
  {
    Motor0_BLDC_SCALAR_CCU8_Slice_Init(count);
 8020f38:	6878      	ldr	r0, [r7, #4]
 8020f3a:	f7ff ffaf 	bl	8020e9c <Motor0_BLDC_SCALAR_CCU8_Slice_Init>
  for (count = 0U; count < CCU8_MAXPHASE_COUNT;count++)
 8020f3e:	687b      	ldr	r3, [r7, #4]
 8020f40:	3301      	adds	r3, #1
 8020f42:	607b      	str	r3, [r7, #4]
 8020f44:	687b      	ldr	r3, [r7, #4]
 8020f46:	2b02      	cmp	r3, #2
 8020f48:	d9f6      	bls.n	8020f38 <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x14>

  /*
   * Initialize Phase-U one match event and Bind Phase-U one match event SR(service request)
   * to interrupt node for control loop execution.
   */
  BLDC_SCALAR_CCU8_Event_Init(Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[0U],
 8020f4a:	4b10      	ldr	r3, [pc, #64]	; (8020f8c <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x68>)
 8020f4c:	681b      	ldr	r3, [r3, #0]
 8020f4e:	2200      	movs	r2, #0
 8020f50:	2101      	movs	r1, #1
 8020f52:	4618      	mov	r0, r3
 8020f54:	f7ff ff8a 	bl	8020e6c <BLDC_SCALAR_CCU8_Event_Init>
  /*
   * DC link current measurement trigger
   * phase-V compare match 2 down event
   */
  /* Initialize phase-V compare match 2 down event and bind SR to interrupt node for ADC trigger */
  BLDC_SCALAR_CCU8_Event_Init(Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[1U],
 8020f58:	4b0c      	ldr	r3, [pc, #48]	; (8020f8c <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x68>)
 8020f5a:	685b      	ldr	r3, [r3, #4]
 8020f5c:	2202      	movs	r2, #2
 8020f5e:	2105      	movs	r1, #5
 8020f60:	4618      	mov	r0, r3
 8020f62:	f7ff ff83 	bl	8020e6c <BLDC_SCALAR_CCU8_Event_Init>
   (XMC_CCU8_SLICE_IRQ_ID_t)XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_2, (XMC_CCU8_SLICE_SR_ID_t)MOTOR0_BLDC_SCALAR_CCU8_COMPMATCH_SR);

  XMC_CCU8_SLICE_SetTimerCompareMatch(Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[1U], XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
 8020f66:	4b09      	ldr	r3, [pc, #36]	; (8020f8c <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x68>)
 8020f68:	685b      	ldr	r3, [r3, #4]
 8020f6a:	4a08      	ldr	r2, [pc, #32]	; (8020f8c <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x68>)
 8020f6c:	8a12      	ldrh	r2, [r2, #16]
 8020f6e:	2101      	movs	r1, #1
 8020f70:	4618      	mov	r0, r3
 8020f72:	f004 fb60 	bl	8025636 <XMC_CCU8_SLICE_SetTimerCompareMatch>
      Motor0_BLDC_SCALAR_CCU8_PWM_Config.current_trigger);

  /*Enable CCU8 shadow transfer*/
  XMC_CCU8_EnableShadowTransfer(MOTOR0_BLDC_SCALAR_CCU8_MODULE, MOTOR0_BLDC_SCALAR_CCU8_SHADOW_TRANSFER);
 8020f76:	f240 1111 	movw	r1, #273	; 0x111
 8020f7a:	4803      	ldr	r0, [pc, #12]	; (8020f88 <Motor0_BLDC_SCALAR_CCU8_PWM_Init+0x64>)
 8020f7c:	f7ff ff51 	bl	8020e22 <XMC_CCU8_EnableShadowTransfer>
}
 8020f80:	bf00      	nop
 8020f82:	3708      	adds	r7, #8
 8020f84:	46bd      	mov	sp, r7
 8020f86:	bd80      	pop	{r7, pc}
 8020f88:	40020000 	.word	0x40020000
 8020f8c:	1ffe9228 	.word	0x1ffe9228

08020f90 <Motor0_BLDC_SCALAR_GPIO_PWM_Init>:
 *
 * \par<b>Description:</b><br>
 * Configures GPIO as output pins of CCU8 slices for PWM generation.
 */
void Motor0_BLDC_SCALAR_GPIO_PWM_Init(void)
{
 8020f90:	b580      	push	{r7, lr}
 8020f92:	af00      	add	r7, sp, #0
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_PH_U_HS, &Motor0_BLDC_SCALAR_GPIO_PhU_High_Config);
 8020f94:	4a0f      	ldr	r2, [pc, #60]	; (8020fd4 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x44>)
 8020f96:	2109      	movs	r1, #9
 8020f98:	480f      	ldr	r0, [pc, #60]	; (8020fd8 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x48>)
 8020f9a:	f002 fcf7 	bl	802398c <XMC_GPIO_Init>
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_PH_U_LS, &Motor0_BLDC_SCALAR_GPIO_PhU_Low_Config);
 8020f9e:	4a0f      	ldr	r2, [pc, #60]	; (8020fdc <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x4c>)
 8020fa0:	210e      	movs	r1, #14
 8020fa2:	480f      	ldr	r0, [pc, #60]	; (8020fe0 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x50>)
 8020fa4:	f002 fcf2 	bl	802398c <XMC_GPIO_Init>
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_PH_V_HS, &Motor0_BLDC_SCALAR_GPIO_PhV_High_Config);
 8020fa8:	4a0e      	ldr	r2, [pc, #56]	; (8020fe4 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x54>)
 8020faa:	210a      	movs	r1, #10
 8020fac:	480a      	ldr	r0, [pc, #40]	; (8020fd8 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x48>)
 8020fae:	f002 fced 	bl	802398c <XMC_GPIO_Init>
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_PH_V_LS, &Motor0_BLDC_SCALAR_GPIO_PhV_Low_Config);
 8020fb2:	4a0d      	ldr	r2, [pc, #52]	; (8020fe8 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x58>)
 8020fb4:	210f      	movs	r1, #15
 8020fb6:	480a      	ldr	r0, [pc, #40]	; (8020fe0 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x50>)
 8020fb8:	f002 fce8 	bl	802398c <XMC_GPIO_Init>
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_PH_W_HS, &Motor0_BLDC_SCALAR_GPIO_PhW_High_Config);
 8020fbc:	4a0b      	ldr	r2, [pc, #44]	; (8020fec <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x5c>)
 8020fbe:	210b      	movs	r1, #11
 8020fc0:	4805      	ldr	r0, [pc, #20]	; (8020fd8 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x48>)
 8020fc2:	f002 fce3 	bl	802398c <XMC_GPIO_Init>
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_PH_W_LS, &Motor0_BLDC_SCALAR_GPIO_PhW_Low_Config);
 8020fc6:	4a0a      	ldr	r2, [pc, #40]	; (8020ff0 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x60>)
 8020fc8:	2108      	movs	r1, #8
 8020fca:	4803      	ldr	r0, [pc, #12]	; (8020fd8 <Motor0_BLDC_SCALAR_GPIO_PWM_Init+0x48>)
 8020fcc:	f002 fcde 	bl	802398c <XMC_GPIO_Init>
}
 8020fd0:	bf00      	nop
 8020fd2:	bd80      	pop	{r7, pc}
 8020fd4:	080283b8 	.word	0x080283b8
 8020fd8:	48028500 	.word	0x48028500
 8020fdc:	080283c4 	.word	0x080283c4
 8020fe0:	48028200 	.word	0x48028200
 8020fe4:	080283d0 	.word	0x080283d0
 8020fe8:	080283dc 	.word	0x080283dc
 8020fec:	080283e8 	.word	0x080283e8
 8020ff0:	080283f4 	.word	0x080283f4

08020ff4 <Motor0_BLDC_SCALAR_GPIO_3Hall_Init>:
 *
 * \par<b>Description:</b><br>
 * Configures GPIO as input pins to the POSIF to sense HALL feedback.
 */
void Motor0_BLDC_SCALAR_GPIO_3Hall_Init(void)
{
 8020ff4:	b580      	push	{r7, lr}
 8020ff6:	af00      	add	r7, sp, #0
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_HALL_1, &Motor0_BLDC_SCALAR_GPIO_Hall_Config);
 8020ff8:	4a08      	ldr	r2, [pc, #32]	; (802101c <Motor0_BLDC_SCALAR_GPIO_3Hall_Init+0x28>)
 8020ffa:	2103      	movs	r1, #3
 8020ffc:	4808      	ldr	r0, [pc, #32]	; (8021020 <Motor0_BLDC_SCALAR_GPIO_3Hall_Init+0x2c>)
 8020ffe:	f002 fcc5 	bl	802398c <XMC_GPIO_Init>
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_HALL_2, &Motor0_BLDC_SCALAR_GPIO_Hall_Config);
 8021002:	4a06      	ldr	r2, [pc, #24]	; (802101c <Motor0_BLDC_SCALAR_GPIO_3Hall_Init+0x28>)
 8021004:	2102      	movs	r1, #2
 8021006:	4806      	ldr	r0, [pc, #24]	; (8021020 <Motor0_BLDC_SCALAR_GPIO_3Hall_Init+0x2c>)
 8021008:	f002 fcc0 	bl	802398c <XMC_GPIO_Init>
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_HALL_3, &Motor0_BLDC_SCALAR_GPIO_Hall_Config);
 802100c:	4a03      	ldr	r2, [pc, #12]	; (802101c <Motor0_BLDC_SCALAR_GPIO_3Hall_Init+0x28>)
 802100e:	2101      	movs	r1, #1
 8021010:	4803      	ldr	r0, [pc, #12]	; (8021020 <Motor0_BLDC_SCALAR_GPIO_3Hall_Init+0x2c>)
 8021012:	f002 fcbb 	bl	802398c <XMC_GPIO_Init>
}
 8021016:	bf00      	nop
 8021018:	bd80      	pop	{r7, pc}
 802101a:	bf00      	nop
 802101c:	08028400 	.word	0x08028400
 8021020:	48028100 	.word	0x48028100

08021024 <Motor0_BLDC_SCALAR_GPIO_Inverter_Init>:
 *
 * \par<b>Description:</b><br>
 * Configures GPIO as general purpose output pin for inverter enable.
 */
void Motor0_BLDC_SCALAR_GPIO_Inverter_Init(void)
{
 8021024:	b580      	push	{r7, lr}
 8021026:	af00      	add	r7, sp, #0
  XMC_GPIO_Init(MOTOR0_BLDC_SCALAR_GPIO_INV_ENABLE, &Motor0_BLDC_SCALAR_GPIO_Inverter_Config);
 8021028:	4a03      	ldr	r2, [pc, #12]	; (8021038 <Motor0_BLDC_SCALAR_GPIO_Inverter_Init+0x14>)
 802102a:	210b      	movs	r1, #11
 802102c:	4803      	ldr	r0, [pc, #12]	; (802103c <Motor0_BLDC_SCALAR_GPIO_Inverter_Init+0x18>)
 802102e:	f002 fcad 	bl	802398c <XMC_GPIO_Init>
}
 8021032:	bf00      	nop
 8021034:	bd80      	pop	{r7, pc}
 8021036:	bf00      	nop
 8021038:	0802840c 	.word	0x0802840c
 802103c:	48028200 	.word	0x48028200

08021040 <__NVIC_GetPriorityGrouping>:
{
 8021040:	b480      	push	{r7}
 8021042:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8021044:	4b04      	ldr	r3, [pc, #16]	; (8021058 <__NVIC_GetPriorityGrouping+0x18>)
 8021046:	68db      	ldr	r3, [r3, #12]
 8021048:	0a1b      	lsrs	r3, r3, #8
 802104a:	f003 0307 	and.w	r3, r3, #7
}
 802104e:	4618      	mov	r0, r3
 8021050:	46bd      	mov	sp, r7
 8021052:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021056:	4770      	bx	lr
 8021058:	e000ed00 	.word	0xe000ed00

0802105c <__NVIC_EnableIRQ>:
{
 802105c:	b480      	push	{r7}
 802105e:	b083      	sub	sp, #12
 8021060:	af00      	add	r7, sp, #0
 8021062:	4603      	mov	r3, r0
 8021064:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8021066:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802106a:	2b00      	cmp	r3, #0
 802106c:	db0b      	blt.n	8021086 <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 802106e:	79fb      	ldrb	r3, [r7, #7]
 8021070:	f003 021f 	and.w	r2, r3, #31
 8021074:	4907      	ldr	r1, [pc, #28]	; (8021094 <__NVIC_EnableIRQ+0x38>)
 8021076:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802107a:	095b      	lsrs	r3, r3, #5
 802107c:	2001      	movs	r0, #1
 802107e:	fa00 f202 	lsl.w	r2, r0, r2
 8021082:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 8021086:	bf00      	nop
 8021088:	370c      	adds	r7, #12
 802108a:	46bd      	mov	sp, r7
 802108c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021090:	4770      	bx	lr
 8021092:	bf00      	nop
 8021094:	e000e100 	.word	0xe000e100

08021098 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8021098:	b480      	push	{r7}
 802109a:	b083      	sub	sp, #12
 802109c:	af00      	add	r7, sp, #0
 802109e:	4603      	mov	r3, r0
 80210a0:	6039      	str	r1, [r7, #0]
 80210a2:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80210a4:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80210a8:	2b00      	cmp	r3, #0
 80210aa:	db0a      	blt.n	80210c2 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80210ac:	683b      	ldr	r3, [r7, #0]
 80210ae:	b2da      	uxtb	r2, r3
 80210b0:	490c      	ldr	r1, [pc, #48]	; (80210e4 <__NVIC_SetPriority+0x4c>)
 80210b2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80210b6:	0092      	lsls	r2, r2, #2
 80210b8:	b2d2      	uxtb	r2, r2
 80210ba:	440b      	add	r3, r1
 80210bc:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 80210c0:	e00a      	b.n	80210d8 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80210c2:	683b      	ldr	r3, [r7, #0]
 80210c4:	b2da      	uxtb	r2, r3
 80210c6:	4908      	ldr	r1, [pc, #32]	; (80210e8 <__NVIC_SetPriority+0x50>)
 80210c8:	79fb      	ldrb	r3, [r7, #7]
 80210ca:	f003 030f 	and.w	r3, r3, #15
 80210ce:	3b04      	subs	r3, #4
 80210d0:	0092      	lsls	r2, r2, #2
 80210d2:	b2d2      	uxtb	r2, r2
 80210d4:	440b      	add	r3, r1
 80210d6:	761a      	strb	r2, [r3, #24]
}
 80210d8:	bf00      	nop
 80210da:	370c      	adds	r7, #12
 80210dc:	46bd      	mov	sp, r7
 80210de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80210e2:	4770      	bx	lr
 80210e4:	e000e100 	.word	0xe000e100
 80210e8:	e000ed00 	.word	0xe000ed00

080210ec <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80210ec:	b480      	push	{r7}
 80210ee:	b089      	sub	sp, #36	; 0x24
 80210f0:	af00      	add	r7, sp, #0
 80210f2:	60f8      	str	r0, [r7, #12]
 80210f4:	60b9      	str	r1, [r7, #8]
 80210f6:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 80210f8:	68fb      	ldr	r3, [r7, #12]
 80210fa:	f003 0307 	and.w	r3, r3, #7
 80210fe:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8021100:	69fb      	ldr	r3, [r7, #28]
 8021102:	f1c3 0307 	rsb	r3, r3, #7
 8021106:	2b06      	cmp	r3, #6
 8021108:	bf28      	it	cs
 802110a:	2306      	movcs	r3, #6
 802110c:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802110e:	69fb      	ldr	r3, [r7, #28]
 8021110:	3306      	adds	r3, #6
 8021112:	2b06      	cmp	r3, #6
 8021114:	d902      	bls.n	802111c <NVIC_EncodePriority+0x30>
 8021116:	69fb      	ldr	r3, [r7, #28]
 8021118:	3b01      	subs	r3, #1
 802111a:	e000      	b.n	802111e <NVIC_EncodePriority+0x32>
 802111c:	2300      	movs	r3, #0
 802111e:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8021120:	f04f 32ff 	mov.w	r2, #4294967295
 8021124:	69bb      	ldr	r3, [r7, #24]
 8021126:	fa02 f303 	lsl.w	r3, r2, r3
 802112a:	43da      	mvns	r2, r3
 802112c:	68bb      	ldr	r3, [r7, #8]
 802112e:	401a      	ands	r2, r3
 8021130:	697b      	ldr	r3, [r7, #20]
 8021132:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8021134:	f04f 31ff 	mov.w	r1, #4294967295
 8021138:	697b      	ldr	r3, [r7, #20]
 802113a:	fa01 f303 	lsl.w	r3, r1, r3
 802113e:	43d9      	mvns	r1, r3
 8021140:	687b      	ldr	r3, [r7, #4]
 8021142:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8021144:	4313      	orrs	r3, r2
         );
}
 8021146:	4618      	mov	r0, r3
 8021148:	3724      	adds	r7, #36	; 0x24
 802114a:	46bd      	mov	sp, r7
 802114c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021150:	4770      	bx	lr

08021152 <BLDC_SCALAR_NVIC_NodeInit>:
 *
 * \par<b>Description:</b><br>
 * Sets the priority of an interrupt and enables the interrupt.
 */
void BLDC_SCALAR_NVIC_NodeInit(IRQn_Type node_id, uint32_t priority, uint32_t sub_priority)
{
 8021152:	b580      	push	{r7, lr}
 8021154:	b084      	sub	sp, #16
 8021156:	af00      	add	r7, sp, #0
 8021158:	4603      	mov	r3, r0
 802115a:	60b9      	str	r1, [r7, #8]
 802115c:	607a      	str	r2, [r7, #4]
 802115e:	73fb      	strb	r3, [r7, #15]
  /*set the priority and sub priority*/
  #if (UC_FAMILY == XMC1)
  NVIC_SetPriority(node_id,priority);
  #else
  NVIC_SetPriority(node_id, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), priority,sub_priority));
 8021160:	f7ff ff6e 	bl	8021040 <__NVIC_GetPriorityGrouping>
 8021164:	4603      	mov	r3, r0
 8021166:	687a      	ldr	r2, [r7, #4]
 8021168:	68b9      	ldr	r1, [r7, #8]
 802116a:	4618      	mov	r0, r3
 802116c:	f7ff ffbe 	bl	80210ec <NVIC_EncodePriority>
 8021170:	4602      	mov	r2, r0
 8021172:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8021176:	4611      	mov	r1, r2
 8021178:	4618      	mov	r0, r3
 802117a:	f7ff ff8d 	bl	8021098 <__NVIC_SetPriority>
  #endif
  /*Enable the IRQ*/
  NVIC_EnableIRQ(node_id);
 802117e:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8021182:	4618      	mov	r0, r3
 8021184:	f7ff ff6a 	bl	802105c <__NVIC_EnableIRQ>
}
 8021188:	bf00      	nop
 802118a:	3710      	adds	r7, #16
 802118c:	46bd      	mov	sp, r7
 802118e:	bd80      	pop	{r7, pc}

08021190 <XMC_POSIF_EnableEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_POSIF_DisableEvent() \n\n\n
 */
__STATIC_INLINE void XMC_POSIF_EnableEvent(XMC_POSIF_t *const peripheral, const XMC_POSIF_IRQ_EVENT_t event)
{
 8021190:	b480      	push	{r7}
 8021192:	b083      	sub	sp, #12
 8021194:	af00      	add	r7, sp, #0
 8021196:	6078      	str	r0, [r7, #4]
 8021198:	460b      	mov	r3, r1
 802119a:	70fb      	strb	r3, [r7, #3]
  peripheral->PFLGE |= (uint32_t)1 << (uint8_t)event;
 802119c:	687b      	ldr	r3, [r7, #4]
 802119e:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80211a0:	78fb      	ldrb	r3, [r7, #3]
 80211a2:	2101      	movs	r1, #1
 80211a4:	fa01 f303 	lsl.w	r3, r1, r3
 80211a8:	431a      	orrs	r2, r3
 80211aa:	687b      	ldr	r3, [r7, #4]
 80211ac:	675a      	str	r2, [r3, #116]	; 0x74
}
 80211ae:	bf00      	nop
 80211b0:	370c      	adds	r7, #12
 80211b2:	46bd      	mov	sp, r7
 80211b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80211b8:	4770      	bx	lr
	...

080211bc <Motor0_BLDC_SCALAR_POSIF_3Hall_Init>:
 * - Correct hall event,
 * - Wrong hall event,
 * - Multi-channel pattern shadow transfer event
 */
void Motor0_BLDC_SCALAR_POSIF_3Hall_Init()
{
 80211bc:	b580      	push	{r7, lr}
 80211be:	af00      	add	r7, sp, #0
  XMC_POSIF_Init(MOTOR0_BLDC_SCALAR_POSIF_MODULE, &Motor0_BLDC_SCALAR_POSIF_GLOBAL_Config);
 80211c0:	4914      	ldr	r1, [pc, #80]	; (8021214 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x58>)
 80211c2:	4815      	ldr	r0, [pc, #84]	; (8021218 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 80211c4:	f004 fb80 	bl	80258c8 <XMC_POSIF_Init>
  XMC_POSIF_MCM_Init(MOTOR0_BLDC_SCALAR_POSIF_MODULE, &Motor0_BLDC_SCALAR_POSIF_MCM_Config);
 80211c8:	4914      	ldr	r1, [pc, #80]	; (802121c <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x60>)
 80211ca:	4813      	ldr	r0, [pc, #76]	; (8021218 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 80211cc:	f004 fbae 	bl	802592c <XMC_POSIF_MCM_Init>
  XMC_POSIF_HSC_Init(MOTOR0_BLDC_SCALAR_POSIF_MODULE, &Motor0_BLDC_SCALAR_POSIF_HALL_Config);
 80211d0:	4913      	ldr	r1, [pc, #76]	; (8021220 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x64>)
 80211d2:	4811      	ldr	r0, [pc, #68]	; (8021218 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 80211d4:	f004 fb8b 	bl	80258ee <XMC_POSIF_HSC_Init>

  /*Bind interrupt node*/
  XMC_POSIF_SetInterruptNode(MOTOR0_BLDC_SCALAR_POSIF_MODULE, XMC_POSIF_IRQ_EVENT_CHE,
 80211d8:	2200      	movs	r2, #0
 80211da:	2100      	movs	r1, #0
 80211dc:	480e      	ldr	r0, [pc, #56]	; (8021218 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 80211de:	f004 fbc4 	bl	802596a <XMC_POSIF_SetInterruptNode>
      MOTOR0_BLDC_SCALAR_POSIF_HALL_SR);
  XMC_POSIF_SetInterruptNode(MOTOR0_BLDC_SCALAR_POSIF_MODULE, XMC_POSIF_IRQ_EVENT_WHE,
 80211e2:	2200      	movs	r2, #0
 80211e4:	2101      	movs	r1, #1
 80211e6:	480c      	ldr	r0, [pc, #48]	; (8021218 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 80211e8:	f004 fbbf 	bl	802596a <XMC_POSIF_SetInterruptNode>
      MOTOR0_BLDC_SCALAR_POSIF_HALL_SR);
  XMC_POSIF_SetInterruptNode(MOTOR0_BLDC_SCALAR_POSIF_MODULE, XMC_POSIF_IRQ_EVENT_MCP_SHADOW_TRANSFER,
 80211ec:	2201      	movs	r2, #1
 80211ee:	2104      	movs	r1, #4
 80211f0:	4809      	ldr	r0, [pc, #36]	; (8021218 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 80211f2:	f004 fbba 	bl	802596a <XMC_POSIF_SetInterruptNode>
      MOTOR0_BLDC_SCALAR_POSIF_MCP_SR);

  XMC_POSIF_EnableEvent(MOTOR0_BLDC_SCALAR_POSIF_MODULE, XMC_POSIF_IRQ_EVENT_CHE);
 80211f6:	2100      	movs	r1, #0
 80211f8:	4807      	ldr	r0, [pc, #28]	; (8021218 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 80211fa:	f7ff ffc9 	bl	8021190 <XMC_POSIF_EnableEvent>
  XMC_POSIF_EnableEvent(MOTOR0_BLDC_SCALAR_POSIF_MODULE, XMC_POSIF_IRQ_EVENT_WHE);
 80211fe:	2101      	movs	r1, #1
 8021200:	4805      	ldr	r0, [pc, #20]	; (8021218 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 8021202:	f7ff ffc5 	bl	8021190 <XMC_POSIF_EnableEvent>
  XMC_POSIF_EnableEvent(MOTOR0_BLDC_SCALAR_POSIF_MODULE, XMC_POSIF_IRQ_EVENT_MCP_SHADOW_TRANSFER);
 8021206:	2104      	movs	r1, #4
 8021208:	4803      	ldr	r0, [pc, #12]	; (8021218 <Motor0_BLDC_SCALAR_POSIF_3Hall_Init+0x5c>)
 802120a:	f7ff ffc1 	bl	8021190 <XMC_POSIF_EnableEvent>
}
 802120e:	bf00      	nop
 8021210:	bd80      	pop	{r7, pc}
 8021212:	bf00      	nop
 8021214:	0802841c 	.word	0x0802841c
 8021218:	40028000 	.word	0x40028000
 802121c:	08028420 	.word	0x08028420
 8021220:	08028418 	.word	0x08028418

08021224 <XMC_VADC_GROUP_QueueSetGatingMode>:
{
 8021224:	b480      	push	{r7}
 8021226:	b083      	sub	sp, #12
 8021228:	af00      	add	r7, sp, #0
 802122a:	6078      	str	r0, [r7, #4]
 802122c:	460b      	mov	r3, r1
 802122e:	70fb      	strb	r3, [r7, #3]
  group_ptr->QMR0 &= (uint32_t)(~((uint32_t) VADC_G_QMR0_ENGT_Msk));
 8021230:	687b      	ldr	r3, [r7, #4]
 8021232:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8021236:	f023 0203 	bic.w	r2, r3, #3
 802123a:	687b      	ldr	r3, [r7, #4]
 802123c:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  group_ptr->QMR0 |= (uint32_t)((uint32_t)mode_sel << VADC_G_QMR0_ENGT_Pos);
 8021240:	687b      	ldr	r3, [r7, #4]
 8021242:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8021246:	78fb      	ldrb	r3, [r7, #3]
 8021248:	431a      	orrs	r2, r3
 802124a:	687b      	ldr	r3, [r7, #4]
 802124c:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
}
 8021250:	bf00      	nop
 8021252:	370c      	adds	r7, #12
 8021254:	46bd      	mov	sp, r7
 8021256:	f85d 7b04 	ldr.w	r7, [sp], #4
 802125a:	4770      	bx	lr

0802125c <XMC_VADC_GROUP_QueueFlushEntries>:
{
 802125c:	b480      	push	{r7}
 802125e:	b083      	sub	sp, #12
 8021260:	af00      	add	r7, sp, #0
 8021262:	6078      	str	r0, [r7, #4]
  group_ptr->QMR0 |= (uint32_t)VADC_G_QMR0_FLUSH_Msk;
 8021264:	687b      	ldr	r3, [r7, #4]
 8021266:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 802126a:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
 802126e:	687b      	ldr	r3, [r7, #4]
 8021270:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  while ( !((group_ptr->QSR0) & (uint32_t)VADC_G_QSR0_EMPTY_Msk))
 8021274:	bf00      	nop
 8021276:	687b      	ldr	r3, [r7, #4]
 8021278:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 802127c:	f003 0320 	and.w	r3, r3, #32
 8021280:	2b00      	cmp	r3, #0
 8021282:	d0f8      	beq.n	8021276 <XMC_VADC_GROUP_QueueFlushEntries+0x1a>
}
 8021284:	bf00      	nop
 8021286:	bf00      	nop
 8021288:	370c      	adds	r7, #12
 802128a:	46bd      	mov	sp, r7
 802128c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021290:	4770      	bx	lr
	...

08021294 <Motor0_BLDC_SCALAR_VADC_Init>:
 * \par<b>Description:</b><br>
 * Initializes VADC peripheral and power on the required VADC Group and Queues.
 * Only required converters will be turned on to optimize power consumption.
 */
void Motor0_BLDC_SCALAR_VADC_Init(void)
{
 8021294:	b580      	push	{r7, lr}
 8021296:	af00      	add	r7, sp, #0
  /* Initialize an instance of VADC Global hardware */
  XMC_VADC_GLOBAL_Init(VADC, &Motor0_BLDC_SCALAR_VADC_GLOBAL_config);
 8021298:	490e      	ldr	r1, [pc, #56]	; (80212d4 <Motor0_BLDC_SCALAR_VADC_Init+0x40>)
 802129a:	f04f 2040 	mov.w	r0, #1073758208	; 0x40004000
 802129e:	f004 fc1a 	bl	8025ad6 <XMC_VADC_GLOBAL_Init>
  /* Switch on the converter of the Group[2]*/
  XMC_VADC_GROUP_SetPowerMode(VADC_G2,XMC_VADC_GROUP_POWERMODE_NORMAL);
  #endif
  #if(VADC_ENABLE_GROUP_QUEUE_3 == 1U)
  /* Switch on the converter of the Group[3]*/
  XMC_VADC_GROUP_SetPowerMode(VADC_G3,XMC_VADC_GROUP_POWERMODE_NORMAL);
 80212a2:	2103      	movs	r1, #3
 80212a4:	480c      	ldr	r0, [pc, #48]	; (80212d8 <Motor0_BLDC_SCALAR_VADC_Init+0x44>)
 80212a6:	f004 fd51 	bl	8025d4c <XMC_VADC_GROUP_SetPowerMode>
  XMC_VADC_GROUP_QueueFlushEntries(VADC_G2);
  #endif  /* end of #if(VADC_ENABLE_GROUP_QUEUE_2 == 1U) */

  #if(VADC_ENABLE_GROUP_QUEUE_3 == 1U)
  /* Program the input classes for Group[3] */
  XMC_VADC_GROUP_InputClassInit(VADC_G3,Motor0_BLDC_SCALAR_VADC_GROUP_class0,XMC_VADC_GROUP_CONV_STD,0U);
 80212aa:	490c      	ldr	r1, [pc, #48]	; (80212dc <Motor0_BLDC_SCALAR_VADC_Init+0x48>)
 80212ac:	2300      	movs	r3, #0
 80212ae:	2200      	movs	r2, #0
 80212b0:	6809      	ldr	r1, [r1, #0]
 80212b2:	4809      	ldr	r0, [pc, #36]	; (80212d8 <Motor0_BLDC_SCALAR_VADC_Init+0x44>)
 80212b4:	f004 fced 	bl	8025c92 <XMC_VADC_GROUP_InputClassInit>
  /* Initialize the Queue3 */
  XMC_VADC_GROUP_QueueInit(VADC_G3,&Motor0_BLDC_SCALAR_VADC_QUEUE_3_cfg);
 80212b8:	4909      	ldr	r1, [pc, #36]	; (80212e0 <Motor0_BLDC_SCALAR_VADC_Init+0x4c>)
 80212ba:	4807      	ldr	r0, [pc, #28]	; (80212d8 <Motor0_BLDC_SCALAR_VADC_Init+0x44>)
 80212bc:	f004 fe0c 	bl	8025ed8 <XMC_VADC_GROUP_QueueInit>
  /* Configure the gating mode for queue3 */
  XMC_VADC_GROUP_QueueSetGatingMode(VADC_G3, (XMC_VADC_GATEMODE_t)MOTOR0_BLDC_SCALAR_VADC_QUEUE_3_GATING);
 80212c0:	2101      	movs	r1, #1
 80212c2:	4805      	ldr	r0, [pc, #20]	; (80212d8 <Motor0_BLDC_SCALAR_VADC_Init+0x44>)
 80212c4:	f7ff ffae 	bl	8021224 <XMC_VADC_GROUP_QueueSetGatingMode>
  /* Flush any entries that are currently in the queue3 buffer */
  XMC_VADC_GROUP_QueueFlushEntries(VADC_G3);
 80212c8:	4803      	ldr	r0, [pc, #12]	; (80212d8 <Motor0_BLDC_SCALAR_VADC_Init+0x44>)
 80212ca:	f7ff ffc7 	bl	802125c <XMC_VADC_GROUP_QueueFlushEntries>
  #endif  /* end of #if(VADC_ENABLE_GROUP_QUEUE_3 == 1U) */
}
 80212ce:	bf00      	nop
 80212d0:	bd80      	pop	{r7, pc}
 80212d2:	bf00      	nop
 80212d4:	08028424 	.word	0x08028424
 80212d8:	40005000 	.word	0x40005000
 80212dc:	0802843c 	.word	0x0802843c
 80212e0:	08028440 	.word	0x08028440

080212e4 <XMC_CCU8_EnableShadowTransfer>:
{
 80212e4:	b480      	push	{r7}
 80212e6:	b083      	sub	sp, #12
 80212e8:	af00      	add	r7, sp, #0
 80212ea:	6078      	str	r0, [r7, #4]
 80212ec:	6039      	str	r1, [r7, #0]
  module->GCSS = (uint32_t)shadow_transfer_msk;
 80212ee:	687b      	ldr	r3, [r7, #4]
 80212f0:	683a      	ldr	r2, [r7, #0]
 80212f2:	611a      	str	r2, [r3, #16]
}
 80212f4:	bf00      	nop
 80212f6:	370c      	adds	r7, #12
 80212f8:	46bd      	mov	sp, r7
 80212fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80212fe:	4770      	bx	lr

08021300 <XMC_POSIF_HSC_GetLastSampledPattern>:
{
 8021300:	b480      	push	{r7}
 8021302:	b083      	sub	sp, #12
 8021304:	af00      	add	r7, sp, #0
 8021306:	6078      	str	r0, [r7, #4]
  return ((uint8_t)((peripheral->PDBG) & POSIF_PDBG_HSP_Msk) >> POSIF_PDBG_HSP_Pos);
 8021308:	687b      	ldr	r3, [r7, #4]
 802130a:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 802130e:	b2db      	uxtb	r3, r3
 8021310:	115b      	asrs	r3, r3, #5
 8021312:	b2db      	uxtb	r3, r3
 8021314:	f003 0307 	and.w	r3, r3, #7
 8021318:	b2db      	uxtb	r3, r3
}
 802131a:	4618      	mov	r0, r3
 802131c:	370c      	adds	r7, #12
 802131e:	46bd      	mov	sp, r7
 8021320:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021324:	4770      	bx	lr

08021326 <XMC_VADC_GROUP_GetResult>:
{
 8021326:	b480      	push	{r7}
 8021328:	b083      	sub	sp, #12
 802132a:	af00      	add	r7, sp, #0
 802132c:	6078      	str	r0, [r7, #4]
 802132e:	6039      	str	r1, [r7, #0]
  return ((XMC_VADC_RESULT_SIZE_t)group_ptr->RES[res_reg]);
 8021330:	687b      	ldr	r3, [r7, #4]
 8021332:	683a      	ldr	r2, [r7, #0]
 8021334:	32c0      	adds	r2, #192	; 0xc0
 8021336:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802133a:	b29b      	uxth	r3, r3
}
 802133c:	4618      	mov	r0, r3
 802133e:	370c      	adds	r7, #12
 8021340:	46bd      	mov	sp, r7
 8021342:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021346:	4770      	bx	lr

08021348 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate>:
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate
(
  uint16_t dutycycle
)
{
 8021348:	b580      	push	{r7, lr}
 802134a:	b084      	sub	sp, #16
 802134c:	af00      	add	r7, sp, #0
 802134e:	4603      	mov	r3, r0
 8021350:	80fb      	strh	r3, [r7, #6]
  uint16_t duty = (dutycycle * Motor0_BLDC_SCALAR_PWM_BC.amplitude_scale) >> BLDC_SCALAR_PWM_BC_SHIFT_14;
 8021352:	88fb      	ldrh	r3, [r7, #6]
 8021354:	4a1a      	ldr	r2, [pc, #104]	; (80213c0 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 8021356:	8cd2      	ldrh	r2, [r2, #38]	; 0x26
 8021358:	fb02 f303 	mul.w	r3, r2, r3
 802135c:	139b      	asrs	r3, r3, #14
 802135e:	81fb      	strh	r3, [r7, #14]
  /* Update compare value for inverted switch*/
  Motor0_BLDC_SCALAR_PWM_BC.ph_cmpval[3] = Motor0_BLDC_SCALAR_PWM_BC.ccu8_handle_ptr->period - duty;
 8021360:	4b17      	ldr	r3, [pc, #92]	; (80213c0 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 8021362:	681b      	ldr	r3, [r3, #0]
 8021364:	8a5a      	ldrh	r2, [r3, #18]
 8021366:	89fb      	ldrh	r3, [r7, #14]
 8021368:	1ad3      	subs	r3, r2, r3
 802136a:	b29a      	uxth	r2, r3
 802136c:	4b14      	ldr	r3, [pc, #80]	; (80213c0 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 802136e:	849a      	strh	r2, [r3, #36]	; 0x24
  /* Update compare value for direct switch */
  Motor0_BLDC_SCALAR_PWM_BC.ph_cmpval[2] = duty;
 8021370:	4a13      	ldr	r2, [pc, #76]	; (80213c0 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 8021372:	89fb      	ldrh	r3, [r7, #14]
 8021374:	8453      	strh	r3, [r2, #34]	; 0x22

  /*Load the duty cycle to the channel compare shadow register*/
  (MOTOR0_BLDC_SCALAR_CCU8_PH_U_SLICE)->CR1S = (uint32_t) Motor0_BLDC_SCALAR_PWM_BC.ph_cmpval[Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[0U]];
 8021376:	4b12      	ldr	r3, [pc, #72]	; (80213c0 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 8021378:	7b9b      	ldrb	r3, [r3, #14]
 802137a:	4a11      	ldr	r2, [pc, #68]	; (80213c0 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 802137c:	330c      	adds	r3, #12
 802137e:	005b      	lsls	r3, r3, #1
 8021380:	4413      	add	r3, r2
 8021382:	88da      	ldrh	r2, [r3, #6]
 8021384:	4b0f      	ldr	r3, [pc, #60]	; (80213c4 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x7c>)
 8021386:	63da      	str	r2, [r3, #60]	; 0x3c
  (MOTOR0_BLDC_SCALAR_CCU8_PH_V_SLICE)->CR1S = (uint32_t) Motor0_BLDC_SCALAR_PWM_BC.ph_cmpval[Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[1U]];
 8021388:	4b0d      	ldr	r3, [pc, #52]	; (80213c0 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 802138a:	7bdb      	ldrb	r3, [r3, #15]
 802138c:	4a0c      	ldr	r2, [pc, #48]	; (80213c0 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 802138e:	330c      	adds	r3, #12
 8021390:	005b      	lsls	r3, r3, #1
 8021392:	4413      	add	r3, r2
 8021394:	88da      	ldrh	r2, [r3, #6]
 8021396:	4b0c      	ldr	r3, [pc, #48]	; (80213c8 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x80>)
 8021398:	63da      	str	r2, [r3, #60]	; 0x3c
  (MOTOR0_BLDC_SCALAR_CCU8_PH_W_SLICE)->CR1S = (uint32_t) Motor0_BLDC_SCALAR_PWM_BC.ph_cmpval[Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[2U]];
 802139a:	4b09      	ldr	r3, [pc, #36]	; (80213c0 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 802139c:	7c1b      	ldrb	r3, [r3, #16]
 802139e:	4a08      	ldr	r2, [pc, #32]	; (80213c0 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x78>)
 80213a0:	330c      	adds	r3, #12
 80213a2:	005b      	lsls	r3, r3, #1
 80213a4:	4413      	add	r3, r2
 80213a6:	88da      	ldrh	r2, [r3, #6]
 80213a8:	4b08      	ldr	r3, [pc, #32]	; (80213cc <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x84>)
 80213aa:	63da      	str	r2, [r3, #60]	; 0x3c

  /*Enable the shadow transfer*/
  XMC_CCU8_EnableShadowTransfer(MOTOR0_BLDC_SCALAR_CCU8_MODULE, MOTOR0_BLDC_SCALAR_CCU8_SHADOW_TRANSFER);
 80213ac:	f240 1111 	movw	r1, #273	; 0x111
 80213b0:	4807      	ldr	r0, [pc, #28]	; (80213d0 <Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate+0x88>)
 80213b2:	f7ff ff97 	bl	80212e4 <XMC_CCU8_EnableShadowTransfer>
}
 80213b6:	bf00      	nop
 80213b8:	3710      	adds	r7, #16
 80213ba:	46bd      	mov	sp, r7
 80213bc:	bd80      	pop	{r7, pc}
 80213be:	bf00      	nop
 80213c0:	1ffe9294 	.word	0x1ffe9294
 80213c4:	40020300 	.word	0x40020300
 80213c8:	40020200 	.word	0x40020200
 80213cc:	40020100 	.word	0x40020100
 80213d0:	40020000 	.word	0x40020000

080213d4 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter>:
 *
 * \par<b>Description:</b><br>
 * Resets variables related to speed calculation.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter(void)
{
 80213d4:	b480      	push	{r7}
 80213d6:	af00      	add	r7, sp, #0
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex = 0U;
 80213d8:	4b12      	ldr	r3, [pc, #72]	; (8021424 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80213da:	2200      	movs	r2, #0
 80213dc:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedcheck = 0U;
 80213e0:	4b10      	ldr	r3, [pc, #64]	; (8021424 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80213e2:	2200      	movs	r2, #0
 80213e4:	61da      	str	r2, [r3, #28]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[0] = 0U;
 80213e6:	4b0f      	ldr	r3, [pc, #60]	; (8021424 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80213e8:	2200      	movs	r2, #0
 80213ea:	601a      	str	r2, [r3, #0]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[1] = 0U;
 80213ec:	4b0d      	ldr	r3, [pc, #52]	; (8021424 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80213ee:	2200      	movs	r2, #0
 80213f0:	605a      	str	r2, [r3, #4]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[2] = 0U;
 80213f2:	4b0c      	ldr	r3, [pc, #48]	; (8021424 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80213f4:	2200      	movs	r2, #0
 80213f6:	609a      	str	r2, [r3, #8]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[3] = 0U;
 80213f8:	4b0a      	ldr	r3, [pc, #40]	; (8021424 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80213fa:	2200      	movs	r2, #0
 80213fc:	60da      	str	r2, [r3, #12]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[4] = 0U;
 80213fe:	4b09      	ldr	r3, [pc, #36]	; (8021424 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8021400:	2200      	movs	r2, #0
 8021402:	611a      	str	r2, [r3, #16]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[5] = 0U;
 8021404:	4b07      	ldr	r3, [pc, #28]	; (8021424 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8021406:	2200      	movs	r2, #0
 8021408:	615a      	str	r2, [r3, #20]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.capval = Motor0_BLDC_SCALAR_SPEED_POS_HALL.speed_constant;
 802140a:	4b06      	ldr	r3, [pc, #24]	; (8021424 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 802140c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802140e:	4a05      	ldr	r2, [pc, #20]	; (8021424 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8021410:	6193      	str	r3, [r2, #24]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum = 0U;
 8021412:	4b04      	ldr	r3, [pc, #16]	; (8021424 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 8021414:	2200      	movs	r2, #0
 8021416:	621a      	str	r2, [r3, #32]
}
 8021418:	bf00      	nop
 802141a:	46bd      	mov	sp, r7
 802141c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021420:	4770      	bx	lr
 8021422:	bf00      	nop
 8021424:	1ffe92bc 	.word	0x1ffe92bc

08021428 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>:
 *
 * \par<b>Description</b><br>
 * Returns last sampled hall sensor pattern of \a peripheral.\n
 */
__STATIC_INLINE uint8_t Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern(void)
{
 8021428:	b580      	push	{r7, lr}
 802142a:	b082      	sub	sp, #8
 802142c:	af00      	add	r7, sp, #0
  uint8_t hall_pattern;
  hall_pattern = XMC_POSIF_HSC_GetLastSampledPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 802142e:	4805      	ldr	r0, [pc, #20]	; (8021444 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern+0x1c>)
 8021430:	f7ff ff66 	bl	8021300 <XMC_POSIF_HSC_GetLastSampledPattern>
 8021434:	4603      	mov	r3, r0
 8021436:	71fb      	strb	r3, [r7, #7]
  return(hall_pattern);
 8021438:	79fb      	ldrb	r3, [r7, #7]
}
 802143a:	4618      	mov	r0, r3
 802143c:	3708      	adds	r7, #8
 802143e:	46bd      	mov	sp, r7
 8021440:	bd80      	pop	{r7, pc}
 8021442:	bf00      	nop
 8021444:	40028000 	.word	0x40028000

08021448 <VADC_GetResult>:
 *
 * \par<b>Description:</b><br>
 * Returns the VADC conversion result by reading result register from selected group number.
 */
__STATIC_INLINE XMC_VADC_RESULT_SIZE_t VADC_GetResult(XMC_VADC_GROUP_t *const group_ptr, const uint32_t res_reg)
{
 8021448:	b580      	push	{r7, lr}
 802144a:	b084      	sub	sp, #16
 802144c:	af00      	add	r7, sp, #0
 802144e:	6078      	str	r0, [r7, #4]
 8021450:	6039      	str	r1, [r7, #0]
  XMC_VADC_RESULT_SIZE_t result;
  result = (XMC_VADC_RESULT_SIZE_t) XMC_VADC_GROUP_GetResult(group_ptr,res_reg);
 8021452:	6839      	ldr	r1, [r7, #0]
 8021454:	6878      	ldr	r0, [r7, #4]
 8021456:	f7ff ff66 	bl	8021326 <XMC_VADC_GROUP_GetResult>
 802145a:	4603      	mov	r3, r0
 802145c:	81fb      	strh	r3, [r7, #14]
  return(result);
 802145e:	89fb      	ldrh	r3, [r7, #14]
}
 8021460:	4618      	mov	r0, r3
 8021462:	3710      	adds	r7, #16
 8021464:	46bd      	mov	sp, r7
 8021466:	bd80      	pop	{r7, pc}

08021468 <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter>:
 *
 * \par<b>Description:</b><br>
 * Limits the input value based on higher_limit and lower_limit
 */
__STATIC_INLINE int32_t Motor0_BLDC_SCALAR_PT1_MinMaxLimiter(int32_t input_val, int32_t higher_limit, int32_t lower_limit)
{
 8021468:	b480      	push	{r7}
 802146a:	b087      	sub	sp, #28
 802146c:	af00      	add	r7, sp, #0
 802146e:	60f8      	str	r0, [r7, #12]
 8021470:	60b9      	str	r1, [r7, #8]
 8021472:	607a      	str	r2, [r7, #4]
  int32_t return_val;
  if ( input_val > higher_limit )
 8021474:	68fa      	ldr	r2, [r7, #12]
 8021476:	68bb      	ldr	r3, [r7, #8]
 8021478:	429a      	cmp	r2, r3
 802147a:	dd02      	ble.n	8021482 <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x1a>
  {
    return_val = higher_limit;
 802147c:	68bb      	ldr	r3, [r7, #8]
 802147e:	617b      	str	r3, [r7, #20]
 8021480:	e008      	b.n	8021494 <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x2c>
  }
  else if ( input_val < lower_limit )
 8021482:	68fa      	ldr	r2, [r7, #12]
 8021484:	687b      	ldr	r3, [r7, #4]
 8021486:	429a      	cmp	r2, r3
 8021488:	da02      	bge.n	8021490 <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x28>
  {
    return_val = lower_limit;
 802148a:	687b      	ldr	r3, [r7, #4]
 802148c:	617b      	str	r3, [r7, #20]
 802148e:	e001      	b.n	8021494 <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x2c>
  }
  else
  {
    return_val = input_val;
 8021490:	68fb      	ldr	r3, [r7, #12]
 8021492:	617b      	str	r3, [r7, #20]
  }
  return return_val;
 8021494:	697b      	ldr	r3, [r7, #20]
}
 8021496:	4618      	mov	r0, r3
 8021498:	371c      	adds	r7, #28
 802149a:	46bd      	mov	sp, r7
 802149c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80214a0:	4770      	bx	lr

080214a2 <Motor0_BLDC_SCALAR_PT1_Filter>:
  * Yn[3,2,1,0] =Yn-1[3,2,1,0] +Z1*(Xn -Yn-1[3,2]) \n
  * Where Z1 is time constant.
  */

__STATIC_INLINE void Motor0_BLDC_SCALAR_PT1_Filter(BLDC_SCALAR_PT1_FILTER_t *handle_ptr, int32_t actual_val)
{
 80214a2:	b590      	push	{r4, r7, lr}
 80214a4:	b083      	sub	sp, #12
 80214a6:	af00      	add	r7, sp, #0
 80214a8:	6078      	str	r0, [r7, #4]
 80214aa:	6039      	str	r1, [r7, #0]
  register int32_t temp_buff;

  /* yn+1 = yn + z1*(x - yn) */
  temp_buff = handle_ptr->pt1_buf + (handle_ptr->z1*(actual_val - (handle_ptr->pt1_buf >> BLDC_SCALAR_PT1_SHIFT_16)));
 80214ac:	687b      	ldr	r3, [r7, #4]
 80214ae:	691a      	ldr	r2, [r3, #16]
 80214b0:	687b      	ldr	r3, [r7, #4]
 80214b2:	681b      	ldr	r3, [r3, #0]
 80214b4:	6879      	ldr	r1, [r7, #4]
 80214b6:	6909      	ldr	r1, [r1, #16]
 80214b8:	1409      	asrs	r1, r1, #16
 80214ba:	6838      	ldr	r0, [r7, #0]
 80214bc:	1a41      	subs	r1, r0, r1
 80214be:	fb01 f303 	mul.w	r3, r1, r3
 80214c2:	18d4      	adds	r4, r2, r3
  /* Checking the buffer limits in the range of Ymin to Ymax */
  handle_ptr->pt1_buf = Motor0_BLDC_SCALAR_PT1_MinMaxLimiter(temp_buff, handle_ptr->y_max, handle_ptr->y_min);
 80214c4:	687b      	ldr	r3, [r7, #4]
 80214c6:	6899      	ldr	r1, [r3, #8]
 80214c8:	687b      	ldr	r3, [r7, #4]
 80214ca:	68db      	ldr	r3, [r3, #12]
 80214cc:	461a      	mov	r2, r3
 80214ce:	4620      	mov	r0, r4
 80214d0:	f7ff ffca 	bl	8021468 <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter>
 80214d4:	4602      	mov	r2, r0
 80214d6:	687b      	ldr	r3, [r7, #4]
 80214d8:	611a      	str	r2, [r3, #16]
  handle_ptr->pt1_out_val = (handle_ptr->pt1_buf >> BLDC_SCALAR_PT1_SHIFT_16);
 80214da:	687b      	ldr	r3, [r7, #4]
 80214dc:	691b      	ldr	r3, [r3, #16]
 80214de:	141a      	asrs	r2, r3, #16
 80214e0:	687b      	ldr	r3, [r7, #4]
 80214e2:	615a      	str	r2, [r3, #20]
}
 80214e4:	bf00      	nop
 80214e6:	370c      	adds	r7, #12
 80214e8:	46bd      	mov	sp, r7
 80214ea:	bd90      	pop	{r4, r7, pc}

080214ec <Motor0_BLDC_SCALAR_GetCurrentValue>:
 * without PT1 filter:                                    <b>0.78 uSec </b>\n
 * with PT1 filter:                                       <b>1.46 uSec </b>\n
 * with filter and with demagnetization blanking enabled: <b>1.6 uSec </b>\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_GetCurrentValue(int32_t *dclink_current)
{
 80214ec:	b580      	push	{r7, lr}
 80214ee:	b084      	sub	sp, #16
 80214f0:	af00      	add	r7, sp, #0
 80214f2:	6078      	str	r0, [r7, #4]
  int32_t current_value;
  current_value = (int32_t)VADC_GetResult(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP,MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_RES_REG_NUM);
 80214f4:	2105      	movs	r1, #5
 80214f6:	4821      	ldr	r0, [pc, #132]	; (802157c <Motor0_BLDC_SCALAR_GetCurrentValue+0x90>)
 80214f8:	f7ff ffa6 	bl	8021448 <VADC_GetResult>
 80214fc:	4603      	mov	r3, r0
 80214fe:	60fb      	str	r3, [r7, #12]
  current_value = (int32_t)(((current_value - Motor0_BLDC_SCALAR_CurrentMeasurement.direct_dc_amplifier_offset) * (int32_t)Motor0_BLDC_SCALAR_CurrentMeasurement.current_adc_scale) >> BLDC_SCALAR_SHIFT_14);
 8021500:	4b1f      	ldr	r3, [pc, #124]	; (8021580 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021502:	681b      	ldr	r3, [r3, #0]
 8021504:	68fa      	ldr	r2, [r7, #12]
 8021506:	1ad3      	subs	r3, r2, r3
 8021508:	4a1d      	ldr	r2, [pc, #116]	; (8021580 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 802150a:	6892      	ldr	r2, [r2, #8]
 802150c:	fb02 f303 	mul.w	r3, r2, r3
 8021510:	139b      	asrs	r3, r3, #14
 8021512:	60fb      	str	r3, [r7, #12]

  #if(MOTOR0_BLDC_SCALAR_ENABLE_IDC_LINK_CURRENT_FILTER == 1U)
  /* PT1 filter   */
  Motor0_BLDC_SCALAR_PT1_Filter(&Motor0_BLDC_SCALAR_PT1_DirectCurrent,(int32_t)current_value);
 8021514:	68f9      	ldr	r1, [r7, #12]
 8021516:	481b      	ldr	r0, [pc, #108]	; (8021584 <Motor0_BLDC_SCALAR_GetCurrentValue+0x98>)
 8021518:	f7ff ffc3 	bl	80214a2 <Motor0_BLDC_SCALAR_PT1_Filter>
  current_value = ((Motor0_BLDC_SCALAR_PT1_DirectCurrent.pt1_out_val));
 802151c:	4b19      	ldr	r3, [pc, #100]	; (8021584 <Motor0_BLDC_SCALAR_GetCurrentValue+0x98>)
 802151e:	695b      	ldr	r3, [r3, #20]
 8021520:	60fb      	str	r3, [r7, #12]
  /*
   * Skip the direct DC link current measurement at commutation point based on de-magnetization count
   * This is required only if the SW filter is disabled
   */
#if (MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING == 1U)
  if (Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_enable == 1U)
 8021522:	4b17      	ldr	r3, [pc, #92]	; (8021580 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021524:	f893 3020 	ldrb.w	r3, [r3, #32]
 8021528:	2b01      	cmp	r3, #1
 802152a:	d11c      	bne.n	8021566 <Motor0_BLDC_SCALAR_GetCurrentValue+0x7a>
  {
    Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter++;
 802152c:	4b14      	ldr	r3, [pc, #80]	; (8021580 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 802152e:	69db      	ldr	r3, [r3, #28]
 8021530:	3301      	adds	r3, #1
 8021532:	4a13      	ldr	r2, [pc, #76]	; (8021580 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021534:	61d3      	str	r3, [r2, #28]
    if (Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter >
 8021536:	4b12      	ldr	r3, [pc, #72]	; (8021580 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021538:	69da      	ldr	r2, [r3, #28]
        Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_count)
 802153a:	4b11      	ldr	r3, [pc, #68]	; (8021580 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 802153c:	699b      	ldr	r3, [r3, #24]
    if (Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter >
 802153e:	429a      	cmp	r2, r3
 8021540:	d90c      	bls.n	802155c <Motor0_BLDC_SCALAR_GetCurrentValue+0x70>
    {
      /* De-magnetization blanking time over. Read current and reset the De-magnetization counter */
     *dclink_current = current_value;
 8021542:	687b      	ldr	r3, [r7, #4]
 8021544:	68fa      	ldr	r2, [r7, #12]
 8021546:	601a      	str	r2, [r3, #0]
     Motor0_BLDC_SCALAR_CurrentMeasurement.prev_current = current_value;
 8021548:	4a0d      	ldr	r2, [pc, #52]	; (8021580 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 802154a:	68fb      	ldr	r3, [r7, #12]
 802154c:	6113      	str	r3, [r2, #16]
     Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter = 0U;
 802154e:	4b0c      	ldr	r3, [pc, #48]	; (8021580 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021550:	2200      	movs	r2, #0
 8021552:	61da      	str	r2, [r3, #28]
     Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_enable = 0U;
 8021554:	4b0a      	ldr	r3, [pc, #40]	; (8021580 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021556:	2200      	movs	r2, #0
 8021558:	f883 2020 	strb.w	r2, [r3, #32]
    }
    *dclink_current = Motor0_BLDC_SCALAR_CurrentMeasurement.prev_current;
 802155c:	4b08      	ldr	r3, [pc, #32]	; (8021580 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 802155e:	691a      	ldr	r2, [r3, #16]
 8021560:	687b      	ldr	r3, [r7, #4]
 8021562:	601a      	str	r2, [r3, #0]
    *dclink_current = current_value;
    Motor0_BLDC_SCALAR_CurrentMeasurement.prev_current =  current_value;
#if (MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING == 1U)
  }
#endif /* end of #if (MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING == 1U) */
}
 8021564:	e005      	b.n	8021572 <Motor0_BLDC_SCALAR_GetCurrentValue+0x86>
    *dclink_current = current_value;
 8021566:	687b      	ldr	r3, [r7, #4]
 8021568:	68fa      	ldr	r2, [r7, #12]
 802156a:	601a      	str	r2, [r3, #0]
    Motor0_BLDC_SCALAR_CurrentMeasurement.prev_current =  current_value;
 802156c:	4a04      	ldr	r2, [pc, #16]	; (8021580 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 802156e:	68fb      	ldr	r3, [r7, #12]
 8021570:	6113      	str	r3, [r2, #16]
}
 8021572:	bf00      	nop
 8021574:	3710      	adds	r7, #16
 8021576:	46bd      	mov	sp, r7
 8021578:	bd80      	pop	{r7, pc}
 802157a:	bf00      	nop
 802157c:	40005000 	.word	0x40005000
 8021580:	1ffe92e8 	.word	0x1ffe92e8
 8021584:	1ffe9268 	.word	0x1ffe9268

08021588 <Motor0_BLDC_SCALAR_GetAverageCurrentValue>:
 * without PT1 filter: <b>0.588 uSec </b> \n
 * with PT1 filter: <b>1.380 uSec </b>\n
 * with filter and with MOTOR0_BLDC_SCALAR_VADC_ENABLE_AVERAGE_CURRENT_USING_IDC_LINK enabled: <b>1.508 uSec </b>\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_GetAverageCurrentValue(int32_t *dclink_average_current)
{
 8021588:	b580      	push	{r7, lr}
 802158a:	b084      	sub	sp, #16
 802158c:	af00      	add	r7, sp, #0
 802158e:	6078      	str	r0, [r7, #4]
  /* Average current pin */
  current_value = (int32_t)VADC_GetResult(MOTOR0_BLDC_SCALAR_VADC_IDC_AVERAGE_GRP,MOTOR0_BLDC_SCALAR_VADC_IDC_AVERAGE_RES_REG_NUM);
  current_value = (int32_t)(((current_value - Motor0_BLDC_SCALAR_CurrentMeasurement.avg_dc_amplifier_offset) * (int32_t)Motor0_BLDC_SCALAR_CurrentMeasurement.current_adc_scale) >> BLDC_SCALAR_SHIFT_14);
#else
  /* Average current calculated from DC link current pin */
  current_value = (int32_t)VADC_GetResult(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP,MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_RES_REG_NUM);
 8021590:	2105      	movs	r1, #5
 8021592:	480f      	ldr	r0, [pc, #60]	; (80215d0 <Motor0_BLDC_SCALAR_GetAverageCurrentValue+0x48>)
 8021594:	f7ff ff58 	bl	8021448 <VADC_GetResult>
 8021598:	4603      	mov	r3, r0
 802159a:	60fb      	str	r3, [r7, #12]
  current_value = (int32_t)(((current_value - Motor0_BLDC_SCALAR_CurrentMeasurement.direct_dc_amplifier_offset) * (int32_t)Motor0_BLDC_SCALAR_CurrentMeasurement.current_adc_scale) >> BLDC_SCALAR_SHIFT_14);
 802159c:	4b0d      	ldr	r3, [pc, #52]	; (80215d4 <Motor0_BLDC_SCALAR_GetAverageCurrentValue+0x4c>)
 802159e:	681b      	ldr	r3, [r3, #0]
 80215a0:	68fa      	ldr	r2, [r7, #12]
 80215a2:	1ad3      	subs	r3, r2, r3
 80215a4:	4a0b      	ldr	r2, [pc, #44]	; (80215d4 <Motor0_BLDC_SCALAR_GetAverageCurrentValue+0x4c>)
 80215a6:	6892      	ldr	r2, [r2, #8]
 80215a8:	fb02 f303 	mul.w	r3, r2, r3
 80215ac:	139b      	asrs	r3, r3, #14
 80215ae:	60fb      	str	r3, [r7, #12]
  current_value = (current_value * ((int32_t)*Motor0_BLDC_SCALAR_CurrentMeasurement.amplitude)) >> BLDC_SCALAR_SHIFT_14;
 80215b0:	4b08      	ldr	r3, [pc, #32]	; (80215d4 <Motor0_BLDC_SCALAR_GetAverageCurrentValue+0x4c>)
 80215b2:	695b      	ldr	r3, [r3, #20]
 80215b4:	681b      	ldr	r3, [r3, #0]
 80215b6:	461a      	mov	r2, r3
 80215b8:	68fb      	ldr	r3, [r7, #12]
 80215ba:	fb02 f303 	mul.w	r3, r2, r3
 80215be:	139b      	asrs	r3, r3, #14
 80215c0:	60fb      	str	r3, [r7, #12]
#if (MOTOR0_BLDC_SCALAR_ENABLE_IDC_AVERAGE_CURRENT_FILTER == 1U)
  /* PT1 filter is used to remove high frequency noise of average DC link current */
  Motor0_BLDC_SCALAR_PT1_Filter(&Motor0_BLDC_SCALAR_PT1_AverageCurrent,(int32_t)current_value);
  *dclink_average_current = ((Motor0_BLDC_SCALAR_PT1_AverageCurrent.pt1_out_val));
#else
  *dclink_average_current = current_value;
 80215c2:	687b      	ldr	r3, [r7, #4]
 80215c4:	68fa      	ldr	r2, [r7, #12]
 80215c6:	601a      	str	r2, [r3, #0]
#endif /* end of #if (MOTOR0_BLDC_SCALAR_ENABLE_IDC_AVERAGE_CURRENT_FILTER == 1U) */
}
 80215c8:	bf00      	nop
 80215ca:	3710      	adds	r7, #16
 80215cc:	46bd      	mov	sp, r7
 80215ce:	bd80      	pop	{r7, pc}
 80215d0:	40005000 	.word	0x40005000
 80215d4:	1ffe92e8 	.word	0x1ffe92e8

080215d8 <Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT>:
 *
 * \par<b>Description:</b><br>
 * Limits the input value based on higher_limit and lower_limit
 */
__STATIC_INLINE int32_t Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT(int32_t input_val, int32_t higher_limit, int32_t lower_limit)
{
 80215d8:	b480      	push	{r7}
 80215da:	b087      	sub	sp, #28
 80215dc:	af00      	add	r7, sp, #0
 80215de:	60f8      	str	r0, [r7, #12]
 80215e0:	60b9      	str	r1, [r7, #8]
 80215e2:	607a      	str	r2, [r7, #4]
  int32_t return_val;
  if ( input_val > higher_limit )
 80215e4:	68fa      	ldr	r2, [r7, #12]
 80215e6:	68bb      	ldr	r3, [r7, #8]
 80215e8:	429a      	cmp	r2, r3
 80215ea:	dd02      	ble.n	80215f2 <Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT+0x1a>
  {
    return_val = higher_limit;
 80215ec:	68bb      	ldr	r3, [r7, #8]
 80215ee:	617b      	str	r3, [r7, #20]
 80215f0:	e008      	b.n	8021604 <Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT+0x2c>
  }
  else if ( input_val < lower_limit )
 80215f2:	68fa      	ldr	r2, [r7, #12]
 80215f4:	687b      	ldr	r3, [r7, #4]
 80215f6:	429a      	cmp	r2, r3
 80215f8:	da02      	bge.n	8021600 <Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT+0x28>
  {
    return_val = lower_limit;
 80215fa:	687b      	ldr	r3, [r7, #4]
 80215fc:	617b      	str	r3, [r7, #20]
 80215fe:	e001      	b.n	8021604 <Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT+0x2c>
  }
  else
  {
    return_val = input_val;
 8021600:	68fb      	ldr	r3, [r7, #12]
 8021602:	617b      	str	r3, [r7, #20]
  }
  return return_val;
 8021604:	697b      	ldr	r3, [r7, #20]
}
 8021606:	4618      	mov	r0, r3
 8021608:	371c      	adds	r7, #28
 802160a:	46bd      	mov	sp, r7
 802160c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021610:	4770      	bx	lr

08021612 <Motor0_BLDC_SCALAR_PI_SAT_STATE>:
 *
 * \par<b>Description:</b><br>
 * Checks if PI saturation flag is set
 */
__STATIC_INLINE uint8_t Motor0_BLDC_SCALAR_PI_SAT_STATE(int32_t input1, int32_t input2)
{
 8021612:	b480      	push	{r7}
 8021614:	b085      	sub	sp, #20
 8021616:	af00      	add	r7, sp, #0
 8021618:	6078      	str	r0, [r7, #4]
 802161a:	6039      	str	r1, [r7, #0]
  uint8_t return_val;
  if (input1 == input2)
 802161c:	687a      	ldr	r2, [r7, #4]
 802161e:	683b      	ldr	r3, [r7, #0]
 8021620:	429a      	cmp	r2, r3
 8021622:	d102      	bne.n	802162a <Motor0_BLDC_SCALAR_PI_SAT_STATE+0x18>
  {
    return_val = 1U;
 8021624:	2301      	movs	r3, #1
 8021626:	73fb      	strb	r3, [r7, #15]
 8021628:	e001      	b.n	802162e <Motor0_BLDC_SCALAR_PI_SAT_STATE+0x1c>
  }
  else
  {
    return_val = 0U;
 802162a:	2300      	movs	r3, #0
 802162c:	73fb      	strb	r3, [r7, #15]
  }
  return (return_val);
 802162e:	7bfb      	ldrb	r3, [r7, #15]
}
 8021630:	4618      	mov	r0, r3
 8021632:	3714      	adds	r7, #20
 8021634:	46bd      	mov	sp, r7
 8021636:	f85d 7b04 	ldr.w	r7, [sp], #4
 802163a:	4770      	bx	lr

0802163c <Motor0_BLDC_SCALAR_PI_Controller>:
__STATIC_INLINE void Motor0_BLDC_SCALAR_PI_Controller
(
    BLDC_SCALAR_PI_CONTROLLER_t *handle_ptr,
    int32_t error_val
)
{
 802163c:	b590      	push	{r4, r7, lr}
 802163e:	b083      	sub	sp, #12
 8021640:	af00      	add	r7, sp, #0
 8021642:	6078      	str	r0, [r7, #4]
 8021644:	6039      	str	r1, [r7, #0]
  register int32_t u_k;
  register int32_t error = error_val;
 8021646:	683c      	ldr	r4, [r7, #0]

  handle_ptr->ik = (int32_t)(error * (int32_t)handle_ptr->ki * (int32_t)handle_ptr->sat_state) + handle_ptr->ik;              /*Integral output I[k] = I[k-1] + Ki * error[k] */
 8021648:	687b      	ldr	r3, [r7, #4]
 802164a:	8a5b      	ldrh	r3, [r3, #18]
 802164c:	fb04 f303 	mul.w	r3, r4, r3
 8021650:	687a      	ldr	r2, [r7, #4]
 8021652:	7d52      	ldrb	r2, [r2, #21]
 8021654:	fb03 f202 	mul.w	r2, r3, r2
 8021658:	687b      	ldr	r3, [r7, #4]
 802165a:	685b      	ldr	r3, [r3, #4]
 802165c:	441a      	add	r2, r3
 802165e:	687b      	ldr	r3, [r7, #4]
 8021660:	605a      	str	r2, [r3, #4]
  u_k = (( error * (int32_t)handle_ptr->kp) + handle_ptr->ik) >> handle_ptr->scale_kpki;         /*PI output U[k] = Kp * error[k] + I[k]. */
 8021662:	687b      	ldr	r3, [r7, #4]
 8021664:	8a1b      	ldrh	r3, [r3, #16]
 8021666:	fb03 f204 	mul.w	r2, r3, r4
 802166a:	687b      	ldr	r3, [r7, #4]
 802166c:	685b      	ldr	r3, [r3, #4]
 802166e:	4413      	add	r3, r2
 8021670:	687a      	ldr	r2, [r7, #4]
 8021672:	7d12      	ldrb	r2, [r2, #20]
 8021674:	fa43 f402 	asr.w	r4, r3, r2
  handle_ptr->uk = Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT(u_k, handle_ptr->uk_limit_max, handle_ptr->uk_limit_min);  /* Check U[k] output limit. Vq = handle_ptr->Uk. */
 8021678:	687b      	ldr	r3, [r7, #4]
 802167a:	68d9      	ldr	r1, [r3, #12]
 802167c:	687b      	ldr	r3, [r7, #4]
 802167e:	689b      	ldr	r3, [r3, #8]
 8021680:	461a      	mov	r2, r3
 8021682:	4620      	mov	r0, r4
 8021684:	f7ff ffa8 	bl	80215d8 <Motor0_BLDC_SCALAR_PI_MIN_MAX_LIMIT>
 8021688:	4602      	mov	r2, r0
 802168a:	687b      	ldr	r3, [r7, #4]
 802168c:	601a      	str	r2, [r3, #0]
  handle_ptr->sat_state = (uint8_t)Motor0_BLDC_SCALAR_PI_SAT_STATE(u_k, handle_ptr->uk);                                   /* Update saturation flag */
 802168e:	687b      	ldr	r3, [r7, #4]
 8021690:	681b      	ldr	r3, [r3, #0]
 8021692:	4619      	mov	r1, r3
 8021694:	4620      	mov	r0, r4
 8021696:	f7ff ffbc 	bl	8021612 <Motor0_BLDC_SCALAR_PI_SAT_STATE>
 802169a:	4603      	mov	r3, r0
 802169c:	461a      	mov	r2, r3
 802169e:	687b      	ldr	r3, [r7, #4]
 80216a0:	755a      	strb	r2, [r3, #21]
}
 80216a2:	bf00      	nop
 80216a4:	370c      	adds	r7, #12
 80216a6:	46bd      	mov	sp, r7
 80216a8:	bd90      	pop	{r4, r7, pc}
	...

080216ac <Motor0_BLDC_SCALAR_SpeedControlScheme>:
 *
 * \par<b>Execution Time:</b><br>
 * <b>1.820 uSec </b>using O3 optimization level
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SpeedControlScheme(int32_t *output)
{
 80216ac:	b580      	push	{r7, lr}
 80216ae:	b084      	sub	sp, #16
 80216b0:	af00      	add	r7, sp, #0
 80216b2:	6078      	str	r0, [r7, #4]
  int32_t error;
  Motor0_BLDC_SCALAR_SpeedControl.fdbk_speed = Motor0_BLDC_SCALAR.motor_speed;
 80216b4:	4b0c      	ldr	r3, [pc, #48]	; (80216e8 <Motor0_BLDC_SCALAR_SpeedControlScheme+0x3c>)
 80216b6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80216b8:	4a0c      	ldr	r2, [pc, #48]	; (80216ec <Motor0_BLDC_SCALAR_SpeedControlScheme+0x40>)
 80216ba:	60d3      	str	r3, [r2, #12]
#if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U)
  Motor0_BLDC_SCALAR_SpeedControl.ref_speed = Motor0_BLDC_SCALAR_Ramp.set_value;
 80216bc:	4b0c      	ldr	r3, [pc, #48]	; (80216f0 <Motor0_BLDC_SCALAR_SpeedControlScheme+0x44>)
 80216be:	681b      	ldr	r3, [r3, #0]
 80216c0:	4a0a      	ldr	r2, [pc, #40]	; (80216ec <Motor0_BLDC_SCALAR_SpeedControlScheme+0x40>)
 80216c2:	6093      	str	r3, [r2, #8]
  Motor0_BLDC_SCALAR_SpeedControl.ref_speed = Motor0_BLDC_SCALAR.analogip_val;
#else
  Motor0_BLDC_SCALAR_SpeedControl.ref_speed = Motor0_BLDC_SCALAR_SpeedControl.user_speed_set;
#endif

  error = (int32_t)(Motor0_BLDC_SCALAR_SpeedControl.ref_speed) - (int32_t)(Motor0_BLDC_SCALAR_SpeedControl.fdbk_speed);
 80216c4:	4b09      	ldr	r3, [pc, #36]	; (80216ec <Motor0_BLDC_SCALAR_SpeedControlScheme+0x40>)
 80216c6:	689a      	ldr	r2, [r3, #8]
 80216c8:	4b08      	ldr	r3, [pc, #32]	; (80216ec <Motor0_BLDC_SCALAR_SpeedControlScheme+0x40>)
 80216ca:	68db      	ldr	r3, [r3, #12]
 80216cc:	1ad3      	subs	r3, r2, r3
 80216ce:	60fb      	str	r3, [r7, #12]

  /*Speed Control based on PI technique*/
  Motor0_BLDC_SCALAR_PI_Controller(&Motor0_BLDC_SCALAR_SpeedControl_PI,(int32_t)error);
 80216d0:	68f9      	ldr	r1, [r7, #12]
 80216d2:	4808      	ldr	r0, [pc, #32]	; (80216f4 <Motor0_BLDC_SCALAR_SpeedControlScheme+0x48>)
 80216d4:	f7ff ffb2 	bl	802163c <Motor0_BLDC_SCALAR_PI_Controller>

  *output = Motor0_BLDC_SCALAR_SpeedControl_PI.uk;
 80216d8:	4b06      	ldr	r3, [pc, #24]	; (80216f4 <Motor0_BLDC_SCALAR_SpeedControlScheme+0x48>)
 80216da:	681a      	ldr	r2, [r3, #0]
 80216dc:	687b      	ldr	r3, [r7, #4]
 80216de:	601a      	str	r2, [r3, #0]
}
 80216e0:	bf00      	nop
 80216e2:	3710      	adds	r7, #16
 80216e4:	46bd      	mov	sp, r7
 80216e6:	bd80      	pop	{r7, pc}
 80216e8:	1ffe9350 	.word	0x1ffe9350
 80216ec:	1ffe930c 	.word	0x1ffe930c
 80216f0:	1ffe9280 	.word	0x1ffe9280
 80216f4:	1ffe9250 	.word	0x1ffe9250

080216f8 <Motor0_BLDC_SCALAR_DirectionControl>:
 * using O3 optimization level \n
 * without bi-direction control: <b>0.120 uSec</b> \n
 * with bi-direction control (normal operation): <b>0.820 uSec </b>\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_DirectionControl(int32_t output, uint32_t *amplitude)
{
 80216f8:	b580      	push	{r7, lr}
 80216fa:	b084      	sub	sp, #16
 80216fc:	af00      	add	r7, sp, #0
 80216fe:	6078      	str	r0, [r7, #4]
 8021700:	6039      	str	r1, [r7, #0]

  /*
   * Change the direction when control scheme output is of reverse polarity of the set motor direction
   * Get the absolute value of the amplitude
   */
  if (output < 0)
 8021702:	687b      	ldr	r3, [r7, #4]
 8021704:	2b00      	cmp	r3, #0
 8021706:	da13      	bge.n	8021730 <Motor0_BLDC_SCALAR_DirectionControl+0x38>
  {
    output = -1 * output;
 8021708:	687b      	ldr	r3, [r7, #4]
 802170a:	425b      	negs	r3, r3
 802170c:	607b      	str	r3, [r7, #4]

    if (Motor0_BLDC_SCALAR.motor_set_direction == BLDC_SCALAR_POSITIVE_DIR)
 802170e:	4b25      	ldr	r3, [pc, #148]	; (80217a4 <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 8021710:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8021712:	2b01      	cmp	r3, #1
 8021714:	d11f      	bne.n	8021756 <Motor0_BLDC_SCALAR_DirectionControl+0x5e>
    {
      Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_NEGATIVE_DIR;
 8021716:	4b23      	ldr	r3, [pc, #140]	; (80217a4 <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 8021718:	f04f 32ff 	mov.w	r2, #4294967295
 802171c:	679a      	str	r2, [r3, #120]	; 0x78
      index = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern();
 802171e:	f7ff fe83 	bl	8021428 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>
 8021722:	4603      	mov	r3, r0
 8021724:	73fb      	strb	r3, [r7, #15]
      Motor0_BLDC_SCALAR_PatternInitiator(index);
 8021726:	7bfb      	ldrb	r3, [r7, #15]
 8021728:	4618      	mov	r0, r3
 802172a:	f006 fe35 	bl	8028398 <__Motor0_BLDC_SCALAR_PatternInitiator_veneer>
 802172e:	e012      	b.n	8021756 <Motor0_BLDC_SCALAR_DirectionControl+0x5e>
    }
  }
  else if (output > 0)
 8021730:	687b      	ldr	r3, [r7, #4]
 8021732:	2b00      	cmp	r3, #0
 8021734:	dd0f      	ble.n	8021756 <Motor0_BLDC_SCALAR_DirectionControl+0x5e>
  {
    if (Motor0_BLDC_SCALAR.motor_set_direction == BLDC_SCALAR_NEGATIVE_DIR)
 8021736:	4b1b      	ldr	r3, [pc, #108]	; (80217a4 <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 8021738:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 802173a:	f1b3 3fff 	cmp.w	r3, #4294967295
 802173e:	d10a      	bne.n	8021756 <Motor0_BLDC_SCALAR_DirectionControl+0x5e>
    {
      Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_POSITIVE_DIR;
 8021740:	4b18      	ldr	r3, [pc, #96]	; (80217a4 <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 8021742:	2201      	movs	r2, #1
 8021744:	679a      	str	r2, [r3, #120]	; 0x78
      index = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern();
 8021746:	f7ff fe6f 	bl	8021428 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>
 802174a:	4603      	mov	r3, r0
 802174c:	73fb      	strb	r3, [r7, #15]
      Motor0_BLDC_SCALAR_PatternInitiator(index);
 802174e:	7bfb      	ldrb	r3, [r7, #15]
 8021750:	4618      	mov	r0, r3
 8021752:	f006 fe21 	bl	8028398 <__Motor0_BLDC_SCALAR_PatternInitiator_veneer>
  }
  else
  {

  }
  *amplitude = (uint32_t)output;
 8021756:	687a      	ldr	r2, [r7, #4]
 8021758:	683b      	ldr	r3, [r7, #0]
 802175a:	601a      	str	r2, [r3, #0]
  /* zero speed handling in speed control with bi-directional control */
  #if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL) || (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEEDCURRENT_CTRL))
  #if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_POTENTIOMETER_MEASUREMENT == 1U)
    speed = Motor0_BLDC_SCALAR.analogip_val;
  #else
    speed = Motor0_BLDC_SCALAR_SpeedControl.user_speed_set;
 802175c:	4b12      	ldr	r3, [pc, #72]	; (80217a8 <Motor0_BLDC_SCALAR_DirectionControl+0xb0>)
 802175e:	685b      	ldr	r3, [r3, #4]
 8021760:	60bb      	str	r3, [r7, #8]
  #endif
  if (speed == 0)
 8021762:	68bb      	ldr	r3, [r7, #8]
 8021764:	2b00      	cmp	r3, #0
 8021766:	d119      	bne.n	802179c <Motor0_BLDC_SCALAR_DirectionControl+0xa4>
  {
    /* Limiting speed to 0 when motor speed with in the range of 2% */
    if ((Motor0_BLDC_SCALAR.motor_speed < Motor0_BLDC_SCALAR.min_speed) && (Motor0_BLDC_SCALAR.motor_speed > -Motor0_BLDC_SCALAR.min_speed))
 8021768:	4b0e      	ldr	r3, [pc, #56]	; (80217a4 <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 802176a:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 802176c:	4b0d      	ldr	r3, [pc, #52]	; (80217a4 <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 802176e:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 8021772:	429a      	cmp	r2, r3
 8021774:	da12      	bge.n	802179c <Motor0_BLDC_SCALAR_DirectionControl+0xa4>
 8021776:	4b0b      	ldr	r3, [pc, #44]	; (80217a4 <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 8021778:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 802177a:	4b0a      	ldr	r3, [pc, #40]	; (80217a4 <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 802177c:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 8021780:	425b      	negs	r3, r3
 8021782:	429a      	cmp	r2, r3
 8021784:	dd0a      	ble.n	802179c <Motor0_BLDC_SCALAR_DirectionControl+0xa4>
    {
      Motor0_BLDC_SCALAR.motor_speed = 0;
 8021786:	4b07      	ldr	r3, [pc, #28]	; (80217a4 <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 8021788:	2200      	movs	r2, #0
 802178a:	66da      	str	r2, [r3, #108]	; 0x6c
      Motor0_BLDC_SCALAR.motor_current = 0;
 802178c:	4b05      	ldr	r3, [pc, #20]	; (80217a4 <Motor0_BLDC_SCALAR_DirectionControl+0xac>)
 802178e:	2200      	movs	r2, #0
 8021790:	671a      	str	r2, [r3, #112]	; 0x70
      Motor0_BLDC_SCALAR_SpeedControl_PI.ik = 0;
 8021792:	4b06      	ldr	r3, [pc, #24]	; (80217ac <Motor0_BLDC_SCALAR_DirectionControl+0xb4>)
 8021794:	2200      	movs	r2, #0
 8021796:	605a      	str	r2, [r3, #4]

      /* Reset speed calculation related variables */
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter();
 8021798:	f7ff fe1c 	bl	80213d4 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter>
  {
    output = 0;
  }
  *amplitude = (uint32_t) output;
#endif
}
 802179c:	bf00      	nop
 802179e:	3710      	adds	r7, #16
 80217a0:	46bd      	mov	sp, r7
 80217a2:	bd80      	pop	{r7, pc}
 80217a4:	1ffe9350 	.word	0x1ffe9350
 80217a8:	1ffe930c 	.word	0x1ffe930c
 80217ac:	1ffe9250 	.word	0x1ffe9250

080217b0 <XMC_CCU4_StartPrescaler>:
{
 80217b0:	b480      	push	{r7}
 80217b2:	b083      	sub	sp, #12
 80217b4:	af00      	add	r7, sp, #0
 80217b6:	6078      	str	r0, [r7, #4]
  module->GIDLC = (uint32_t) CCU4_GIDLC_SPRB_Msk;
 80217b8:	687b      	ldr	r3, [r7, #4]
 80217ba:	f44f 7280 	mov.w	r2, #256	; 0x100
 80217be:	60da      	str	r2, [r3, #12]
}
 80217c0:	bf00      	nop
 80217c2:	370c      	adds	r7, #12
 80217c4:	46bd      	mov	sp, r7
 80217c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80217ca:	4770      	bx	lr

080217cc <XMC_CCU4_StopPrescaler>:
{
 80217cc:	b480      	push	{r7}
 80217ce:	b083      	sub	sp, #12
 80217d0:	af00      	add	r7, sp, #0
 80217d2:	6078      	str	r0, [r7, #4]
  module->GIDLS = (uint32_t) CCU4_GIDLS_CPRB_Msk;
 80217d4:	687b      	ldr	r3, [r7, #4]
 80217d6:	f44f 7280 	mov.w	r2, #256	; 0x100
 80217da:	609a      	str	r2, [r3, #8]
}
 80217dc:	bf00      	nop
 80217de:	370c      	adds	r7, #12
 80217e0:	46bd      	mov	sp, r7
 80217e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80217e6:	4770      	bx	lr

080217e8 <XMC_CCU4_SLICE_StartTimer>:
{
 80217e8:	b480      	push	{r7}
 80217ea:	b083      	sub	sp, #12
 80217ec:	af00      	add	r7, sp, #0
 80217ee:	6078      	str	r0, [r7, #4]
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
 80217f0:	687b      	ldr	r3, [r7, #4]
 80217f2:	2201      	movs	r2, #1
 80217f4:	60da      	str	r2, [r3, #12]
}
 80217f6:	bf00      	nop
 80217f8:	370c      	adds	r7, #12
 80217fa:	46bd      	mov	sp, r7
 80217fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021800:	4770      	bx	lr

08021802 <XMC_CCU4_SLICE_StopTimer>:
{
 8021802:	b480      	push	{r7}
 8021804:	b083      	sub	sp, #12
 8021806:	af00      	add	r7, sp, #0
 8021808:	6078      	str	r0, [r7, #4]
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TRBC_Msk;
 802180a:	687b      	ldr	r3, [r7, #4]
 802180c:	2201      	movs	r2, #1
 802180e:	611a      	str	r2, [r3, #16]
}
 8021810:	bf00      	nop
 8021812:	370c      	adds	r7, #12
 8021814:	46bd      	mov	sp, r7
 8021816:	f85d 7b04 	ldr.w	r7, [sp], #4
 802181a:	4770      	bx	lr

0802181c <XMC_CCU4_SLICE_GetTimerValue>:
{
 802181c:	b480      	push	{r7}
 802181e:	b083      	sub	sp, #12
 8021820:	af00      	add	r7, sp, #0
 8021822:	6078      	str	r0, [r7, #4]
  return ((uint16_t)slice->TIMER);
 8021824:	687b      	ldr	r3, [r7, #4]
 8021826:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8021828:	b29b      	uxth	r3, r3
}
 802182a:	4618      	mov	r0, r3
 802182c:	370c      	adds	r7, #12
 802182e:	46bd      	mov	sp, r7
 8021830:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021834:	4770      	bx	lr

08021836 <XMC_CCU4_SLICE_SetTimerValue>:
{
 8021836:	b480      	push	{r7}
 8021838:	b083      	sub	sp, #12
 802183a:	af00      	add	r7, sp, #0
 802183c:	6078      	str	r0, [r7, #4]
 802183e:	460b      	mov	r3, r1
 8021840:	807b      	strh	r3, [r7, #2]
  slice->TIMER = (uint32_t) timer_val;
 8021842:	887a      	ldrh	r2, [r7, #2]
 8021844:	687b      	ldr	r3, [r7, #4]
 8021846:	671a      	str	r2, [r3, #112]	; 0x70
}
 8021848:	bf00      	nop
 802184a:	370c      	adds	r7, #12
 802184c:	46bd      	mov	sp, r7
 802184e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021852:	4770      	bx	lr

08021854 <XMC_POSIF_HSC_GetLastSampledPattern>:
{
 8021854:	b480      	push	{r7}
 8021856:	b083      	sub	sp, #12
 8021858:	af00      	add	r7, sp, #0
 802185a:	6078      	str	r0, [r7, #4]
  return ((uint8_t)((peripheral->PDBG) & POSIF_PDBG_HSP_Msk) >> POSIF_PDBG_HSP_Pos);
 802185c:	687b      	ldr	r3, [r7, #4]
 802185e:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8021862:	b2db      	uxtb	r3, r3
 8021864:	115b      	asrs	r3, r3, #5
 8021866:	b2db      	uxtb	r3, r3
 8021868:	f003 0307 	and.w	r3, r3, #7
 802186c:	b2db      	uxtb	r3, r3
}
 802186e:	4618      	mov	r0, r3
 8021870:	370c      	adds	r7, #12
 8021872:	46bd      	mov	sp, r7
 8021874:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021878:	4770      	bx	lr

0802187a <XMC_POSIF_HSC_GetExpectedPattern>:
{
 802187a:	b480      	push	{r7}
 802187c:	b083      	sub	sp, #12
 802187e:	af00      	add	r7, sp, #0
 8021880:	6078      	str	r0, [r7, #4]
  return ((uint8_t)((peripheral->HALP & POSIF_HALP_HEP_Msk) >> POSIF_HALP_HEP_Pos));
 8021882:	687b      	ldr	r3, [r7, #4]
 8021884:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8021886:	08db      	lsrs	r3, r3, #3
 8021888:	b2db      	uxtb	r3, r3
 802188a:	f003 0307 	and.w	r3, r3, #7
 802188e:	b2db      	uxtb	r3, r3
}
 8021890:	4618      	mov	r0, r3
 8021892:	370c      	adds	r7, #12
 8021894:	46bd      	mov	sp, r7
 8021896:	f85d 7b04 	ldr.w	r7, [sp], #4
 802189a:	4770      	bx	lr

0802189c <XMC_POSIF_HSC_SetHallPatterns>:
{
 802189c:	b480      	push	{r7}
 802189e:	b083      	sub	sp, #12
 80218a0:	af00      	add	r7, sp, #0
 80218a2:	6078      	str	r0, [r7, #4]
 80218a4:	460b      	mov	r3, r1
 80218a6:	70fb      	strb	r3, [r7, #3]
  peripheral->HALPS = (uint32_t)(pattern_mask & (POSIF_HALPS_HCPS_Msk | POSIF_HALPS_HEPS_Msk));
 80218a8:	78fb      	ldrb	r3, [r7, #3]
 80218aa:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 80218ae:	687b      	ldr	r3, [r7, #4]
 80218b0:	635a      	str	r2, [r3, #52]	; 0x34
}
 80218b2:	bf00      	nop
 80218b4:	370c      	adds	r7, #12
 80218b6:	46bd      	mov	sp, r7
 80218b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80218bc:	4770      	bx	lr

080218be <XMC_POSIF_HSC_UpdateHallPattern>:
{
 80218be:	b480      	push	{r7}
 80218c0:	b083      	sub	sp, #12
 80218c2:	af00      	add	r7, sp, #0
 80218c4:	6078      	str	r0, [r7, #4]
  peripheral->MCMS = (uint32_t)POSIF_MCMS_STHR_Msk;
 80218c6:	687b      	ldr	r3, [r7, #4]
 80218c8:	2202      	movs	r2, #2
 80218ca:	649a      	str	r2, [r3, #72]	; 0x48
}
 80218cc:	bf00      	nop
 80218ce:	370c      	adds	r7, #12
 80218d0:	46bd      	mov	sp, r7
 80218d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80218d6:	4770      	bx	lr

080218d8 <XMC_POSIF_ClearEvent>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_POSIF_SetEvent() \n\n\n
 */
__STATIC_INLINE void XMC_POSIF_ClearEvent(XMC_POSIF_t *const peripheral, const XMC_POSIF_IRQ_EVENT_t event)
{
 80218d8:	b480      	push	{r7}
 80218da:	b083      	sub	sp, #12
 80218dc:	af00      	add	r7, sp, #0
 80218de:	6078      	str	r0, [r7, #4]
 80218e0:	460b      	mov	r3, r1
 80218e2:	70fb      	strb	r3, [r7, #3]
  peripheral->RPFLG = (uint32_t)1 << (uint8_t)event;
 80218e4:	78fb      	ldrb	r3, [r7, #3]
 80218e6:	2201      	movs	r2, #1
 80218e8:	409a      	lsls	r2, r3
 80218ea:	687b      	ldr	r3, [r7, #4]
 80218ec:	67da      	str	r2, [r3, #124]	; 0x7c
}
 80218ee:	bf00      	nop
 80218f0:	370c      	adds	r7, #12
 80218f2:	46bd      	mov	sp, r7
 80218f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80218f8:	4770      	bx	lr

080218fa <XMC_POSIF_GetEventStatus>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_POSIF_SetEvent(),XMC_POSIF_ClearEvent() \n\n\n
 */
__STATIC_INLINE uint8_t XMC_POSIF_GetEventStatus(XMC_POSIF_t *const peripheral, const XMC_POSIF_IRQ_EVENT_t event)
{
 80218fa:	b480      	push	{r7}
 80218fc:	b083      	sub	sp, #12
 80218fe:	af00      	add	r7, sp, #0
 8021900:	6078      	str	r0, [r7, #4]
 8021902:	460b      	mov	r3, r1
 8021904:	70fb      	strb	r3, [r7, #3]
  return ((uint8_t)((peripheral->PFLG >> (uint8_t)event) & 1U));
 8021906:	687b      	ldr	r3, [r7, #4]
 8021908:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 802190a:	78fb      	ldrb	r3, [r7, #3]
 802190c:	fa22 f303 	lsr.w	r3, r2, r3
 8021910:	b2db      	uxtb	r3, r3
 8021912:	f003 0301 	and.w	r3, r3, #1
 8021916:	b2db      	uxtb	r3, r3
}
 8021918:	4618      	mov	r0, r3
 802191a:	370c      	adds	r7, #12
 802191c:	46bd      	mov	sp, r7
 802191e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021922:	4770      	bx	lr

08021924 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>:
{
 8021924:	b580      	push	{r7, lr}
 8021926:	b082      	sub	sp, #8
 8021928:	af00      	add	r7, sp, #0
 802192a:	4603      	mov	r3, r0
 802192c:	71fb      	strb	r3, [r7, #7]
  XMC_POSIF_HSC_SetHallPatterns(MOTOR0_BLDC_SCALAR_POSIF_MODULE, pattern);
 802192e:	79fb      	ldrb	r3, [r7, #7]
 8021930:	4619      	mov	r1, r3
 8021932:	4803      	ldr	r0, [pc, #12]	; (8021940 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern+0x1c>)
 8021934:	f7ff ffb2 	bl	802189c <XMC_POSIF_HSC_SetHallPatterns>
}
 8021938:	bf00      	nop
 802193a:	3708      	adds	r7, #8
 802193c:	46bd      	mov	sp, r7
 802193e:	bd80      	pop	{r7, pc}
 8021940:	40028000 	.word	0x40028000

08021944 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern>:
{
 8021944:	b580      	push	{r7, lr}
 8021946:	af00      	add	r7, sp, #0
  XMC_POSIF_HSC_UpdateHallPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8021948:	4802      	ldr	r0, [pc, #8]	; (8021954 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern+0x10>)
 802194a:	f7ff ffb8 	bl	80218be <XMC_POSIF_HSC_UpdateHallPattern>
}
 802194e:	bf00      	nop
 8021950:	bd80      	pop	{r7, pc}
 8021952:	bf00      	nop
 8021954:	40028000 	.word	0x40028000

08021958 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern>:
{
 8021958:	b580      	push	{r7, lr}
 802195a:	b082      	sub	sp, #8
 802195c:	af00      	add	r7, sp, #0
  pattern = XMC_POSIF_HSC_GetExpectedPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 802195e:	4805      	ldr	r0, [pc, #20]	; (8021974 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern+0x1c>)
 8021960:	f7ff ff8b 	bl	802187a <XMC_POSIF_HSC_GetExpectedPattern>
 8021964:	4603      	mov	r3, r0
 8021966:	71fb      	strb	r3, [r7, #7]
  return(pattern);
 8021968:	79fb      	ldrb	r3, [r7, #7]
}
 802196a:	4618      	mov	r0, r3
 802196c:	3708      	adds	r7, #8
 802196e:	46bd      	mov	sp, r7
 8021970:	bd80      	pop	{r7, pc}
 8021972:	bf00      	nop
 8021974:	40028000 	.word	0x40028000

08021978 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallEventTime>:
{
 8021978:	b580      	push	{r7, lr}
 802197a:	b082      	sub	sp, #8
 802197c:	af00      	add	r7, sp, #0
  period = XMC_CCU4_SLICE_GetCaptureRegisterValue(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, BLDC_SCALAR_HALL_CAPTURE_REGITSER);
 802197e:	2103      	movs	r1, #3
 8021980:	4804      	ldr	r0, [pc, #16]	; (8021994 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallEventTime+0x1c>)
 8021982:	f003 fc32 	bl	80251ea <XMC_CCU4_SLICE_GetCaptureRegisterValue>
 8021986:	6078      	str	r0, [r7, #4]
  return(period);
 8021988:	687b      	ldr	r3, [r7, #4]
}
 802198a:	4618      	mov	r0, r3
 802198c:	3708      	adds	r7, #8
 802198e:	46bd      	mov	sp, r7
 8021990:	bd80      	pop	{r7, pc}
 8021992:	bf00      	nop
 8021994:	4000c200 	.word	0x4000c200

08021998 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>:
{
 8021998:	b580      	push	{r7, lr}
 802199a:	b082      	sub	sp, #8
 802199c:	af00      	add	r7, sp, #0
  hall_pattern = XMC_POSIF_HSC_GetLastSampledPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 802199e:	4805      	ldr	r0, [pc, #20]	; (80219b4 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern+0x1c>)
 80219a0:	f7ff ff58 	bl	8021854 <XMC_POSIF_HSC_GetLastSampledPattern>
 80219a4:	4603      	mov	r3, r0
 80219a6:	71fb      	strb	r3, [r7, #7]
  return(hall_pattern);
 80219a8:	79fb      	ldrb	r3, [r7, #7]
}
 80219aa:	4618      	mov	r0, r3
 80219ac:	3708      	adds	r7, #8
 80219ae:	46bd      	mov	sp, r7
 80219b0:	bd80      	pop	{r7, pc}
 80219b2:	bf00      	nop
 80219b4:	40028000 	.word	0x40028000

080219b8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler>:
 *
 * \par<b>Description</b><br>
 * Reset the capture timer prescaler value.\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler(void)
{
 80219b8:	b580      	push	{r7, lr}
 80219ba:	af00      	add	r7, sp, #0
  /*
   * Stop timer and prescalar.
   * initialize timer and prescalar value and restert the timer
   */
  XMC_CCU4_SLICE_StopTimer(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE);
 80219bc:	480a      	ldr	r0, [pc, #40]	; (80219e8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler+0x30>)
 80219be:	f7ff ff20 	bl	8021802 <XMC_CCU4_SLICE_StopTimer>
  XMC_CCU4_StopPrescaler(MOTOR0_BLDC_SCALAR_CCU4_MODULE);
 80219c2:	480a      	ldr	r0, [pc, #40]	; (80219ec <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler+0x34>)
 80219c4:	f7ff ff02 	bl	80217cc <XMC_CCU4_StopPrescaler>
  XMC_CCU4_SLICE_SetTimerValue(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, 0U);
 80219c8:	2100      	movs	r1, #0
 80219ca:	4807      	ldr	r0, [pc, #28]	; (80219e8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler+0x30>)
 80219cc:	f7ff ff33 	bl	8021836 <XMC_CCU4_SLICE_SetTimerValue>
  XMC_CCU4_SLICE_SetPrescaler(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, MOTOR0_BLDC_SCALAR_CCU4_PRESCALER);
 80219d0:	2105      	movs	r1, #5
 80219d2:	4805      	ldr	r0, [pc, #20]	; (80219e8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler+0x30>)
 80219d4:	f003 fc1b 	bl	802520e <XMC_CCU4_SLICE_SetPrescaler>
  XMC_CCU4_StartPrescaler(MOTOR0_BLDC_SCALAR_CCU4_MODULE);
 80219d8:	4804      	ldr	r0, [pc, #16]	; (80219ec <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler+0x34>)
 80219da:	f7ff fee9 	bl	80217b0 <XMC_CCU4_StartPrescaler>
  XMC_CCU4_SLICE_StartTimer(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE);
 80219de:	4802      	ldr	r0, [pc, #8]	; (80219e8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler+0x30>)
 80219e0:	f7ff ff02 	bl	80217e8 <XMC_CCU4_SLICE_StartTimer>
}
 80219e4:	bf00      	nop
 80219e6:	bd80      	pop	{r7, pc}
 80219e8:	4000c200 	.word	0x4000c200
 80219ec:	4000c000 	.word	0x4000c000

080219f0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetCapTimerVal>:
 *
 * \par<b>Description</b><br>
 * Return Hall event capture timer current value\n
 */
__STATIC_INLINE uint16_t Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetCapTimerVal(void)
{
 80219f0:	b580      	push	{r7, lr}
 80219f2:	b082      	sub	sp, #8
 80219f4:	af00      	add	r7, sp, #0
  uint16_t period;
  period = XMC_CCU4_SLICE_GetTimerValue(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE);
 80219f6:	4805      	ldr	r0, [pc, #20]	; (8021a0c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetCapTimerVal+0x1c>)
 80219f8:	f7ff ff10 	bl	802181c <XMC_CCU4_SLICE_GetTimerValue>
 80219fc:	4603      	mov	r3, r0
 80219fe:	80fb      	strh	r3, [r7, #6]
  return(period);
 8021a00:	88fb      	ldrh	r3, [r7, #6]
}
 8021a02:	4618      	mov	r0, r3
 8021a04:	3708      	adds	r7, #8
 8021a06:	46bd      	mov	sp, r7
 8021a08:	bd80      	pop	{r7, pc}
 8021a0a:	bf00      	nop
 8021a0c:	4000c200 	.word	0x4000c200

08021a10 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetEventStatus>:
 *
 * \par<b>Description</b><br>
 * Returns event status of peripheral. \n
 */
__STATIC_INLINE uint8_t Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetEventStatus(const XMC_POSIF_IRQ_EVENT_t event)
{
 8021a10:	b580      	push	{r7, lr}
 8021a12:	b082      	sub	sp, #8
 8021a14:	af00      	add	r7, sp, #0
 8021a16:	4603      	mov	r3, r0
 8021a18:	71fb      	strb	r3, [r7, #7]
  return XMC_POSIF_GetEventStatus(MOTOR0_BLDC_SCALAR_POSIF_MODULE, event);
 8021a1a:	79fb      	ldrb	r3, [r7, #7]
 8021a1c:	4619      	mov	r1, r3
 8021a1e:	4804      	ldr	r0, [pc, #16]	; (8021a30 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetEventStatus+0x20>)
 8021a20:	f7ff ff6b 	bl	80218fa <XMC_POSIF_GetEventStatus>
 8021a24:	4603      	mov	r3, r0
}
 8021a26:	4618      	mov	r0, r3
 8021a28:	3708      	adds	r7, #8
 8021a2a:	46bd      	mov	sp, r7
 8021a2c:	bd80      	pop	{r7, pc}
 8021a2e:	bf00      	nop
 8021a30:	40028000 	.word	0x40028000

08021a34 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearEvent>:
 *
 * \par<b>Description</b><br>
 * Clears event by acknowledgment of peripheral. \n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearEvent(const XMC_POSIF_IRQ_EVENT_t event)
{
 8021a34:	b580      	push	{r7, lr}
 8021a36:	b082      	sub	sp, #8
 8021a38:	af00      	add	r7, sp, #0
 8021a3a:	4603      	mov	r3, r0
 8021a3c:	71fb      	strb	r3, [r7, #7]
  XMC_POSIF_ClearEvent(MOTOR0_BLDC_SCALAR_POSIF_MODULE, event);
 8021a3e:	79fb      	ldrb	r3, [r7, #7]
 8021a40:	4619      	mov	r1, r3
 8021a42:	4803      	ldr	r0, [pc, #12]	; (8021a50 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearEvent+0x1c>)
 8021a44:	f7ff ff48 	bl	80218d8 <XMC_POSIF_ClearEvent>
}
 8021a48:	bf00      	nop
 8021a4a:	3708      	adds	r7, #8
 8021a4c:	46bd      	mov	sp, r7
 8021a4e:	bd80      	pop	{r7, pc}
 8021a50:	40028000 	.word	0x40028000

08021a54 <Motor0_BLDC_SCALAR_WrongHallEvent>:
 * Restart capture timer and calculate the speed.
 *
 * if hall failure, stop the motor and change the state to ERROR.
 */
static void Motor0_BLDC_SCALAR_WrongHallEvent(void)
{
 8021a54:	b580      	push	{r7, lr}
 8021a56:	b088      	sub	sp, #32
 8021a58:	af00      	add	r7, sp, #0
  uint8_t sampled_pat;      /* Sampled hall pattern */
  uint8_t reverse_pat;      /* Expected reverse direction pattern based on last sample pattern */
  uint8_t correct_pat;      /* Expected correct direction pattern based on last sample pattern */

  /* 0: positive direction, 8: negative direction to access the pattern table */
  uint8_t direction = (uint8_t) Motor0_BLDC_SCALAR.motor_set_direction & BLDC_SCALAR_HALL_MOTOR_DIR_INDEX;  /* intended direction */
 8021a5a:	4b59      	ldr	r3, [pc, #356]	; (8021bc0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021a5c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8021a5e:	b2db      	uxtb	r3, r3
 8021a60:	f003 0308 	and.w	r3, r3, #8
 8021a64:	77fb      	strb	r3, [r7, #31]
  int32_t temp_dir  = (-Motor0_BLDC_SCALAR.motor_set_direction);
 8021a66:	4b56      	ldr	r3, [pc, #344]	; (8021bc0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021a68:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8021a6a:	425b      	negs	r3, r3
 8021a6c:	61bb      	str	r3, [r7, #24]
  uint8_t rev_direction = ((uint8_t)(temp_dir) & BLDC_SCALAR_HALL_MOTOR_DIR_INDEX);    /* reverse direction */
 8021a6e:	69bb      	ldr	r3, [r7, #24]
 8021a70:	b2db      	uxtb	r3, r3
 8021a72:	f003 0308 	and.w	r3, r3, #8
 8021a76:	75fb      	strb	r3, [r7, #23]
#if (MOTOR0_BLDC_SCALAR_ENABLE_CATCH_FREE == 1U)
  uint8_t pos;           /* array index variable */
#endif
  uint32_t speed = 0U;     /* electrical speed in RPM */
 8021a78:	2300      	movs	r3, #0
 8021a7a:	607b      	str	r3, [r7, #4]
  uint32_t capval;         /* Calculated time between two hall events */

#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U)
#if (MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING == 1U)
  /* To blank the direct DC link current measurement at the commutation point */
  Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_enable = 1U;
 8021a7c:	4b51      	ldr	r3, [pc, #324]	; (8021bc4 <Motor0_BLDC_SCALAR_WrongHallEvent+0x170>)
 8021a7e:	2201      	movs	r2, #1
 8021a80:	f883 2020 	strb.w	r2, [r3, #32]
#if (MOTOR0_BLDC_SCALAR_ENABLE_STALL_DETECTION == 1U)
  /* Reset the stall detection count as hall event is detected for timeout*/
  Motor0_BLDC_SCALAR.stall_detection_counter = 0U;
#endif
  /*Get the sampled hall pattern*/
  sampled_pat = (uint8_t)Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern();
 8021a84:	f7ff ff88 	bl	8021998 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>
 8021a88:	4603      	mov	r3, r0
 8021a8a:	75bb      	strb	r3, [r7, #22]
  reverse_pat = (Motor0_BLDC_SCALAR_Hall.hall_pattern[Motor0_BLDC_SCALAR_Hall.prev_hall_pos + rev_direction] >> BLDC_SCALAR_HALL_PATTERN_POS);
 8021a8c:	4b4e      	ldr	r3, [pc, #312]	; (8021bc8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x174>)
 8021a8e:	7c5b      	ldrb	r3, [r3, #17]
 8021a90:	461a      	mov	r2, r3
 8021a92:	7dfb      	ldrb	r3, [r7, #23]
 8021a94:	4413      	add	r3, r2
 8021a96:	4a4c      	ldr	r2, [pc, #304]	; (8021bc8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x174>)
 8021a98:	5cd3      	ldrb	r3, [r2, r3]
 8021a9a:	08db      	lsrs	r3, r3, #3
 8021a9c:	757b      	strb	r3, [r7, #21]
  correct_pat = (Motor0_BLDC_SCALAR_Hall.hall_pattern[Motor0_BLDC_SCALAR_Hall.prev_hall_pos + direction] >> BLDC_SCALAR_HALL_PATTERN_POS);
 8021a9e:	4b4a      	ldr	r3, [pc, #296]	; (8021bc8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x174>)
 8021aa0:	7c5b      	ldrb	r3, [r3, #17]
 8021aa2:	461a      	mov	r2, r3
 8021aa4:	7ffb      	ldrb	r3, [r7, #31]
 8021aa6:	4413      	add	r3, r2
 8021aa8:	4a47      	ldr	r2, [pc, #284]	; (8021bc8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x174>)
 8021aaa:	5cd3      	ldrb	r3, [r2, r3]
 8021aac:	08db      	lsrs	r3, r3, #3
 8021aae:	753b      	strb	r3, [r7, #20]

  /* Check if the pattern matches the correct or reverse hall pattern */
  if (( reverse_pat == sampled_pat) || ( correct_pat == sampled_pat))
 8021ab0:	7d7a      	ldrb	r2, [r7, #21]
 8021ab2:	7dbb      	ldrb	r3, [r7, #22]
 8021ab4:	429a      	cmp	r2, r3
 8021ab6:	d003      	beq.n	8021ac0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x6c>
 8021ab8:	7d3a      	ldrb	r2, [r7, #20]
 8021aba:	7dbb      	ldrb	r3, [r7, #22]
 8021abc:	429a      	cmp	r2, r3
 8021abe:	d16b      	bne.n	8021b98 <Motor0_BLDC_SCALAR_WrongHallEvent+0x144>
  {
    /* Reverse hall event detected */

#if (MOTOR0_BLDC_SCALAR_ENABLE_CATCH_FREE == 1U)
    /* BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION  - to get the direction of freely running motor */
    if ((Motor0_BLDC_SCALAR_HALL_CatchFree.state_identification_done == 0U) &&
 8021ac0:	4b42      	ldr	r3, [pc, #264]	; (8021bcc <Motor0_BLDC_SCALAR_WrongHallEvent+0x178>)
 8021ac2:	781b      	ldrb	r3, [r3, #0]
 8021ac4:	2b00      	cmp	r3, #0
 8021ac6:	d12a      	bne.n	8021b1e <Motor0_BLDC_SCALAR_WrongHallEvent+0xca>
          (Motor0_BLDC_SCALAR.msm_state == BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION))
 8021ac8:	4b3d      	ldr	r3, [pc, #244]	; (8021bc0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021aca:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 8021ace:	b2db      	uxtb	r3, r3
    if ((Motor0_BLDC_SCALAR_HALL_CatchFree.state_identification_done == 0U) &&
 8021ad0:	2b02      	cmp	r3, #2
 8021ad2:	d124      	bne.n	8021b1e <Motor0_BLDC_SCALAR_WrongHallEvent+0xca>
    {
      /* Find the direction of rotation if motor is already running */
      Motor0_BLDC_SCALAR_HALL_CatchFree.identified_direction = (int32_t) (Motor0_BLDC_SCALAR.motor_set_direction * -1);
 8021ad4:	4b3a      	ldr	r3, [pc, #232]	; (8021bc0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021ad6:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8021ad8:	425b      	negs	r3, r3
 8021ada:	4a3c      	ldr	r2, [pc, #240]	; (8021bcc <Motor0_BLDC_SCALAR_WrongHallEvent+0x178>)
 8021adc:	60d3      	str	r3, [r2, #12]
      direction = (uint8_t) Motor0_BLDC_SCALAR_HALL_CatchFree.identified_direction & BLDC_SCALAR_HALL_MOTOR_DIR_INDEX;
 8021ade:	4b3b      	ldr	r3, [pc, #236]	; (8021bcc <Motor0_BLDC_SCALAR_WrongHallEvent+0x178>)
 8021ae0:	68db      	ldr	r3, [r3, #12]
 8021ae2:	b2db      	uxtb	r3, r3
 8021ae4:	f003 0308 	and.w	r3, r3, #8
 8021ae8:	77fb      	strb	r3, [r7, #31]
      Motor0_BLDC_SCALAR_HALL_CatchFree.dir_acquired = 1U;
 8021aea:	4b38      	ldr	r3, [pc, #224]	; (8021bcc <Motor0_BLDC_SCALAR_WrongHallEvent+0x178>)
 8021aec:	2201      	movs	r2, #1
 8021aee:	741a      	strb	r2, [r3, #16]

      /* Update the hall pattern in shadow register and perform immediate transfer */
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
          (uint8_t) (Motor0_BLDC_SCALAR_Hall.hall_pattern[((uint8_t) sampled_pat + (uint32_t) direction)]));
 8021af0:	7dba      	ldrb	r2, [r7, #22]
 8021af2:	7ffb      	ldrb	r3, [r7, #31]
 8021af4:	4413      	add	r3, r2
 8021af6:	4a34      	ldr	r2, [pc, #208]	; (8021bc8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x174>)
 8021af8:	5cd3      	ldrb	r3, [r2, r3]
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
 8021afa:	4618      	mov	r0, r3
 8021afc:	f7ff ff12 	bl	8021924 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern();
 8021b00:	f7ff ff20 	bl	8021944 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern>
      pos =  Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern();
 8021b04:	f7ff ff28 	bl	8021958 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern>
 8021b08:	4603      	mov	r3, r0
 8021b0a:	74fb      	strb	r3, [r7, #19]
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
          (uint8_t) (Motor0_BLDC_SCALAR_Hall.hall_pattern[(uint8_t) pos + (uint32_t) direction]));
 8021b0c:	7cfa      	ldrb	r2, [r7, #19]
 8021b0e:	7ffb      	ldrb	r3, [r7, #31]
 8021b10:	4413      	add	r3, r2
 8021b12:	4a2d      	ldr	r2, [pc, #180]	; (8021bc8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x174>)
 8021b14:	5cd3      	ldrb	r3, [r2, r3]
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
 8021b16:	4618      	mov	r0, r3
 8021b18:	f7ff ff04 	bl	8021924 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>
 8021b1c:	e035      	b.n	8021b8a <Motor0_BLDC_SCALAR_WrongHallEvent+0x136>
    /* Apply hall pattern and multi-channel pattern for intended direction */
    else
    {
#endif
      /* Update actual motor direction */
      Motor0_BLDC_SCALAR.actual_motor_direction = (-Motor0_BLDC_SCALAR.motor_set_direction);
 8021b1e:	4b28      	ldr	r3, [pc, #160]	; (8021bc0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021b20:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8021b22:	425b      	negs	r3, r3
 8021b24:	4a26      	ldr	r2, [pc, #152]	; (8021bc0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021b26:	67d3      	str	r3, [r2, #124]	; 0x7c

      Motor0_BLDC_SCALAR_PatternInitiator(sampled_pat);
 8021b28:	7dbb      	ldrb	r3, [r7, #22]
 8021b2a:	4618      	mov	r0, r3
 8021b2c:	f006 fc34 	bl	8028398 <__Motor0_BLDC_SCALAR_PatternInitiator_veneer>

      /* Restart the capture slice which is used for speed calculation */
      timer = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetCapTimerVal();
 8021b30:	f7ff ff5e 	bl	80219f0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetCapTimerVal>
 8021b34:	4603      	mov	r3, r0
 8021b36:	823b      	strh	r3, [r7, #16]
      curr_psc = ((uint32_t)((uint32_t)MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE->FPC & (uint32_t)CCU4_CC4_FPC_PVAL_Msk) >> (uint32_t)CCU4_CC4_FPC_PVAL_Pos);
 8021b38:	4b25      	ldr	r3, [pc, #148]	; (8021bd0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x17c>)
 8021b3a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8021b3c:	0a1b      	lsrs	r3, r3, #8
 8021b3e:	f003 030f 	and.w	r3, r3, #15
 8021b42:	60fb      	str	r3, [r7, #12]

      /* Stop timer and prescaler and restart with reset values*/
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler();
 8021b44:	f7ff ff38 	bl	80219b8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ResetCaptureTimePrescaler>

      /* speed calculation */
      capval = BLDC_SCALAR_SPEED_POS_HALL_Cap_Array[(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)] +
 8021b48:	68fb      	ldr	r3, [r7, #12]
 8021b4a:	3b05      	subs	r3, #5
 8021b4c:	4a21      	ldr	r2, [pc, #132]	; (8021bd4 <Motor0_BLDC_SCALAR_WrongHallEvent+0x180>)
 8021b4e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
               (((uint32_t)1 << (uint32_t)(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)) * timer);
 8021b52:	8a39      	ldrh	r1, [r7, #16]
 8021b54:	68fb      	ldr	r3, [r7, #12]
 8021b56:	3b05      	subs	r3, #5
 8021b58:	fa01 f303 	lsl.w	r3, r1, r3
      capval = BLDC_SCALAR_SPEED_POS_HALL_Cap_Array[(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)] +
 8021b5c:	4413      	add	r3, r2
 8021b5e:	60bb      	str	r3, [r7, #8]
      Motor0_BLDC_SCALAR_SPEED_POS_HALL.capval = capval;
 8021b60:	4a1d      	ldr	r2, [pc, #116]	; (8021bd8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x184>)
 8021b62:	68bb      	ldr	r3, [r7, #8]
 8021b64:	6193      	str	r3, [r2, #24]
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation(capval, &speed);
 8021b66:	1d3b      	adds	r3, r7, #4
 8021b68:	4619      	mov	r1, r3
 8021b6a:	68b8      	ldr	r0, [r7, #8]
 8021b6c:	f006 fc10 	bl	8028390 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation_veneer>
      Motor0_BLDC_SCALAR.motor_speed = (((int32_t)speed * Motor0_BLDC_SCALAR.actual_motor_direction *
 8021b70:	4b13      	ldr	r3, [pc, #76]	; (8021bc0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021b72:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8021b74:	687a      	ldr	r2, [r7, #4]
 8021b76:	fb02 f303 	mul.w	r3, r2, r3
                                       (int32_t)Motor0_BLDC_SCALAR.speed_mech_scale) >> BLDC_SCALAR_SPEED_SCALE_RES);
 8021b7a:	4a11      	ldr	r2, [pc, #68]	; (8021bc0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021b7c:	f8d2 20bc 	ldr.w	r2, [r2, #188]	; 0xbc
      Motor0_BLDC_SCALAR.motor_speed = (((int32_t)speed * Motor0_BLDC_SCALAR.actual_motor_direction *
 8021b80:	fb02 f303 	mul.w	r3, r2, r3
                                       (int32_t)Motor0_BLDC_SCALAR.speed_mech_scale) >> BLDC_SCALAR_SPEED_SCALE_RES);
 8021b84:	129b      	asrs	r3, r3, #10
      Motor0_BLDC_SCALAR.motor_speed = (((int32_t)speed * Motor0_BLDC_SCALAR.actual_motor_direction *
 8021b86:	4a0e      	ldr	r2, [pc, #56]	; (8021bc0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021b88:	66d3      	str	r3, [r2, #108]	; 0x6c
#if (MOTOR0_BLDC_SCALAR_ENABLE_CATCH_FREE == 1U)
    }
#endif
    Motor0_BLDC_SCALAR_Hall.prev_hall_pos = (uint8_t)Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern();
 8021b8a:	f7ff ff05 	bl	8021998 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>
 8021b8e:	4603      	mov	r3, r0
 8021b90:	461a      	mov	r2, r3
 8021b92:	4b0d      	ldr	r3, [pc, #52]	; (8021bc8 <Motor0_BLDC_SCALAR_WrongHallEvent+0x174>)
 8021b94:	745a      	strb	r2, [r3, #17]
 8021b96:	e00b      	b.n	8021bb0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x15c>

  /* Hall failure - sampled hall pattern does not match with either direction pattern */
  else
  {
    /* wrong hall event */
    Motor0_BLDC_SCALAR.error_status |= (uint32_t)1 << (uint32_t)BLDC_SCALAR_EID_WRONGHALL;
 8021b98:	4b09      	ldr	r3, [pc, #36]	; (8021bc0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021b9a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8021b9c:	f043 0308 	orr.w	r3, r3, #8
 8021ba0:	4a07      	ldr	r2, [pc, #28]	; (8021bc0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021ba2:	6693      	str	r3, [r2, #104]	; 0x68
    Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_ERROR;
 8021ba4:	4b06      	ldr	r3, [pc, #24]	; (8021bc0 <Motor0_BLDC_SCALAR_WrongHallEvent+0x16c>)
 8021ba6:	2208      	movs	r2, #8
 8021ba8:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
    Motor0_BLDC_SCALAR_MotorStop();
 8021bac:	f000 fed6 	bl	802295c <Motor0_BLDC_SCALAR_MotorStop>
  }
  /* clear wrong hall event */
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearEvent(XMC_POSIF_IRQ_EVENT_WHE);
 8021bb0:	2001      	movs	r0, #1
 8021bb2:	f7ff ff3f 	bl	8021a34 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearEvent>
}
 8021bb6:	bf00      	nop
 8021bb8:	3720      	adds	r7, #32
 8021bba:	46bd      	mov	sp, r7
 8021bbc:	bd80      	pop	{r7, pc}
 8021bbe:	bf00      	nop
 8021bc0:	1ffe9350 	.word	0x1ffe9350
 8021bc4:	1ffe92e8 	.word	0x1ffe92e8
 8021bc8:	1ffe931c 	.word	0x1ffe931c
 8021bcc:	1ffe9330 	.word	0x1ffe9330
 8021bd0:	4000c200 	.word	0x4000c200
 8021bd4:	1ffe91c0 	.word	0x1ffe91c0
 8021bd8:	1ffe92bc 	.word	0x1ffe92bc

08021bdc <Motor0_BLDC_SCALAR_CorrectHallEvent>:
/*
 * Find the direction of the motor in free running condition.
 * This event is disabled once control is switched to closed loop.
 */
static void Motor0_BLDC_SCALAR_CorrectHallEvent(void)
{
 8021bdc:	b580      	push	{r7, lr}
 8021bde:	b086      	sub	sp, #24
 8021be0:	af00      	add	r7, sp, #0
  /* 0: positive direction, 8: negative direction to access the pattern table */
  uint8_t direction = (uint8_t) Motor0_BLDC_SCALAR.motor_set_direction & BLDC_SCALAR_HALL_MOTOR_DIR_INDEX;  /* intended direction */
 8021be2:	4b34      	ldr	r3, [pc, #208]	; (8021cb4 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xd8>)
 8021be4:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8021be6:	b2db      	uxtb	r3, r3
 8021be8:	f003 0308 	and.w	r3, r3, #8
 8021bec:	75fb      	strb	r3, [r7, #23]
  uint8_t pos;          /* Array index variable */
  uint32_t capture_reg;   /* capture register value */
  uint32_t curr_psc;      /* Prescaler value */

  /* Speed is calculated based on last two hall events */
  Motor0_BLDC_SCALAR_HALL_CatchFree.sample_capture_counter++;
 8021bee:	4b32      	ldr	r3, [pc, #200]	; (8021cb8 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021bf0:	695b      	ldr	r3, [r3, #20]
 8021bf2:	3301      	adds	r3, #1
 8021bf4:	4a30      	ldr	r2, [pc, #192]	; (8021cb8 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021bf6:	6153      	str	r3, [r2, #20]
  Motor0_BLDC_SCALAR_HALL_CatchFree.catch_free_wait_counter = 0U;
 8021bf8:	4b2f      	ldr	r3, [pc, #188]	; (8021cb8 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021bfa:	2200      	movs	r2, #0
 8021bfc:	609a      	str	r2, [r3, #8]
   * if correct hall event is the first event after the state machine has started,
   * identified direction is the intended direction.
   * If wrong hall event is the first event after the state machine has started,
   * identified direction is the reverse direction.
   */
  if ((Motor0_BLDC_SCALAR_HALL_CatchFree.sample_capture_counter == 1U) && (Motor0_BLDC_SCALAR_HALL_CatchFree.dir_acquired == 0U))
 8021bfe:	4b2e      	ldr	r3, [pc, #184]	; (8021cb8 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c00:	695b      	ldr	r3, [r3, #20]
 8021c02:	2b01      	cmp	r3, #1
 8021c04:	d10a      	bne.n	8021c1c <Motor0_BLDC_SCALAR_CorrectHallEvent+0x40>
 8021c06:	4b2c      	ldr	r3, [pc, #176]	; (8021cb8 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c08:	7c1b      	ldrb	r3, [r3, #16]
 8021c0a:	2b00      	cmp	r3, #0
 8021c0c:	d106      	bne.n	8021c1c <Motor0_BLDC_SCALAR_CorrectHallEvent+0x40>
  {
    Motor0_BLDC_SCALAR_HALL_CatchFree.identified_direction = (int32_t) Motor0_BLDC_SCALAR.motor_set_direction;
 8021c0e:	4b29      	ldr	r3, [pc, #164]	; (8021cb4 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xd8>)
 8021c10:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8021c12:	4a29      	ldr	r2, [pc, #164]	; (8021cb8 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c14:	60d3      	str	r3, [r2, #12]
    Motor0_BLDC_SCALAR_HALL_CatchFree.dir_acquired = 1U;
 8021c16:	4b28      	ldr	r3, [pc, #160]	; (8021cb8 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c18:	2201      	movs	r2, #1
 8021c1a:	741a      	strb	r2, [r3, #16]
  }

  direction = (uint8_t) Motor0_BLDC_SCALAR_HALL_CatchFree.identified_direction & BLDC_SCALAR_HALL_MOTOR_DIR_INDEX;
 8021c1c:	4b26      	ldr	r3, [pc, #152]	; (8021cb8 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c1e:	68db      	ldr	r3, [r3, #12]
 8021c20:	b2db      	uxtb	r3, r3
 8021c22:	f003 0308 	and.w	r3, r3, #8
 8021c26:	75fb      	strb	r3, [r7, #23]

  /* Read the captured value */
  capture_reg = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallEventTime();
 8021c28:	f7ff fea6 	bl	8021978 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallEventTime>
 8021c2c:	6138      	str	r0, [r7, #16]
  if ((Motor0_BLDC_SCALAR_HALL_CatchFree.sample_capture_counter > 1U) && (Motor0_BLDC_SCALAR_HALL_CatchFree.state_identification_done == 0U))
 8021c2e:	4b22      	ldr	r3, [pc, #136]	; (8021cb8 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c30:	695b      	ldr	r3, [r3, #20]
 8021c32:	2b01      	cmp	r3, #1
 8021c34:	d925      	bls.n	8021c82 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xa6>
 8021c36:	4b20      	ldr	r3, [pc, #128]	; (8021cb8 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c38:	781b      	ldrb	r3, [r3, #0]
 8021c3a:	2b00      	cmp	r3, #0
 8021c3c:	d121      	bne.n	8021c82 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xa6>
  {
    capture_reg = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallEventTime();
 8021c3e:	f7ff fe9b 	bl	8021978 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallEventTime>
 8021c42:	6138      	str	r0, [r7, #16]

    capval = (capture_reg & (uint32_t) BLDC_SCALAR_HALL_CAPTURE_MASK);
 8021c44:	693b      	ldr	r3, [r7, #16]
 8021c46:	b29b      	uxth	r3, r3
 8021c48:	60fb      	str	r3, [r7, #12]
    curr_psc = (capture_reg & BLDC_SCALAR_HALL_CAPTURE_PRESCALAR_MASK) >> BLDC_SCALAR_HALL_CAPTURE_PRESCALAR_POS;
 8021c4a:	693b      	ldr	r3, [r7, #16]
 8021c4c:	0c1b      	lsrs	r3, r3, #16
 8021c4e:	f003 030f 	and.w	r3, r3, #15
 8021c52:	60bb      	str	r3, [r7, #8]
    Motor0_BLDC_SCALAR_HALL_CatchFree.cf_capval += BLDC_SCALAR_SPEED_POS_HALL_Cap_Array[(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)]
 8021c54:	4b18      	ldr	r3, [pc, #96]	; (8021cb8 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c56:	685a      	ldr	r2, [r3, #4]
 8021c58:	68bb      	ldr	r3, [r7, #8]
 8021c5a:	3b05      	subs	r3, #5
 8021c5c:	4917      	ldr	r1, [pc, #92]	; (8021cbc <Motor0_BLDC_SCALAR_CorrectHallEvent+0xe0>)
 8021c5e:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
                                                   + (((uint32_t)1 << (uint32_t)(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)) * capval);
 8021c62:	68bb      	ldr	r3, [r7, #8]
 8021c64:	3b05      	subs	r3, #5
 8021c66:	68f8      	ldr	r0, [r7, #12]
 8021c68:	fa00 f303 	lsl.w	r3, r0, r3
 8021c6c:	440b      	add	r3, r1
    Motor0_BLDC_SCALAR_HALL_CatchFree.cf_capval += BLDC_SCALAR_SPEED_POS_HALL_Cap_Array[(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)]
 8021c6e:	4413      	add	r3, r2
 8021c70:	4a11      	ldr	r2, [pc, #68]	; (8021cb8 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c72:	6053      	str	r3, [r2, #4]

    /*
     * STATE_IDENTIFICATION state execution needs three correct hall events. First
     * event is ignored and speed is calculated based on last two events
     */
    if (Motor0_BLDC_SCALAR_HALL_CatchFree.sample_capture_counter == BLDC_SCALAR_HALL_CAPTURE_COUNTER)
 8021c74:	4b10      	ldr	r3, [pc, #64]	; (8021cb8 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c76:	695b      	ldr	r3, [r3, #20]
 8021c78:	2b03      	cmp	r3, #3
 8021c7a:	d102      	bne.n	8021c82 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xa6>
    {
      Motor0_BLDC_SCALAR_HALL_CatchFree.state_identification_done = 1U;
 8021c7c:	4b0e      	ldr	r3, [pc, #56]	; (8021cb8 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xdc>)
 8021c7e:	2201      	movs	r2, #1
 8021c80:	701a      	strb	r2, [r3, #0]
    }
  }
  Motor0_BLDC_SCALAR_Hall.prev_hall_pos = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern();
 8021c82:	f7ff fe89 	bl	8021998 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>
 8021c86:	4603      	mov	r3, r0
 8021c88:	461a      	mov	r2, r3
 8021c8a:	4b0d      	ldr	r3, [pc, #52]	; (8021cc0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xe4>)
 8021c8c:	745a      	strb	r2, [r3, #17]
  pos = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern();
 8021c8e:	f7ff fe63 	bl	8021958 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern>
 8021c92:	4603      	mov	r3, r0
 8021c94:	71fb      	strb	r3, [r7, #7]

  /* next hall pattern in hall shadow register*/
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
      (uint8_t) (Motor0_BLDC_SCALAR_Hall.hall_pattern[(uint8_t) pos + (uint32_t) direction]));
 8021c96:	79fa      	ldrb	r2, [r7, #7]
 8021c98:	7dfb      	ldrb	r3, [r7, #23]
 8021c9a:	4413      	add	r3, r2
 8021c9c:	4a08      	ldr	r2, [pc, #32]	; (8021cc0 <Motor0_BLDC_SCALAR_CorrectHallEvent+0xe4>)
 8021c9e:	5cd3      	ldrb	r3, [r2, r3]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
 8021ca0:	4618      	mov	r0, r3
 8021ca2:	f7ff fe3f 	bl	8021924 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>

  /* clear correct hall event */
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearEvent(XMC_POSIF_IRQ_EVENT_CHE);
 8021ca6:	2000      	movs	r0, #0
 8021ca8:	f7ff fec4 	bl	8021a34 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearEvent>
}
 8021cac:	bf00      	nop
 8021cae:	3718      	adds	r7, #24
 8021cb0:	46bd      	mov	sp, r7
 8021cb2:	bd80      	pop	{r7, pc}
 8021cb4:	1ffe9350 	.word	0x1ffe9350
 8021cb8:	1ffe9330 	.word	0x1ffe9330
 8021cbc:	1ffe91c0 	.word	0x1ffe91c0
 8021cc0:	1ffe931c 	.word	0x1ffe931c

08021cc4 <XMC_POSIF_HSC_GetLastSampledPattern>:
{
 8021cc4:	b480      	push	{r7}
 8021cc6:	b083      	sub	sp, #12
 8021cc8:	af00      	add	r7, sp, #0
 8021cca:	6078      	str	r0, [r7, #4]
  return ((uint8_t)((peripheral->PDBG) & POSIF_PDBG_HSP_Msk) >> POSIF_PDBG_HSP_Pos);
 8021ccc:	687b      	ldr	r3, [r7, #4]
 8021cce:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8021cd2:	b2db      	uxtb	r3, r3
 8021cd4:	115b      	asrs	r3, r3, #5
 8021cd6:	b2db      	uxtb	r3, r3
 8021cd8:	f003 0307 	and.w	r3, r3, #7
 8021cdc:	b2db      	uxtb	r3, r3
}
 8021cde:	4618      	mov	r0, r3
 8021ce0:	370c      	adds	r7, #12
 8021ce2:	46bd      	mov	sp, r7
 8021ce4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021ce8:	4770      	bx	lr

08021cea <XMC_POSIF_HSC_GetExpectedPattern>:
{
 8021cea:	b480      	push	{r7}
 8021cec:	b083      	sub	sp, #12
 8021cee:	af00      	add	r7, sp, #0
 8021cf0:	6078      	str	r0, [r7, #4]
  return ((uint8_t)((peripheral->HALP & POSIF_HALP_HEP_Msk) >> POSIF_HALP_HEP_Pos));
 8021cf2:	687b      	ldr	r3, [r7, #4]
 8021cf4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8021cf6:	08db      	lsrs	r3, r3, #3
 8021cf8:	b2db      	uxtb	r3, r3
 8021cfa:	f003 0307 	and.w	r3, r3, #7
 8021cfe:	b2db      	uxtb	r3, r3
}
 8021d00:	4618      	mov	r0, r3
 8021d02:	370c      	adds	r7, #12
 8021d04:	46bd      	mov	sp, r7
 8021d06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d0a:	4770      	bx	lr

08021d0c <XMC_POSIF_HSC_SetHallPatterns>:
{
 8021d0c:	b480      	push	{r7}
 8021d0e:	b083      	sub	sp, #12
 8021d10:	af00      	add	r7, sp, #0
 8021d12:	6078      	str	r0, [r7, #4]
 8021d14:	460b      	mov	r3, r1
 8021d16:	70fb      	strb	r3, [r7, #3]
  peripheral->HALPS = (uint32_t)(pattern_mask & (POSIF_HALPS_HCPS_Msk | POSIF_HALPS_HEPS_Msk));
 8021d18:	78fb      	ldrb	r3, [r7, #3]
 8021d1a:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 8021d1e:	687b      	ldr	r3, [r7, #4]
 8021d20:	635a      	str	r2, [r3, #52]	; 0x34
}
 8021d22:	bf00      	nop
 8021d24:	370c      	adds	r7, #12
 8021d26:	46bd      	mov	sp, r7
 8021d28:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d2c:	4770      	bx	lr

08021d2e <XMC_POSIF_MCM_SetMultiChannelPattern>:
{
 8021d2e:	b480      	push	{r7}
 8021d30:	b083      	sub	sp, #12
 8021d32:	af00      	add	r7, sp, #0
 8021d34:	6078      	str	r0, [r7, #4]
 8021d36:	460b      	mov	r3, r1
 8021d38:	807b      	strh	r3, [r7, #2]
  peripheral->MCSM = pattern;
 8021d3a:	887a      	ldrh	r2, [r7, #2]
 8021d3c:	687b      	ldr	r3, [r7, #4]
 8021d3e:	645a      	str	r2, [r3, #68]	; 0x44
}
 8021d40:	bf00      	nop
 8021d42:	370c      	adds	r7, #12
 8021d44:	46bd      	mov	sp, r7
 8021d46:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d4a:	4770      	bx	lr

08021d4c <XMC_POSIF_MCM_GetMultiChannelPattern>:
{
 8021d4c:	b480      	push	{r7}
 8021d4e:	b083      	sub	sp, #12
 8021d50:	af00      	add	r7, sp, #0
 8021d52:	6078      	str	r0, [r7, #4]
  return ((uint16_t)(peripheral->MCM & (uint32_t)POSIF_MCM_MCMP_Msk));
 8021d54:	687b      	ldr	r3, [r7, #4]
 8021d56:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8021d58:	b29b      	uxth	r3, r3
}
 8021d5a:	4618      	mov	r0, r3
 8021d5c:	370c      	adds	r7, #12
 8021d5e:	46bd      	mov	sp, r7
 8021d60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d64:	4770      	bx	lr

08021d66 <XMC_POSIF_MCM_GetShadowMultiChannelPattern>:
{
 8021d66:	b480      	push	{r7}
 8021d68:	b083      	sub	sp, #12
 8021d6a:	af00      	add	r7, sp, #0
 8021d6c:	6078      	str	r0, [r7, #4]
  return ((uint16_t)(peripheral->MCSM & (uint32_t)POSIF_MCSM_MCMPS_Msk));
 8021d6e:	687b      	ldr	r3, [r7, #4]
 8021d70:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8021d72:	b29b      	uxth	r3, r3
}
 8021d74:	4618      	mov	r0, r3
 8021d76:	370c      	adds	r7, #12
 8021d78:	46bd      	mov	sp, r7
 8021d7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d7e:	4770      	bx	lr

08021d80 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue>:
{
 8021d80:	b580      	push	{r7, lr}
 8021d82:	b086      	sub	sp, #24
 8021d84:	af00      	add	r7, sp, #0
 8021d86:	6078      	str	r0, [r7, #4]
  BLDC_SCALAR_SPEED_POS_HALL_STATUS_t status = BLDC_SCALAR_SPEED_POS_HALL_STATUS_FAILURE;  /* return status */
 8021d88:	2301      	movs	r3, #1
 8021d8a:	75fb      	strb	r3, [r7, #23]
  temp_capval = (uint32_t)XMC_CCU4_SLICE_GetCaptureRegisterValue(MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE, BLDC_SCALAR_HALL_CAPTURE_REGITSER);
 8021d8c:	2103      	movs	r1, #3
 8021d8e:	4816      	ldr	r0, [pc, #88]	; (8021de8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue+0x68>)
 8021d90:	f003 fa2b 	bl	80251ea <XMC_CCU4_SLICE_GetCaptureRegisterValue>
 8021d94:	6138      	str	r0, [r7, #16]
  if (((temp_capval & (uint32_t)CCU4_CC4_CV_FFL_Msk) >> CCU4_CC4_CV_FFL_Pos) == 1U)
 8021d96:	693b      	ldr	r3, [r7, #16]
 8021d98:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8021d9c:	2b00      	cmp	r3, #0
 8021d9e:	d01b      	beq.n	8021dd8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue+0x58>
    curr_psc = ((temp_capval & (uint32_t)CCU4_CC4_CV_FPCV_Msk) >> (uint32_t)CCU4_CC4_CV_FPCV_Pos);
 8021da0:	693b      	ldr	r3, [r7, #16]
 8021da2:	0c1b      	lsrs	r3, r3, #16
 8021da4:	f003 030f 	and.w	r3, r3, #15
 8021da8:	60fb      	str	r3, [r7, #12]
    temp_capval = temp_capval & BLDC_SCALAR_SPEED_POS_HALL_CAP_COMP_VAL;
 8021daa:	693b      	ldr	r3, [r7, #16]
 8021dac:	b29b      	uxth	r3, r3
 8021dae:	613b      	str	r3, [r7, #16]
        (uint32_t)(BLDC_SCALAR_SPEED_POS_HALL_Cap_Array[(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)] +
 8021db0:	68fb      	ldr	r3, [r7, #12]
 8021db2:	3b05      	subs	r3, #5
 8021db4:	4a0d      	ldr	r2, [pc, #52]	; (8021dec <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue+0x6c>)
 8021db6:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
        (((uint32_t)1 << (curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)) * (uint32_t)temp_capval));
 8021dba:	68fb      	ldr	r3, [r7, #12]
 8021dbc:	3b05      	subs	r3, #5
 8021dbe:	6939      	ldr	r1, [r7, #16]
 8021dc0:	fa01 f303 	lsl.w	r3, r1, r3
        (uint32_t)(BLDC_SCALAR_SPEED_POS_HALL_Cap_Array[(curr_psc - MOTOR0_BLDC_SCALAR_CCU4_PRESCALER)] +
 8021dc4:	4413      	add	r3, r2
    Motor0_BLDC_SCALAR_SPEED_POS_HALL.capval =
 8021dc6:	4a0a      	ldr	r2, [pc, #40]	; (8021df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue+0x70>)
 8021dc8:	6193      	str	r3, [r2, #24]
    *capval = (uint32_t)Motor0_BLDC_SCALAR_SPEED_POS_HALL.capval;
 8021dca:	4b09      	ldr	r3, [pc, #36]	; (8021df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue+0x70>)
 8021dcc:	699a      	ldr	r2, [r3, #24]
 8021dce:	687b      	ldr	r3, [r7, #4]
 8021dd0:	601a      	str	r2, [r3, #0]
    status = BLDC_SCALAR_SPEED_POS_HALL_STATUS_SUCCESS;
 8021dd2:	2300      	movs	r3, #0
 8021dd4:	75fb      	strb	r3, [r7, #23]
 8021dd6:	e002      	b.n	8021dde <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue+0x5e>
    *capval = 0U;
 8021dd8:	687b      	ldr	r3, [r7, #4]
 8021dda:	2200      	movs	r2, #0
 8021ddc:	601a      	str	r2, [r3, #0]
  return (status);
 8021dde:	7dfb      	ldrb	r3, [r7, #23]
}
 8021de0:	4618      	mov	r0, r3
 8021de2:	3718      	adds	r7, #24
 8021de4:	46bd      	mov	sp, r7
 8021de6:	bd80      	pop	{r7, pc}
 8021de8:	4000c200 	.word	0x4000c200
 8021dec:	1ffe91c0 	.word	0x1ffe91c0
 8021df0:	1ffe92bc 	.word	0x1ffe92bc

08021df4 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern>:
{
 8021df4:	b580      	push	{r7, lr}
 8021df6:	b082      	sub	sp, #8
 8021df8:	af00      	add	r7, sp, #0
 8021dfa:	4603      	mov	r3, r0
 8021dfc:	80fb      	strh	r3, [r7, #6]
  XMC_POSIF_MCM_SetMultiChannelPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE, pattern);
 8021dfe:	88fb      	ldrh	r3, [r7, #6]
 8021e00:	4619      	mov	r1, r3
 8021e02:	4803      	ldr	r0, [pc, #12]	; (8021e10 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern+0x1c>)
 8021e04:	f7ff ff93 	bl	8021d2e <XMC_POSIF_MCM_SetMultiChannelPattern>
}
 8021e08:	bf00      	nop
 8021e0a:	3708      	adds	r7, #8
 8021e0c:	46bd      	mov	sp, r7
 8021e0e:	bd80      	pop	{r7, pc}
 8021e10:	40028000 	.word	0x40028000

08021e14 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern>:
{
 8021e14:	b580      	push	{r7, lr}
 8021e16:	b082      	sub	sp, #8
 8021e18:	af00      	add	r7, sp, #0
  pattern = XMC_POSIF_MCM_GetMultiChannelPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8021e1a:	4805      	ldr	r0, [pc, #20]	; (8021e30 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern+0x1c>)
 8021e1c:	f7ff ff96 	bl	8021d4c <XMC_POSIF_MCM_GetMultiChannelPattern>
 8021e20:	4603      	mov	r3, r0
 8021e22:	80fb      	strh	r3, [r7, #6]
  return(pattern);
 8021e24:	88fb      	ldrh	r3, [r7, #6]
}
 8021e26:	4618      	mov	r0, r3
 8021e28:	3708      	adds	r7, #8
 8021e2a:	46bd      	mov	sp, r7
 8021e2c:	bd80      	pop	{r7, pc}
 8021e2e:	bf00      	nop
 8021e30:	40028000 	.word	0x40028000

08021e34 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern>:
{
 8021e34:	b580      	push	{r7, lr}
 8021e36:	b082      	sub	sp, #8
 8021e38:	af00      	add	r7, sp, #0
  pattern = XMC_POSIF_MCM_GetShadowMultiChannelPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8021e3a:	4805      	ldr	r0, [pc, #20]	; (8021e50 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern+0x1c>)
 8021e3c:	f7ff ff93 	bl	8021d66 <XMC_POSIF_MCM_GetShadowMultiChannelPattern>
 8021e40:	4603      	mov	r3, r0
 8021e42:	80fb      	strh	r3, [r7, #6]
  return(pattern);
 8021e44:	88fb      	ldrh	r3, [r7, #6]
}
 8021e46:	4618      	mov	r0, r3
 8021e48:	3708      	adds	r7, #8
 8021e4a:	46bd      	mov	sp, r7
 8021e4c:	bd80      	pop	{r7, pc}
 8021e4e:	bf00      	nop
 8021e50:	40028000 	.word	0x40028000

08021e54 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>:
{
 8021e54:	b580      	push	{r7, lr}
 8021e56:	b082      	sub	sp, #8
 8021e58:	af00      	add	r7, sp, #0
 8021e5a:	4603      	mov	r3, r0
 8021e5c:	71fb      	strb	r3, [r7, #7]
  XMC_POSIF_HSC_SetHallPatterns(MOTOR0_BLDC_SCALAR_POSIF_MODULE, pattern);
 8021e5e:	79fb      	ldrb	r3, [r7, #7]
 8021e60:	4619      	mov	r1, r3
 8021e62:	4803      	ldr	r0, [pc, #12]	; (8021e70 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern+0x1c>)
 8021e64:	f7ff ff52 	bl	8021d0c <XMC_POSIF_HSC_SetHallPatterns>
}
 8021e68:	bf00      	nop
 8021e6a:	3708      	adds	r7, #8
 8021e6c:	46bd      	mov	sp, r7
 8021e6e:	bd80      	pop	{r7, pc}
 8021e70:	40028000 	.word	0x40028000

08021e74 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern>:
{
 8021e74:	b580      	push	{r7, lr}
 8021e76:	b082      	sub	sp, #8
 8021e78:	af00      	add	r7, sp, #0
  pattern = XMC_POSIF_HSC_GetExpectedPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8021e7a:	4805      	ldr	r0, [pc, #20]	; (8021e90 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern+0x1c>)
 8021e7c:	f7ff ff35 	bl	8021cea <XMC_POSIF_HSC_GetExpectedPattern>
 8021e80:	4603      	mov	r3, r0
 8021e82:	71fb      	strb	r3, [r7, #7]
  return(pattern);
 8021e84:	79fb      	ldrb	r3, [r7, #7]
}
 8021e86:	4618      	mov	r0, r3
 8021e88:	3708      	adds	r7, #8
 8021e8a:	46bd      	mov	sp, r7
 8021e8c:	bd80      	pop	{r7, pc}
 8021e8e:	bf00      	nop
 8021e90:	40028000 	.word	0x40028000

08021e94 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern>:
{
 8021e94:	b580      	push	{r7, lr}
 8021e96:	b082      	sub	sp, #8
 8021e98:	af00      	add	r7, sp, #0
  hall_pattern = XMC_POSIF_HSC_GetLastSampledPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8021e9a:	4805      	ldr	r0, [pc, #20]	; (8021eb0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern+0x1c>)
 8021e9c:	f7ff ff12 	bl	8021cc4 <XMC_POSIF_HSC_GetLastSampledPattern>
 8021ea0:	4603      	mov	r3, r0
 8021ea2:	71fb      	strb	r3, [r7, #7]
  return(hall_pattern);
 8021ea4:	79fb      	ldrb	r3, [r7, #7]
}
 8021ea6:	4618      	mov	r0, r3
 8021ea8:	3708      	adds	r7, #8
 8021eaa:	46bd      	mov	sp, r7
 8021eac:	bd80      	pop	{r7, pc}
 8021eae:	bf00      	nop
 8021eb0:	40028000 	.word	0x40028000

08021eb4 <XMC_VADC_GROUP_GetResult>:
{
 8021eb4:	b480      	push	{r7}
 8021eb6:	b083      	sub	sp, #12
 8021eb8:	af00      	add	r7, sp, #0
 8021eba:	6078      	str	r0, [r7, #4]
 8021ebc:	6039      	str	r1, [r7, #0]
  return ((XMC_VADC_RESULT_SIZE_t)group_ptr->RES[res_reg]);
 8021ebe:	687b      	ldr	r3, [r7, #4]
 8021ec0:	683a      	ldr	r2, [r7, #0]
 8021ec2:	32c0      	adds	r2, #192	; 0xc0
 8021ec4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8021ec8:	b29b      	uxth	r3, r3
}
 8021eca:	4618      	mov	r0, r3
 8021ecc:	370c      	adds	r7, #12
 8021ece:	46bd      	mov	sp, r7
 8021ed0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021ed4:	4770      	bx	lr

08021ed6 <VADC_GetResult>:
{
 8021ed6:	b580      	push	{r7, lr}
 8021ed8:	b084      	sub	sp, #16
 8021eda:	af00      	add	r7, sp, #0
 8021edc:	6078      	str	r0, [r7, #4]
 8021ede:	6039      	str	r1, [r7, #0]
  result = (XMC_VADC_RESULT_SIZE_t) XMC_VADC_GROUP_GetResult(group_ptr,res_reg);
 8021ee0:	6839      	ldr	r1, [r7, #0]
 8021ee2:	6878      	ldr	r0, [r7, #4]
 8021ee4:	f7ff ffe6 	bl	8021eb4 <XMC_VADC_GROUP_GetResult>
 8021ee8:	4603      	mov	r3, r0
 8021eea:	81fb      	strh	r3, [r7, #14]
  return(result);
 8021eec:	89fb      	ldrh	r3, [r7, #14]
}
 8021eee:	4618      	mov	r0, r3
 8021ef0:	3710      	adds	r7, #16
 8021ef2:	46bd      	mov	sp, r7
 8021ef4:	bd80      	pop	{r7, pc}

08021ef6 <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter>:
{
 8021ef6:	b480      	push	{r7}
 8021ef8:	b087      	sub	sp, #28
 8021efa:	af00      	add	r7, sp, #0
 8021efc:	60f8      	str	r0, [r7, #12]
 8021efe:	60b9      	str	r1, [r7, #8]
 8021f00:	607a      	str	r2, [r7, #4]
  if ( input_val > higher_limit )
 8021f02:	68fa      	ldr	r2, [r7, #12]
 8021f04:	68bb      	ldr	r3, [r7, #8]
 8021f06:	429a      	cmp	r2, r3
 8021f08:	dd02      	ble.n	8021f10 <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x1a>
    return_val = higher_limit;
 8021f0a:	68bb      	ldr	r3, [r7, #8]
 8021f0c:	617b      	str	r3, [r7, #20]
 8021f0e:	e008      	b.n	8021f22 <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x2c>
  else if ( input_val < lower_limit )
 8021f10:	68fa      	ldr	r2, [r7, #12]
 8021f12:	687b      	ldr	r3, [r7, #4]
 8021f14:	429a      	cmp	r2, r3
 8021f16:	da02      	bge.n	8021f1e <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x28>
    return_val = lower_limit;
 8021f18:	687b      	ldr	r3, [r7, #4]
 8021f1a:	617b      	str	r3, [r7, #20]
 8021f1c:	e001      	b.n	8021f22 <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter+0x2c>
    return_val = input_val;
 8021f1e:	68fb      	ldr	r3, [r7, #12]
 8021f20:	617b      	str	r3, [r7, #20]
  return return_val;
 8021f22:	697b      	ldr	r3, [r7, #20]
}
 8021f24:	4618      	mov	r0, r3
 8021f26:	371c      	adds	r7, #28
 8021f28:	46bd      	mov	sp, r7
 8021f2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021f2e:	4770      	bx	lr

08021f30 <Motor0_BLDC_SCALAR_PT1_Filter>:
{
 8021f30:	b590      	push	{r4, r7, lr}
 8021f32:	b083      	sub	sp, #12
 8021f34:	af00      	add	r7, sp, #0
 8021f36:	6078      	str	r0, [r7, #4]
 8021f38:	6039      	str	r1, [r7, #0]
  temp_buff = handle_ptr->pt1_buf + (handle_ptr->z1*(actual_val - (handle_ptr->pt1_buf >> BLDC_SCALAR_PT1_SHIFT_16)));
 8021f3a:	687b      	ldr	r3, [r7, #4]
 8021f3c:	691a      	ldr	r2, [r3, #16]
 8021f3e:	687b      	ldr	r3, [r7, #4]
 8021f40:	681b      	ldr	r3, [r3, #0]
 8021f42:	6879      	ldr	r1, [r7, #4]
 8021f44:	6909      	ldr	r1, [r1, #16]
 8021f46:	1409      	asrs	r1, r1, #16
 8021f48:	6838      	ldr	r0, [r7, #0]
 8021f4a:	1a41      	subs	r1, r0, r1
 8021f4c:	fb01 f303 	mul.w	r3, r1, r3
 8021f50:	18d4      	adds	r4, r2, r3
  handle_ptr->pt1_buf = Motor0_BLDC_SCALAR_PT1_MinMaxLimiter(temp_buff, handle_ptr->y_max, handle_ptr->y_min);
 8021f52:	687b      	ldr	r3, [r7, #4]
 8021f54:	6899      	ldr	r1, [r3, #8]
 8021f56:	687b      	ldr	r3, [r7, #4]
 8021f58:	68db      	ldr	r3, [r3, #12]
 8021f5a:	461a      	mov	r2, r3
 8021f5c:	4620      	mov	r0, r4
 8021f5e:	f7ff ffca 	bl	8021ef6 <Motor0_BLDC_SCALAR_PT1_MinMaxLimiter>
 8021f62:	4602      	mov	r2, r0
 8021f64:	687b      	ldr	r3, [r7, #4]
 8021f66:	611a      	str	r2, [r3, #16]
  handle_ptr->pt1_out_val = (handle_ptr->pt1_buf >> BLDC_SCALAR_PT1_SHIFT_16);
 8021f68:	687b      	ldr	r3, [r7, #4]
 8021f6a:	691b      	ldr	r3, [r3, #16]
 8021f6c:	141a      	asrs	r2, r3, #16
 8021f6e:	687b      	ldr	r3, [r7, #4]
 8021f70:	615a      	str	r2, [r3, #20]
}
 8021f72:	bf00      	nop
 8021f74:	370c      	adds	r7, #12
 8021f76:	46bd      	mov	sp, r7
 8021f78:	bd90      	pop	{r4, r7, pc}
	...

08021f7c <Motor0_BLDC_SCALAR_GetCurrentValue>:
{
 8021f7c:	b580      	push	{r7, lr}
 8021f7e:	b084      	sub	sp, #16
 8021f80:	af00      	add	r7, sp, #0
 8021f82:	6078      	str	r0, [r7, #4]
  current_value = (int32_t)VADC_GetResult(MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP,MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_RES_REG_NUM);
 8021f84:	2105      	movs	r1, #5
 8021f86:	4821      	ldr	r0, [pc, #132]	; (802200c <Motor0_BLDC_SCALAR_GetCurrentValue+0x90>)
 8021f88:	f7ff ffa5 	bl	8021ed6 <VADC_GetResult>
 8021f8c:	4603      	mov	r3, r0
 8021f8e:	60fb      	str	r3, [r7, #12]
  current_value = (int32_t)(((current_value - Motor0_BLDC_SCALAR_CurrentMeasurement.direct_dc_amplifier_offset) * (int32_t)Motor0_BLDC_SCALAR_CurrentMeasurement.current_adc_scale) >> BLDC_SCALAR_SHIFT_14);
 8021f90:	4b1f      	ldr	r3, [pc, #124]	; (8022010 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021f92:	681b      	ldr	r3, [r3, #0]
 8021f94:	68fa      	ldr	r2, [r7, #12]
 8021f96:	1ad3      	subs	r3, r2, r3
 8021f98:	4a1d      	ldr	r2, [pc, #116]	; (8022010 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021f9a:	6892      	ldr	r2, [r2, #8]
 8021f9c:	fb02 f303 	mul.w	r3, r2, r3
 8021fa0:	139b      	asrs	r3, r3, #14
 8021fa2:	60fb      	str	r3, [r7, #12]
  Motor0_BLDC_SCALAR_PT1_Filter(&Motor0_BLDC_SCALAR_PT1_DirectCurrent,(int32_t)current_value);
 8021fa4:	68f9      	ldr	r1, [r7, #12]
 8021fa6:	481b      	ldr	r0, [pc, #108]	; (8022014 <Motor0_BLDC_SCALAR_GetCurrentValue+0x98>)
 8021fa8:	f7ff ffc2 	bl	8021f30 <Motor0_BLDC_SCALAR_PT1_Filter>
  current_value = ((Motor0_BLDC_SCALAR_PT1_DirectCurrent.pt1_out_val));
 8021fac:	4b19      	ldr	r3, [pc, #100]	; (8022014 <Motor0_BLDC_SCALAR_GetCurrentValue+0x98>)
 8021fae:	695b      	ldr	r3, [r3, #20]
 8021fb0:	60fb      	str	r3, [r7, #12]
  if (Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_enable == 1U)
 8021fb2:	4b17      	ldr	r3, [pc, #92]	; (8022010 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021fb4:	f893 3020 	ldrb.w	r3, [r3, #32]
 8021fb8:	2b01      	cmp	r3, #1
 8021fba:	d11c      	bne.n	8021ff6 <Motor0_BLDC_SCALAR_GetCurrentValue+0x7a>
    Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter++;
 8021fbc:	4b14      	ldr	r3, [pc, #80]	; (8022010 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021fbe:	69db      	ldr	r3, [r3, #28]
 8021fc0:	3301      	adds	r3, #1
 8021fc2:	4a13      	ldr	r2, [pc, #76]	; (8022010 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021fc4:	61d3      	str	r3, [r2, #28]
    if (Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter >
 8021fc6:	4b12      	ldr	r3, [pc, #72]	; (8022010 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021fc8:	69da      	ldr	r2, [r3, #28]
        Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_count)
 8021fca:	4b11      	ldr	r3, [pc, #68]	; (8022010 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021fcc:	699b      	ldr	r3, [r3, #24]
    if (Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter >
 8021fce:	429a      	cmp	r2, r3
 8021fd0:	d90c      	bls.n	8021fec <Motor0_BLDC_SCALAR_GetCurrentValue+0x70>
     *dclink_current = current_value;
 8021fd2:	687b      	ldr	r3, [r7, #4]
 8021fd4:	68fa      	ldr	r2, [r7, #12]
 8021fd6:	601a      	str	r2, [r3, #0]
     Motor0_BLDC_SCALAR_CurrentMeasurement.prev_current = current_value;
 8021fd8:	4a0d      	ldr	r2, [pc, #52]	; (8022010 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021fda:	68fb      	ldr	r3, [r7, #12]
 8021fdc:	6113      	str	r3, [r2, #16]
     Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter = 0U;
 8021fde:	4b0c      	ldr	r3, [pc, #48]	; (8022010 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021fe0:	2200      	movs	r2, #0
 8021fe2:	61da      	str	r2, [r3, #28]
     Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_enable = 0U;
 8021fe4:	4b0a      	ldr	r3, [pc, #40]	; (8022010 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021fe6:	2200      	movs	r2, #0
 8021fe8:	f883 2020 	strb.w	r2, [r3, #32]
    *dclink_current = Motor0_BLDC_SCALAR_CurrentMeasurement.prev_current;
 8021fec:	4b08      	ldr	r3, [pc, #32]	; (8022010 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021fee:	691a      	ldr	r2, [r3, #16]
 8021ff0:	687b      	ldr	r3, [r7, #4]
 8021ff2:	601a      	str	r2, [r3, #0]
}
 8021ff4:	e005      	b.n	8022002 <Motor0_BLDC_SCALAR_GetCurrentValue+0x86>
    *dclink_current = current_value;
 8021ff6:	687b      	ldr	r3, [r7, #4]
 8021ff8:	68fa      	ldr	r2, [r7, #12]
 8021ffa:	601a      	str	r2, [r3, #0]
    Motor0_BLDC_SCALAR_CurrentMeasurement.prev_current =  current_value;
 8021ffc:	4a04      	ldr	r2, [pc, #16]	; (8022010 <Motor0_BLDC_SCALAR_GetCurrentValue+0x94>)
 8021ffe:	68fb      	ldr	r3, [r7, #12]
 8022000:	6113      	str	r3, [r2, #16]
}
 8022002:	bf00      	nop
 8022004:	3710      	adds	r7, #16
 8022006:	46bd      	mov	sp, r7
 8022008:	bd80      	pop	{r7, pc}
 802200a:	bf00      	nop
 802200c:	40005000 	.word	0x40005000
 8022010:	1ffe92e8 	.word	0x1ffe92e8
 8022014:	1ffe9268 	.word	0x1ffe9268

08022018 <VADC0_C0_0_IRQHandler>:
 * Current protection - Global boundary \n
 * Voltage protection - Group specific boundary \n
 */
#if (MOTOR0_BLDC_SCALAR_ENABLE_OVER_CURRENT == 1U)
void Motor0_BLDC_SCALAR_Protection_ISR(void)
{
 8022018:	b580      	push	{r7, lr}
 802201a:	b082      	sub	sp, #8
 802201c:	af00      	add	r7, sp, #0
  int32_t current;   /* ADC value of the current in Q14 */
  /*******************************Current Protection ****************************************************/
  /* Direct DC link current measurement is used for over-current protection */
#if ((MOTOR0_BLDC_SCALAR_OVER_CURRENT_SOURCE == BLDC_SCALAR_IDC_DIRECT_CURRENT) && (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U))
  /* Check whether the interrupt is due to current limit overshoot */
  if ((((MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_GRP->CEFLAG) >> MOTOR0_BLDC_SCALAR_VADC_IDC_LINK_CH_NUM) & 0x1U) == 0x1U)
 802201e:	4b21      	ldr	r3, [pc, #132]	; (80220a4 <VADC0_C0_0_IRQHandler+0x8c>)
 8022020:	f8d3 3180 	ldr.w	r3, [r3, #384]	; 0x180
 8022024:	095b      	lsrs	r3, r3, #5
 8022026:	f003 0301 	and.w	r3, r3, #1
 802202a:	2b01      	cmp	r3, #1
 802202c:	d135      	bne.n	802209a <VADC0_C0_0_IRQHandler+0x82>
  {
    /* Read the current value for short-circuit protection */
    Motor0_BLDC_SCALAR_GetCurrentValue(&current);
 802202e:	1d3b      	adds	r3, r7, #4
 8022030:	4618      	mov	r0, r3
 8022032:	f7ff ffa3 	bl	8021f7c <Motor0_BLDC_SCALAR_GetCurrentValue>
    if ((current > Motor0_BLDC_SCALAR_CurrentMeasurement.short_circuit_current) ||
 8022036:	4b1c      	ldr	r3, [pc, #112]	; (80220a8 <VADC0_C0_0_IRQHandler+0x90>)
 8022038:	68da      	ldr	r2, [r3, #12]
 802203a:	687b      	ldr	r3, [r7, #4]
 802203c:	429a      	cmp	r2, r3
 802203e:	db04      	blt.n	802204a <VADC0_C0_0_IRQHandler+0x32>
        (current > BLDC_SCALAR_VADC_MAX_CURRENT_LIMIT))
 8022040:	687b      	ldr	r3, [r7, #4]
    if ((current > Motor0_BLDC_SCALAR_CurrentMeasurement.short_circuit_current) ||
 8022042:	f643 72d8 	movw	r2, #16344	; 0x3fd8
 8022046:	4293      	cmp	r3, r2
 8022048:	dd0c      	ble.n	8022064 <VADC0_C0_0_IRQHandler+0x4c>
    {
      /* Stop the motor immediately if current is greater than configured short circuit current */
      Motor0_BLDC_SCALAR.error_status |= (uint32_t)1 << (uint32_t)BLDC_SCALAR_EID_SHORTCIRCUIT;
 802204a:	4b18      	ldr	r3, [pc, #96]	; (80220ac <VADC0_C0_0_IRQHandler+0x94>)
 802204c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 802204e:	f043 0304 	orr.w	r3, r3, #4
 8022052:	4a16      	ldr	r2, [pc, #88]	; (80220ac <VADC0_C0_0_IRQHandler+0x94>)
 8022054:	6693      	str	r3, [r2, #104]	; 0x68
      Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_ERROR;
 8022056:	4b15      	ldr	r3, [pc, #84]	; (80220ac <VADC0_C0_0_IRQHandler+0x94>)
 8022058:	2208      	movs	r2, #8
 802205a:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
      Motor0_BLDC_SCALAR_MotorStop();
 802205e:	f000 fc7d 	bl	802295c <Motor0_BLDC_SCALAR_MotorStop>
      }
    }
  }
#endif /* end of #if (MOTOR0_BLDC_SCALAR_OVER_CURRENT_SOURCE == BLDC_SCALAR_IDC_AVG_CURRENT)*/
#endif
}
 8022062:	e01a      	b.n	802209a <VADC0_C0_0_IRQHandler+0x82>
      Motor0_BLDC_SCALAR.overcurrent_counter += 2U;
 8022064:	4b11      	ldr	r3, [pc, #68]	; (80220ac <VADC0_C0_0_IRQHandler+0x94>)
 8022066:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 802206a:	3302      	adds	r3, #2
 802206c:	4a0f      	ldr	r2, [pc, #60]	; (80220ac <VADC0_C0_0_IRQHandler+0x94>)
 802206e:	f8c2 30ac 	str.w	r3, [r2, #172]	; 0xac
      if (Motor0_BLDC_SCALAR.overcurrent_counter > Motor0_BLDC_SCALAR.overcurrent_count)
 8022072:	4b0e      	ldr	r3, [pc, #56]	; (80220ac <VADC0_C0_0_IRQHandler+0x94>)
 8022074:	f8d3 20ac 	ldr.w	r2, [r3, #172]	; 0xac
 8022078:	4b0c      	ldr	r3, [pc, #48]	; (80220ac <VADC0_C0_0_IRQHandler+0x94>)
 802207a:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 802207e:	429a      	cmp	r2, r3
 8022080:	d90b      	bls.n	802209a <VADC0_C0_0_IRQHandler+0x82>
        Motor0_BLDC_SCALAR.error_status |= (uint32_t)1 << (uint32_t)BLDC_SCALAR_EID_OVERCURRENT;
 8022082:	4b0a      	ldr	r3, [pc, #40]	; (80220ac <VADC0_C0_0_IRQHandler+0x94>)
 8022084:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8022086:	f043 0302 	orr.w	r3, r3, #2
 802208a:	4a08      	ldr	r2, [pc, #32]	; (80220ac <VADC0_C0_0_IRQHandler+0x94>)
 802208c:	6693      	str	r3, [r2, #104]	; 0x68
        Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_ERROR;
 802208e:	4b07      	ldr	r3, [pc, #28]	; (80220ac <VADC0_C0_0_IRQHandler+0x94>)
 8022090:	2208      	movs	r2, #8
 8022092:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
        Motor0_BLDC_SCALAR_MotorStop();
 8022096:	f000 fc61 	bl	802295c <Motor0_BLDC_SCALAR_MotorStop>
}
 802209a:	bf00      	nop
 802209c:	3708      	adds	r7, #8
 802209e:	46bd      	mov	sp, r7
 80220a0:	bd80      	pop	{r7, pc}
 80220a2:	bf00      	nop
 80220a4:	40005000 	.word	0x40005000
 80220a8:	1ffe92e8 	.word	0x1ffe92e8
 80220ac:	1ffe9350 	.word	0x1ffe9350

080220b0 <__NVIC_ClearPendingIRQ>:
{
 80220b0:	b480      	push	{r7}
 80220b2:	b083      	sub	sp, #12
 80220b4:	af00      	add	r7, sp, #0
 80220b6:	4603      	mov	r3, r0
 80220b8:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80220ba:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80220be:	2b00      	cmp	r3, #0
 80220c0:	db0c      	blt.n	80220dc <__NVIC_ClearPendingIRQ+0x2c>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80220c2:	79fb      	ldrb	r3, [r7, #7]
 80220c4:	f003 021f 	and.w	r2, r3, #31
 80220c8:	4907      	ldr	r1, [pc, #28]	; (80220e8 <__NVIC_ClearPendingIRQ+0x38>)
 80220ca:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80220ce:	095b      	lsrs	r3, r3, #5
 80220d0:	2001      	movs	r0, #1
 80220d2:	fa00 f202 	lsl.w	r2, r0, r2
 80220d6:	3360      	adds	r3, #96	; 0x60
 80220d8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 80220dc:	bf00      	nop
 80220de:	370c      	adds	r7, #12
 80220e0:	46bd      	mov	sp, r7
 80220e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80220e6:	4770      	bx	lr
 80220e8:	e000e100 	.word	0xe000e100

080220ec <XMC_SCU_SetCcuTriggerHigh>:
{
 80220ec:	b480      	push	{r7}
 80220ee:	b083      	sub	sp, #12
 80220f0:	af00      	add	r7, sp, #0
 80220f2:	6078      	str	r0, [r7, #4]
  SCU_GENERAL->CCUCON |= (uint32_t)trigger;
 80220f4:	4b05      	ldr	r3, [pc, #20]	; (802210c <XMC_SCU_SetCcuTriggerHigh+0x20>)
 80220f6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80220f8:	4904      	ldr	r1, [pc, #16]	; (802210c <XMC_SCU_SetCcuTriggerHigh+0x20>)
 80220fa:	687b      	ldr	r3, [r7, #4]
 80220fc:	4313      	orrs	r3, r2
 80220fe:	64cb      	str	r3, [r1, #76]	; 0x4c
}
 8022100:	bf00      	nop
 8022102:	370c      	adds	r7, #12
 8022104:	46bd      	mov	sp, r7
 8022106:	f85d 7b04 	ldr.w	r7, [sp], #4
 802210a:	4770      	bx	lr
 802210c:	50004000 	.word	0x50004000

08022110 <XMC_POSIF_HSC_GetExpectedPattern>:
{
 8022110:	b480      	push	{r7}
 8022112:	b083      	sub	sp, #12
 8022114:	af00      	add	r7, sp, #0
 8022116:	6078      	str	r0, [r7, #4]
  return ((uint8_t)((peripheral->HALP & POSIF_HALP_HEP_Msk) >> POSIF_HALP_HEP_Pos));
 8022118:	687b      	ldr	r3, [r7, #4]
 802211a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802211c:	08db      	lsrs	r3, r3, #3
 802211e:	b2db      	uxtb	r3, r3
 8022120:	f003 0307 	and.w	r3, r3, #7
 8022124:	b2db      	uxtb	r3, r3
}
 8022126:	4618      	mov	r0, r3
 8022128:	370c      	adds	r7, #12
 802212a:	46bd      	mov	sp, r7
 802212c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022130:	4770      	bx	lr

08022132 <XMC_POSIF_HSC_SetHallPatterns>:
{
 8022132:	b480      	push	{r7}
 8022134:	b083      	sub	sp, #12
 8022136:	af00      	add	r7, sp, #0
 8022138:	6078      	str	r0, [r7, #4]
 802213a:	460b      	mov	r3, r1
 802213c:	70fb      	strb	r3, [r7, #3]
  peripheral->HALPS = (uint32_t)(pattern_mask & (POSIF_HALPS_HCPS_Msk | POSIF_HALPS_HEPS_Msk));
 802213e:	78fb      	ldrb	r3, [r7, #3]
 8022140:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 8022144:	687b      	ldr	r3, [r7, #4]
 8022146:	635a      	str	r2, [r3, #52]	; 0x34
}
 8022148:	bf00      	nop
 802214a:	370c      	adds	r7, #12
 802214c:	46bd      	mov	sp, r7
 802214e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022152:	4770      	bx	lr

08022154 <XMC_POSIF_HSC_UpdateHallPattern>:
{
 8022154:	b480      	push	{r7}
 8022156:	b083      	sub	sp, #12
 8022158:	af00      	add	r7, sp, #0
 802215a:	6078      	str	r0, [r7, #4]
  peripheral->MCMS = (uint32_t)POSIF_MCMS_STHR_Msk;
 802215c:	687b      	ldr	r3, [r7, #4]
 802215e:	2202      	movs	r2, #2
 8022160:	649a      	str	r2, [r3, #72]	; 0x48
}
 8022162:	bf00      	nop
 8022164:	370c      	adds	r7, #12
 8022166:	46bd      	mov	sp, r7
 8022168:	f85d 7b04 	ldr.w	r7, [sp], #4
 802216c:	4770      	bx	lr

0802216e <XMC_POSIF_DisableEvent>:
{
 802216e:	b480      	push	{r7}
 8022170:	b083      	sub	sp, #12
 8022172:	af00      	add	r7, sp, #0
 8022174:	6078      	str	r0, [r7, #4]
 8022176:	460b      	mov	r3, r1
 8022178:	70fb      	strb	r3, [r7, #3]
  peripheral->PFLGE &= ~((uint32_t)1 << (uint8_t)event);
 802217a:	687b      	ldr	r3, [r7, #4]
 802217c:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 802217e:	78fb      	ldrb	r3, [r7, #3]
 8022180:	2101      	movs	r1, #1
 8022182:	fa01 f303 	lsl.w	r3, r1, r3
 8022186:	43db      	mvns	r3, r3
 8022188:	401a      	ands	r2, r3
 802218a:	687b      	ldr	r3, [r7, #4]
 802218c:	675a      	str	r2, [r3, #116]	; 0x74
}
 802218e:	bf00      	nop
 8022190:	370c      	adds	r7, #12
 8022192:	46bd      	mov	sp, r7
 8022194:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022198:	4770      	bx	lr

0802219a <Motor0_BLDC_SCALAR_CCU8_PWM_Start>:
 *
 * \par<b>Description:</b><br>
 * Set CCUCON trigger signal to high to start all slices synchronously.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_CCU8_PWM_Start(void)
{
 802219a:	b580      	push	{r7, lr}
 802219c:	af00      	add	r7, sp, #0
  XMC_SCU_SetCcuTriggerHigh((uint32_t)MOTOR0_BLDC_SCALAR_CCU8_SYNC_START);
 802219e:	f44f 7080 	mov.w	r0, #256	; 0x100
 80221a2:	f7ff ffa3 	bl	80220ec <XMC_SCU_SetCcuTriggerHigh>
}
 80221a6:	bf00      	nop
 80221a8:	bd80      	pop	{r7, pc}
	...

080221ac <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter>:
{
 80221ac:	b480      	push	{r7}
 80221ae:	af00      	add	r7, sp, #0
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex = 0U;
 80221b0:	4b12      	ldr	r3, [pc, #72]	; (80221fc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221b2:	2200      	movs	r2, #0
 80221b4:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedcheck = 0U;
 80221b8:	4b10      	ldr	r3, [pc, #64]	; (80221fc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221ba:	2200      	movs	r2, #0
 80221bc:	61da      	str	r2, [r3, #28]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[0] = 0U;
 80221be:	4b0f      	ldr	r3, [pc, #60]	; (80221fc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221c0:	2200      	movs	r2, #0
 80221c2:	601a      	str	r2, [r3, #0]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[1] = 0U;
 80221c4:	4b0d      	ldr	r3, [pc, #52]	; (80221fc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221c6:	2200      	movs	r2, #0
 80221c8:	605a      	str	r2, [r3, #4]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[2] = 0U;
 80221ca:	4b0c      	ldr	r3, [pc, #48]	; (80221fc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221cc:	2200      	movs	r2, #0
 80221ce:	609a      	str	r2, [r3, #8]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[3] = 0U;
 80221d0:	4b0a      	ldr	r3, [pc, #40]	; (80221fc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221d2:	2200      	movs	r2, #0
 80221d4:	60da      	str	r2, [r3, #12]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[4] = 0U;
 80221d6:	4b09      	ldr	r3, [pc, #36]	; (80221fc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221d8:	2200      	movs	r2, #0
 80221da:	611a      	str	r2, [r3, #16]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[5] = 0U;
 80221dc:	4b07      	ldr	r3, [pc, #28]	; (80221fc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221de:	2200      	movs	r2, #0
 80221e0:	615a      	str	r2, [r3, #20]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.capval = Motor0_BLDC_SCALAR_SPEED_POS_HALL.speed_constant;
 80221e2:	4b06      	ldr	r3, [pc, #24]	; (80221fc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80221e6:	4a05      	ldr	r2, [pc, #20]	; (80221fc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221e8:	6193      	str	r3, [r2, #24]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum = 0U;
 80221ea:	4b04      	ldr	r3, [pc, #16]	; (80221fc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter+0x50>)
 80221ec:	2200      	movs	r2, #0
 80221ee:	621a      	str	r2, [r3, #32]
}
 80221f0:	bf00      	nop
 80221f2:	46bd      	mov	sp, r7
 80221f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80221f8:	4770      	bx	lr
 80221fa:	bf00      	nop
 80221fc:	1ffe92bc 	.word	0x1ffe92bc

08022200 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>:
{
 8022200:	b580      	push	{r7, lr}
 8022202:	b082      	sub	sp, #8
 8022204:	af00      	add	r7, sp, #0
 8022206:	4603      	mov	r3, r0
 8022208:	71fb      	strb	r3, [r7, #7]
  XMC_POSIF_HSC_SetHallPatterns(MOTOR0_BLDC_SCALAR_POSIF_MODULE, pattern);
 802220a:	79fb      	ldrb	r3, [r7, #7]
 802220c:	4619      	mov	r1, r3
 802220e:	4803      	ldr	r0, [pc, #12]	; (802221c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern+0x1c>)
 8022210:	f7ff ff8f 	bl	8022132 <XMC_POSIF_HSC_SetHallPatterns>
}
 8022214:	bf00      	nop
 8022216:	3708      	adds	r7, #8
 8022218:	46bd      	mov	sp, r7
 802221a:	bd80      	pop	{r7, pc}
 802221c:	40028000 	.word	0x40028000

08022220 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern>:
{
 8022220:	b580      	push	{r7, lr}
 8022222:	af00      	add	r7, sp, #0
  XMC_POSIF_HSC_UpdateHallPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8022224:	4802      	ldr	r0, [pc, #8]	; (8022230 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern+0x10>)
 8022226:	f7ff ff95 	bl	8022154 <XMC_POSIF_HSC_UpdateHallPattern>
}
 802222a:	bf00      	nop
 802222c:	bd80      	pop	{r7, pc}
 802222e:	bf00      	nop
 8022230:	40028000 	.word	0x40028000

08022234 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern>:
{
 8022234:	b580      	push	{r7, lr}
 8022236:	b082      	sub	sp, #8
 8022238:	af00      	add	r7, sp, #0
  pattern = XMC_POSIF_HSC_GetExpectedPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 802223a:	4805      	ldr	r0, [pc, #20]	; (8022250 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern+0x1c>)
 802223c:	f7ff ff68 	bl	8022110 <XMC_POSIF_HSC_GetExpectedPattern>
 8022240:	4603      	mov	r3, r0
 8022242:	71fb      	strb	r3, [r7, #7]
  return(pattern);
 8022244:	79fb      	ldrb	r3, [r7, #7]
}
 8022246:	4618      	mov	r0, r3
 8022248:	3708      	adds	r7, #8
 802224a:	46bd      	mov	sp, r7
 802224c:	bd80      	pop	{r7, pc}
 802224e:	bf00      	nop
 8022250:	40028000 	.word	0x40028000

08022254 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent>:
 *
 * \par<b>Description</b><br>
 * Disables event generation of peripheral.\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent(const XMC_POSIF_IRQ_EVENT_t event)
{
 8022254:	b580      	push	{r7, lr}
 8022256:	b082      	sub	sp, #8
 8022258:	af00      	add	r7, sp, #0
 802225a:	4603      	mov	r3, r0
 802225c:	71fb      	strb	r3, [r7, #7]
  XMC_POSIF_DisableEvent(MOTOR0_BLDC_SCALAR_POSIF_MODULE, event);
 802225e:	79fb      	ldrb	r3, [r7, #7]
 8022260:	4619      	mov	r1, r3
 8022262:	4803      	ldr	r0, [pc, #12]	; (8022270 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent+0x1c>)
 8022264:	f7ff ff83 	bl	802216e <XMC_POSIF_DisableEvent>
}
 8022268:	bf00      	nop
 802226a:	3708      	adds	r7, #8
 802226c:	46bd      	mov	sp, r7
 802226e:	bd80      	pop	{r7, pc}
 8022270:	40028000 	.word	0x40028000

08022274 <Motor0_BLDC_SCALAR_MSM_START_Func>:
 * Initialize Motor control variables
 * Enable inverter
 * Enable interrupt for ctrap and protection
 */
static void Motor0_BLDC_SCALAR_MSM_START_Func(void)
{
 8022274:	b580      	push	{r7, lr}
 8022276:	af00      	add	r7, sp, #0
  /*Initialize all run time parameters*/
  Motor0_BLDC_SCALAR_MotorParamInit();
 8022278:	f000 fa7a 	bl	8022770 <Motor0_BLDC_SCALAR_MotorParamInit>
#if (MOTOR0_BLDC_SCALAR_INVERTER_ENABLE_CONF != BLDC_SCALAR_INV_DISABLED)
  /*Enable inverter*/
  Motor0_BLDC_SCALAR_PWM_BC_InverterEnable();
 802227c:	f7fe fbbe 	bl	80209fc <Motor0_BLDC_SCALAR_PWM_BC_InverterEnable>
  /* ISR Init for trap */
  BLDC_SCALAR_NVIC_NodeInit(MOTOR0_BLDC_SCALAR_CTRAP_NODE, MOTOR0_BLDC_SCALAR_TRAP_NVIC_PRIO,MOTOR0_BLDC_SCALAR_TRAP_NVIC_SUBPRIO);
#endif
#if (MOTOR0_BLDC_SCALAR_ENABLE_OVER_CURRENT == 1U)
  /* ISR Init for VADC channel event handler*/
  BLDC_SCALAR_NVIC_NodeInit(MOTOR0_BLDC_SCALAR_VADC_PROTECTION_NODE, MOTOR0_BLDC_SCALAR_VADC_PROTECTION_NVIC_PRIO,MOTOR0_BLDC_SCALAR_VADC_PROTECTION_NVIC_SUBPRIO);
 8022280:	2200      	movs	r2, #0
 8022282:	213c      	movs	r1, #60	; 0x3c
 8022284:	200e      	movs	r0, #14
 8022286:	f7fe ff64 	bl	8021152 <BLDC_SCALAR_NVIC_NodeInit>
#endif

  Motor0_BLDC_SCALAR_MSM_START_Exit_Func();
 802228a:	f000 f802 	bl	8022292 <Motor0_BLDC_SCALAR_MSM_START_Exit_Func>
}
 802228e:	bf00      	nop
 8022290:	bd80      	pop	{r7, pc}

08022292 <Motor0_BLDC_SCALAR_MSM_START_Exit_Func>:
 * BOOTSTRAP: if catch free running motor feature is disabled and bootstrap feature is enabled
 * HALL_LEARNING: if catch free running motor feature is disabled and bootstrap feature is disabled, and hall learning feature is enabled
 * NORMAL_OPERATION: if catch free running motor, bootstrap and hall learning features are disabled
 */
static void Motor0_BLDC_SCALAR_MSM_START_Exit_Func(void)
{
 8022292:	b580      	push	{r7, lr}
 8022294:	af00      	add	r7, sp, #0
#if (MOTOR0_BLDC_SCALAR_ENABLE_CATCH_FREE == 1U)
  Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func();
 8022296:	f000 f881 	bl	802239c <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func>
    Motor0_BLDC_SCALAR_MSM_HALL_LEARNING_Entry_Func();
  #else
    Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func();
  #endif
#endif  /* end of #if (MOTOR0_BLDC_SCALAR_ENABLE_CATCH_FREE == 1U) */
}
 802229a:	bf00      	nop
 802229c:	bd80      	pop	{r7, pc}
	...

080222a0 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func>:
 * Start the CCU8 for PWM
 * Disable correct hall event
 * Enable wrong hall event, multi-channel pattern shadow transfer event and CCU8 one match event
 */
static void Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func(void)
{
 80222a0:	b580      	push	{r7, lr}
 80222a2:	af00      	add	r7, sp, #0
  /* Disable correct hall event */
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent(XMC_POSIF_IRQ_EVENT_CHE);
 80222a4:	2000      	movs	r0, #0
 80222a6:	f7ff ffd5 	bl	8022254 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent>
  Motor0_BLDC_SCALAR_Hall.prev_hall_pos = (uint8_t) Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition();
 80222aa:	f7fe fcab 	bl	8020c04 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition>
 80222ae:	4603      	mov	r3, r0
 80222b0:	b2da      	uxtb	r2, r3
 80222b2:	4b1a      	ldr	r3, [pc, #104]	; (802231c <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x7c>)
 80222b4:	745a      	strb	r2, [r3, #17]
  Motor0_BLDC_SCALAR_PatternInitiator(Motor0_BLDC_SCALAR_Hall.prev_hall_pos);
 80222b6:	4b19      	ldr	r3, [pc, #100]	; (802231c <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x7c>)
 80222b8:	7c5b      	ldrb	r3, [r3, #17]
 80222ba:	4618      	mov	r0, r3
 80222bc:	f006 f86c 	bl	8028398 <__Motor0_BLDC_SCALAR_PatternInitiator_veneer>
  NVIC_ClearPendingIRQ(MOTOR0_BLDC_SCALAR_HALL_EVENT_NODE);
 80222c0:	2044      	movs	r0, #68	; 0x44
 80222c2:	f7ff fef5 	bl	80220b0 <__NVIC_ClearPendingIRQ>

  /* POSIF is in running mode in MOTOR_STATE_IDENTIFICATION state */
  if (Motor0_BLDC_SCALAR.msm_state != BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION)
 80222c6:	4b16      	ldr	r3, [pc, #88]	; (8022320 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x80>)
 80222c8:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 80222cc:	b2db      	uxtb	r3, r3
 80222ce:	2b02      	cmp	r3, #2
 80222d0:	d006      	beq.n	80222e0 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x40>
  {
    /* Start POSIF */
    Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start();
 80222d2:	f7fe fc69 	bl	8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start>

    /* ISR Init for wrong hall event*/
    BLDC_SCALAR_NVIC_NodeInit(MOTOR0_BLDC_SCALAR_HALL_EVENT_NODE,MOTOR0_BLDC_SCALAR_HALL_NVIC_PRIO,MOTOR0_BLDC_SCALAR_HALL_NVIC_SUBPRIO);
 80222d6:	2200      	movs	r2, #0
 80222d8:	213d      	movs	r1, #61	; 0x3d
 80222da:	2044      	movs	r0, #68	; 0x44
 80222dc:	f7fe ff39 	bl	8021152 <BLDC_SCALAR_NVIC_NodeInit>
  }

  /* ISR Init for pattern update handler */
  BLDC_SCALAR_NVIC_NodeInit(MOTOR0_BLDC_SCALAR_PATTERN_UPDATE_NODE, MOTOR0_BLDC_SCALAR_PATTERN_UPDATE_NVIC_PRIO, MOTOR0_BLDC_SCALAR_PATTERN_UPDATE_NVIC_SUBPRIO);
 80222e0:	2200      	movs	r2, #0
 80222e2:	213d      	movs	r1, #61	; 0x3d
 80222e4:	2045      	movs	r0, #69	; 0x45
 80222e6:	f7fe ff34 	bl	8021152 <BLDC_SCALAR_NVIC_NodeInit>
  /* ISR Init for control loop */
  BLDC_SCALAR_NVIC_NodeInit(MOTOR0_BLDC_SCALAR_CTRL_LOOP_NODE, MOTOR0_BLDC_SCALAR_CTRL_LOOP_NVIC_PRIO,MOTOR0_BLDC_SCALAR_CTRL_LOOP_NVIC_SUBPRIO);
 80222ea:	2200      	movs	r2, #0
 80222ec:	213e      	movs	r1, #62	; 0x3e
 80222ee:	203c      	movs	r0, #60	; 0x3c
 80222f0:	f7fe ff2f 	bl	8021152 <BLDC_SCALAR_NVIC_NodeInit>

  if ((Motor0_BLDC_SCALAR.msm_state == BLDC_SCALAR_MSM_START) || (Motor0_BLDC_SCALAR.msm_state == BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION))
 80222f4:	4b0a      	ldr	r3, [pc, #40]	; (8022320 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x80>)
 80222f6:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 80222fa:	b2db      	uxtb	r3, r3
 80222fc:	2b01      	cmp	r3, #1
 80222fe:	d005      	beq.n	802230c <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x6c>
 8022300:	4b07      	ldr	r3, [pc, #28]	; (8022320 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x80>)
 8022302:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 8022306:	b2db      	uxtb	r3, r3
 8022308:	2b02      	cmp	r3, #2
 802230a:	d101      	bne.n	8022310 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x70>
  {
    /* Start CCU8 */
    Motor0_BLDC_SCALAR_CCU8_PWM_Start();
 802230c:	f7ff ff45 	bl	802219a <Motor0_BLDC_SCALAR_CCU8_PWM_Start>
  }
  Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_NORMAL_OPERATION;
 8022310:	4b03      	ldr	r3, [pc, #12]	; (8022320 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func+0x80>)
 8022312:	2207      	movs	r2, #7
 8022314:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
}
 8022318:	bf00      	nop
 802231a:	bd80      	pop	{r7, pc}
 802231c:	1ffe931c 	.word	0x1ffe931c
 8022320:	1ffe9350 	.word	0x1ffe9350

08022324 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func>:
 * Ramp
 * Stall detection
 * zero duty condition handling
 */
static void Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func(void)
{
 8022324:	b580      	push	{r7, lr}
 8022326:	b082      	sub	sp, #8
 8022328:	af00      	add	r7, sp, #0
  Motor0_BLDC_SCALAR_AnalogIpMeasurement();
#endif

  /************************** Ramp start**************************/
#if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U)
  Motor0_BLDC_SCALAR.set_val = Motor0_BLDC_SCALAR_Ramp.set_value;
 802232a:	4b18      	ldr	r3, [pc, #96]	; (802238c <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 802232c:	681b      	ldr	r3, [r3, #0]
 802232e:	4a18      	ldr	r2, [pc, #96]	; (8022390 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x6c>)
 8022330:	6013      	str	r3, [r2, #0]
#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_POTENTIOMETER_MEASUREMENT == 1U)
  Motor0_BLDC_SCALAR_Ramp.input_value = Motor0_BLDC_SCALAR.analogip_val;
#else  /* potentiometer disabled */
  #if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL) || (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEEDCURRENT_CTRL))
  /* Speed control */
    Motor0_BLDC_SCALAR_Ramp.input_value = Motor0_BLDC_SCALAR_SpeedControl.user_speed_set;
 8022332:	4b18      	ldr	r3, [pc, #96]	; (8022394 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x70>)
 8022334:	685b      	ldr	r3, [r3, #4]
 8022336:	4a15      	ldr	r2, [pc, #84]	; (802238c <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 8022338:	6053      	str	r3, [r2, #4]
    Motor0_BLDC_SCALAR_Ramp.input_value = Motor0_BLDC_SCALAR_VoltageControl.user_voltage_set;
  #endif

#endif /* end of #if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_POTENTIOMETER_MEASUREMENT == 1U) */

  setval_diff =  ((Motor0_BLDC_SCALAR_Ramp.input_value) - Motor0_BLDC_SCALAR_Ramp.set_value) *
 802233a:	4b14      	ldr	r3, [pc, #80]	; (802238c <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 802233c:	685a      	ldr	r2, [r3, #4]
 802233e:	4b13      	ldr	r3, [pc, #76]	; (802238c <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 8022340:	681b      	ldr	r3, [r3, #0]
 8022342:	1ad3      	subs	r3, r2, r3
                 Motor0_BLDC_SCALAR.motor_set_direction;
 8022344:	4a12      	ldr	r2, [pc, #72]	; (8022390 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x6c>)
 8022346:	6f92      	ldr	r2, [r2, #120]	; 0x78
  setval_diff =  ((Motor0_BLDC_SCALAR_Ramp.input_value) - Motor0_BLDC_SCALAR_Ramp.set_value) *
 8022348:	fb02 f303 	mul.w	r3, r2, r3
 802234c:	607b      	str	r3, [r7, #4]

  /* Find whether ramp up or down is required based on set value */
  if (setval_diff < 0)
 802234e:	687b      	ldr	r3, [r7, #4]
 8022350:	2b00      	cmp	r3, #0
 8022352:	da04      	bge.n	802235e <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x3a>
  {
    Motor0_BLDC_SCALAR_Ramp.ramp_rate = Motor0_BLDC_SCALAR_Ramp.ramp_down_rate;
 8022354:	4b0d      	ldr	r3, [pc, #52]	; (802238c <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 8022356:	691b      	ldr	r3, [r3, #16]
 8022358:	4a0c      	ldr	r2, [pc, #48]	; (802238c <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 802235a:	6093      	str	r3, [r2, #8]
 802235c:	e003      	b.n	8022366 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x42>
  }
  else
  {
    Motor0_BLDC_SCALAR_Ramp.ramp_rate = Motor0_BLDC_SCALAR_Ramp.ramp_up_rate;
 802235e:	4b0b      	ldr	r3, [pc, #44]	; (802238c <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 8022360:	68db      	ldr	r3, [r3, #12]
 8022362:	4a0a      	ldr	r2, [pc, #40]	; (802238c <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x68>)
 8022364:	6093      	str	r3, [r2, #8]
  {
    Motor0_BLDC_SCALAR_Ramp_Linear();
  }
  #else /* #if(MOTOR0_BLDC_SCALAR_VADC_ENABLE_VDC_LINK_MEASUREMENT == 1U) */

  Motor0_BLDC_SCALAR_Ramp_Linear();
 8022366:	f006 f80b 	bl	8028380 <__Motor0_BLDC_SCALAR_Ramp_Linear_veneer>
    {
      Motor0_BLDC_SCALAR.stall_check = 1U;
    }
#endif
    /* zero speed handling */
    curr_psc = (uint32_t)((uint32_t)MOTOR0_BLDC_SCALAR_CCU4_CAPTURE_SLICE->FPC >> BLDC_SCALAR_HALL_CAPVAL_POS);
 802236a:	4b0b      	ldr	r3, [pc, #44]	; (8022398 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x74>)
 802236c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802236e:	0a1b      	lsrs	r3, r3, #8
 8022370:	603b      	str	r3, [r7, #0]
    /* reset the speed calculation related variables when prescaler is greater 11 */
    if (curr_psc > BLDC_SCALAR_PRESCALER_CMP_VALUE)
 8022372:	683b      	ldr	r3, [r7, #0]
 8022374:	2b0b      	cmp	r3, #11
 8022376:	d904      	bls.n	8022382 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x5e>
    {
      /* Reset speed calculation related variables */
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter();
 8022378:	f7ff ff18 	bl	80221ac <Motor0_BLDC_SCALAR_SPEED_POS_HALL_ClearSpeedFilter>
      Motor0_BLDC_SCALAR.motor_speed = 0;
 802237c:	4b04      	ldr	r3, [pc, #16]	; (8022390 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func+0x6c>)
 802237e:	2200      	movs	r2, #0
 8022380:	66da      	str	r2, [r3, #108]	; 0x6c
  {
    Motor0_BLDC_SCALAR_MSM_IDLE_Entry_Func();
  }
#endif

}
 8022382:	bf00      	nop
 8022384:	3708      	adds	r7, #8
 8022386:	46bd      	mov	sp, r7
 8022388:	bd80      	pop	{r7, pc}
 802238a:	bf00      	nop
 802238c:	1ffe9280 	.word	0x1ffe9280
 8022390:	1ffe9350 	.word	0x1ffe9350
 8022394:	1ffe930c 	.word	0x1ffe930c
 8022398:	4000c200 	.word	0x4000c200

0802239c <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func>:
 * Enable correct and wrong hall event
 */

#if (MOTOR0_BLDC_SCALAR_ENABLE_CATCH_FREE == 1U)
static void Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func(void)
{
 802239c:	b580      	push	{r7, lr}
 802239e:	b082      	sub	sp, #8
 80223a0:	af00      	add	r7, sp, #0
  uint8_t pattern_index;       /* hall pattern index */
  uint8_t direction = (uint8_t) Motor0_BLDC_SCALAR.motor_set_direction & BLDC_SCALAR_HALL_MOTOR_DIR_INDEX;
 80223a2:	4b1b      	ldr	r3, [pc, #108]	; (8022410 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x74>)
 80223a4:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80223a6:	b2db      	uxtb	r3, r3
 80223a8:	f003 0308 	and.w	r3, r3, #8
 80223ac:	71fb      	strb	r3, [r7, #7]

  Motor0_BLDC_SCALAR_HALL_CatchFree.identified_direction = Motor0_BLDC_SCALAR.motor_set_direction;
 80223ae:	4b18      	ldr	r3, [pc, #96]	; (8022410 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x74>)
 80223b0:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80223b2:	4a18      	ldr	r2, [pc, #96]	; (8022414 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x78>)
 80223b4:	60d3      	str	r3, [r2, #12]

  /* Load initial hall pattern and start the POSIF */
  Motor0_BLDC_SCALAR_Hall.prev_hall_pos = (uint8_t) Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition();
 80223b6:	f7fe fc25 	bl	8020c04 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition>
 80223ba:	4603      	mov	r3, r0
 80223bc:	b2da      	uxtb	r2, r3
 80223be:	4b16      	ldr	r3, [pc, #88]	; (8022418 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x7c>)
 80223c0:	745a      	strb	r2, [r3, #17]

  /* Update the hall pattern in shadow register and perform immediate transfer */
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
      (uint8_t) (Motor0_BLDC_SCALAR_Hall.hall_pattern[Motor0_BLDC_SCALAR_Hall.prev_hall_pos + (uint32_t) direction]));
 80223c2:	4b15      	ldr	r3, [pc, #84]	; (8022418 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x7c>)
 80223c4:	7c5b      	ldrb	r3, [r3, #17]
 80223c6:	461a      	mov	r2, r3
 80223c8:	79fb      	ldrb	r3, [r7, #7]
 80223ca:	4413      	add	r3, r2
 80223cc:	4a12      	ldr	r2, [pc, #72]	; (8022418 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x7c>)
 80223ce:	5cd3      	ldrb	r3, [r2, r3]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
 80223d0:	4618      	mov	r0, r3
 80223d2:	f7ff ff15 	bl	8022200 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern();
 80223d6:	f7ff ff23 	bl	8022220 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern>
  /*Get Expected Pattern*/
  pattern_index = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern();
 80223da:	f7ff ff2b 	bl	8022234 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern>
 80223de:	4603      	mov	r3, r0
 80223e0:	71bb      	strb	r3, [r7, #6]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
      (uint8_t) (Motor0_BLDC_SCALAR_Hall.hall_pattern[(uint8_t) pattern_index + (uint32_t) direction]));
 80223e2:	79ba      	ldrb	r2, [r7, #6]
 80223e4:	79fb      	ldrb	r3, [r7, #7]
 80223e6:	4413      	add	r3, r2
 80223e8:	4a0b      	ldr	r2, [pc, #44]	; (8022418 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x7c>)
 80223ea:	5cd3      	ldrb	r3, [r2, r3]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
 80223ec:	4618      	mov	r0, r3
 80223ee:	f7ff ff07 	bl	8022200 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>

  /* Start POSIF */
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start();
 80223f2:	f7fe fbd9 	bl	8020ba8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Start>
  /* ISR Init for wrong hall event and correct hall event handler*/
  BLDC_SCALAR_NVIC_NodeInit(MOTOR0_BLDC_SCALAR_HALL_EVENT_NODE, MOTOR0_BLDC_SCALAR_HALL_NVIC_PRIO,MOTOR0_BLDC_SCALAR_HALL_NVIC_SUBPRIO);
 80223f6:	2200      	movs	r2, #0
 80223f8:	213d      	movs	r1, #61	; 0x3d
 80223fa:	2044      	movs	r0, #68	; 0x44
 80223fc:	f7fe fea9 	bl	8021152 <BLDC_SCALAR_NVIC_NodeInit>
  /*Change Motor Control State to motor state identification */
  Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION;
 8022400:	4b03      	ldr	r3, [pc, #12]	; (8022410 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Entry_Func+0x74>)
 8022402:	2202      	movs	r2, #2
 8022404:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
}
 8022408:	bf00      	nop
 802240a:	3708      	adds	r7, #8
 802240c:	46bd      	mov	sp, r7
 802240e:	bd80      	pop	{r7, pc}
 8022410:	1ffe9350 	.word	0x1ffe9350
 8022414:	1ffe9330 	.word	0x1ffe9330
 8022418:	1ffe931c 	.word	0x1ffe931c

0802241c <Motor0_BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION_Func>:
/*
 * STATE_IDENTIFICATION state:
 * Wait for detection timeout or state identification flag to be set; whichever is earlier
 */
static void Motor0_BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION_Func(void)
{
 802241c:	b580      	push	{r7, lr}
 802241e:	af00      	add	r7, sp, #0
  if (BLDC_SCALAR_STATE_IDENTIFICATION_COMPLETED == Motor0_BLDC_SCALAR_State_Identification())
 8022420:	f000 f958 	bl	80226d4 <Motor0_BLDC_SCALAR_State_Identification>
 8022424:	4603      	mov	r3, r0
 8022426:	2b01      	cmp	r3, #1
 8022428:	d101      	bne.n	802242e <Motor0_BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION_Func+0x12>
  {
    Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func();
 802242a:	f000 f803 	bl	8022434 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func>
  }
}
 802242e:	bf00      	nop
 8022430:	bd80      	pop	{r7, pc}
	...

08022434 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func>:
 *            if motor is running in reverse direction with speed less than threshold speed and bootstrap is enabled
 * HALL_LEARNING: if motor is freely running in the intended direction with speed less than threshold speed and bootstrap is disabled and hall learning is enabled OR
 *            if motor is running in reverse direction with speed less than threshold speed and bootstrap is disabled and hall learning is enabled
 */
static void Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func(void)
{
 8022434:	b580      	push	{r7, lr}
 8022436:	af00      	add	r7, sp, #0
  /* Disable correct hall event */
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent(XMC_POSIF_IRQ_EVENT_CHE);
 8022438:	2000      	movs	r0, #0
 802243a:	f7ff ff0b 	bl	8022254 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent>

  /* Motor is freely running in the intended direction */
  if (Motor0_BLDC_SCALAR_HALL_CatchFree.identified_direction == Motor0_BLDC_SCALAR.motor_set_direction)
 802243e:	4b20      	ldr	r3, [pc, #128]	; (80224c0 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x8c>)
 8022440:	68da      	ldr	r2, [r3, #12]
 8022442:	4b20      	ldr	r3, [pc, #128]	; (80224c4 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 8022444:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8022446:	429a      	cmp	r2, r3
 8022448:	d118      	bne.n	802247c <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x48>
        Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func();
    #endif
    }
#else
    /* if speed is greater than threshold speed, go to closed loop operation */
    if ((Motor0_BLDC_SCALAR.motor_speed > (int32_t)Motor0_BLDC_SCALAR_HALL_CatchFree.cf_max_speed) ||
 802244a:	4b1e      	ldr	r3, [pc, #120]	; (80224c4 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 802244c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 802244e:	4b1c      	ldr	r3, [pc, #112]	; (80224c0 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x8c>)
 8022450:	699b      	ldr	r3, [r3, #24]
 8022452:	429a      	cmp	r2, r3
 8022454:	dc06      	bgt.n	8022464 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x30>
        (Motor0_BLDC_SCALAR.motor_speed < -Motor0_BLDC_SCALAR_HALL_CatchFree.cf_max_speed))
 8022456:	4b1b      	ldr	r3, [pc, #108]	; (80224c4 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 8022458:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 802245a:	4b19      	ldr	r3, [pc, #100]	; (80224c0 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x8c>)
 802245c:	699b      	ldr	r3, [r3, #24]
 802245e:	425b      	negs	r3, r3
    if ((Motor0_BLDC_SCALAR.motor_speed > (int32_t)Motor0_BLDC_SCALAR_HALL_CatchFree.cf_max_speed) ||
 8022460:	429a      	cmp	r2, r3
 8022462:	da06      	bge.n	8022472 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x3e>
    {
#if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL) && (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U))
      Motor0_BLDC_SCALAR_Ramp.set_value = Motor0_BLDC_SCALAR.motor_speed;
 8022464:	4b17      	ldr	r3, [pc, #92]	; (80224c4 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 8022466:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8022468:	4a17      	ldr	r2, [pc, #92]	; (80224c8 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x94>)
 802246a:	6013      	str	r3, [r2, #0]
#endif
      /* Normal operation */
      Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func();
 802246c:	f7ff ff18 	bl	80222a0 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func>
 8022470:	e023      	b.n	80224ba <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x86>
    else
    {
      /*Current amplifier bias voltage calibration*/
    #if ((MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U) || (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_AVERAGE_MEASUREMENT == 1U))
    #if (MOTOR0_BLDC_SCALAR_ENABLE_AMPLIFIER_OFFSET_CALIBRATION == 1U)
      Motor0_BLDC_SCALAR_AmpBiasVoltCalibration();
 8022472:	f7fe fa0b 	bl	802088c <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration>
      if (BLDC_SCALAR_HALL_LEARNING_FLAG_DISABLED == Motor0_BLDC_SCALAR_Hall.hall_learning_flag)
      {
        Motor0_BLDC_SCALAR_MSM_HALL_LEARNING_Entry_Func();
      }
    #else
      Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func();
 8022476:	f7ff ff13 	bl	80222a0 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func>
    #else
      Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func();
    #endif
    }
  }
}
 802247a:	e01e      	b.n	80224ba <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x86>
    if ((Motor0_BLDC_SCALAR.motor_speed > (int32_t)Motor0_BLDC_SCALAR_HALL_CatchFree.cf_max_speed) ||
 802247c:	4b11      	ldr	r3, [pc, #68]	; (80224c4 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 802247e:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8022480:	4b0f      	ldr	r3, [pc, #60]	; (80224c0 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x8c>)
 8022482:	699b      	ldr	r3, [r3, #24]
 8022484:	429a      	cmp	r2, r3
 8022486:	dc06      	bgt.n	8022496 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x62>
        (Motor0_BLDC_SCALAR.motor_speed < -Motor0_BLDC_SCALAR_HALL_CatchFree.cf_max_speed))
 8022488:	4b0e      	ldr	r3, [pc, #56]	; (80224c4 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 802248a:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 802248c:	4b0c      	ldr	r3, [pc, #48]	; (80224c0 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x8c>)
 802248e:	699b      	ldr	r3, [r3, #24]
 8022490:	425b      	negs	r3, r3
    if ((Motor0_BLDC_SCALAR.motor_speed > (int32_t)Motor0_BLDC_SCALAR_HALL_CatchFree.cf_max_speed) ||
 8022492:	429a      	cmp	r2, r3
 8022494:	da0c      	bge.n	80224b0 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x7c>
      Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_ERROR;
 8022496:	4b0b      	ldr	r3, [pc, #44]	; (80224c4 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 8022498:	2208      	movs	r2, #8
 802249a:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
      Motor0_BLDC_SCALAR.error_status |= (uint32_t)1 << (uint32_t)BLDC_SCALAR_EID_MOTOR_FREE_RUNNING;
 802249e:	4b09      	ldr	r3, [pc, #36]	; (80224c4 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 80224a0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80224a2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80224a6:	4a07      	ldr	r2, [pc, #28]	; (80224c4 <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x90>)
 80224a8:	6693      	str	r3, [r2, #104]	; 0x68
      Motor0_BLDC_SCALAR_MotorStop();
 80224aa:	f000 fa57 	bl	802295c <Motor0_BLDC_SCALAR_MotorStop>
 80224ae:	e004      	b.n	80224ba <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x86>
      Motor0_BLDC_SCALAR_AmpBiasVoltCalibration();
 80224b0:	f7fe f9ec 	bl	802088c <Motor0_BLDC_SCALAR_AmpBiasVoltCalibration>
      Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func();
 80224b4:	f7ff fef4 	bl	80222a0 <Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Entry_Func>
}
 80224b8:	e7ff      	b.n	80224ba <Motor0_BLDC_SCALAR_MSM_STATE_IDENTIFICATION_Exit_Func+0x86>
 80224ba:	bf00      	nop
 80224bc:	bd80      	pop	{r7, pc}
 80224be:	bf00      	nop
 80224c0:	1ffe9330 	.word	0x1ffe9330
 80224c4:	1ffe9350 	.word	0x1ffe9350
 80224c8:	1ffe9280 	.word	0x1ffe9280

080224cc <Motor0_BLDC_SCALAR_MSM_ERROR_Func>:
/*
 * ERROR state:
 * Change the state to STOP when all the errors are cleared
 */
static void Motor0_BLDC_SCALAR_MSM_ERROR_Func(void)
{
 80224cc:	b480      	push	{r7}
 80224ce:	af00      	add	r7, sp, #0
/* Change the state to STOP when all the errors are cleared */
  if (Motor0_BLDC_SCALAR.error_status == 0U)
 80224d0:	4b06      	ldr	r3, [pc, #24]	; (80224ec <Motor0_BLDC_SCALAR_MSM_ERROR_Func+0x20>)
 80224d2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80224d4:	2b00      	cmp	r3, #0
 80224d6:	d103      	bne.n	80224e0 <Motor0_BLDC_SCALAR_MSM_ERROR_Func+0x14>
  {
    Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_STOP;
 80224d8:	4b04      	ldr	r3, [pc, #16]	; (80224ec <Motor0_BLDC_SCALAR_MSM_ERROR_Func+0x20>)
 80224da:	2200      	movs	r2, #0
 80224dc:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
  }
}
 80224e0:	bf00      	nop
 80224e2:	46bd      	mov	sp, r7
 80224e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80224e8:	4770      	bx	lr
 80224ea:	bf00      	nop
 80224ec:	1ffe9350 	.word	0x1ffe9350

080224f0 <XMC_POSIF_HSC_GetExpectedPattern>:
{
 80224f0:	b480      	push	{r7}
 80224f2:	b083      	sub	sp, #12
 80224f4:	af00      	add	r7, sp, #0
 80224f6:	6078      	str	r0, [r7, #4]
  return ((uint8_t)((peripheral->HALP & POSIF_HALP_HEP_Msk) >> POSIF_HALP_HEP_Pos));
 80224f8:	687b      	ldr	r3, [r7, #4]
 80224fa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80224fc:	08db      	lsrs	r3, r3, #3
 80224fe:	b2db      	uxtb	r3, r3
 8022500:	f003 0307 	and.w	r3, r3, #7
 8022504:	b2db      	uxtb	r3, r3
}
 8022506:	4618      	mov	r0, r3
 8022508:	370c      	adds	r7, #12
 802250a:	46bd      	mov	sp, r7
 802250c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022510:	4770      	bx	lr

08022512 <XMC_POSIF_HSC_SetHallPatterns>:
{
 8022512:	b480      	push	{r7}
 8022514:	b083      	sub	sp, #12
 8022516:	af00      	add	r7, sp, #0
 8022518:	6078      	str	r0, [r7, #4]
 802251a:	460b      	mov	r3, r1
 802251c:	70fb      	strb	r3, [r7, #3]
  peripheral->HALPS = (uint32_t)(pattern_mask & (POSIF_HALPS_HCPS_Msk | POSIF_HALPS_HEPS_Msk));
 802251e:	78fb      	ldrb	r3, [r7, #3]
 8022520:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 8022524:	687b      	ldr	r3, [r7, #4]
 8022526:	635a      	str	r2, [r3, #52]	; 0x34
}
 8022528:	bf00      	nop
 802252a:	370c      	adds	r7, #12
 802252c:	46bd      	mov	sp, r7
 802252e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022532:	4770      	bx	lr

08022534 <XMC_POSIF_HSC_UpdateHallPattern>:
{
 8022534:	b480      	push	{r7}
 8022536:	b083      	sub	sp, #12
 8022538:	af00      	add	r7, sp, #0
 802253a:	6078      	str	r0, [r7, #4]
  peripheral->MCMS = (uint32_t)POSIF_MCMS_STHR_Msk;
 802253c:	687b      	ldr	r3, [r7, #4]
 802253e:	2202      	movs	r2, #2
 8022540:	649a      	str	r2, [r3, #72]	; 0x48
}
 8022542:	bf00      	nop
 8022544:	370c      	adds	r7, #12
 8022546:	46bd      	mov	sp, r7
 8022548:	f85d 7b04 	ldr.w	r7, [sp], #4
 802254c:	4770      	bx	lr

0802254e <XMC_POSIF_MCM_SetMultiChannelPattern>:
{
 802254e:	b480      	push	{r7}
 8022550:	b083      	sub	sp, #12
 8022552:	af00      	add	r7, sp, #0
 8022554:	6078      	str	r0, [r7, #4]
 8022556:	460b      	mov	r3, r1
 8022558:	807b      	strh	r3, [r7, #2]
  peripheral->MCSM = pattern;
 802255a:	887a      	ldrh	r2, [r7, #2]
 802255c:	687b      	ldr	r3, [r7, #4]
 802255e:	645a      	str	r2, [r3, #68]	; 0x44
}
 8022560:	bf00      	nop
 8022562:	370c      	adds	r7, #12
 8022564:	46bd      	mov	sp, r7
 8022566:	f85d 7b04 	ldr.w	r7, [sp], #4
 802256a:	4770      	bx	lr

0802256c <XMC_POSIF_MCM_GetMultiChannelPattern>:
{
 802256c:	b480      	push	{r7}
 802256e:	b083      	sub	sp, #12
 8022570:	af00      	add	r7, sp, #0
 8022572:	6078      	str	r0, [r7, #4]
  return ((uint16_t)(peripheral->MCM & (uint32_t)POSIF_MCM_MCMP_Msk));
 8022574:	687b      	ldr	r3, [r7, #4]
 8022576:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8022578:	b29b      	uxth	r3, r3
}
 802257a:	4618      	mov	r0, r3
 802257c:	370c      	adds	r7, #12
 802257e:	46bd      	mov	sp, r7
 8022580:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022584:	4770      	bx	lr

08022586 <XMC_POSIF_MCM_GetShadowMultiChannelPattern>:
{
 8022586:	b480      	push	{r7}
 8022588:	b083      	sub	sp, #12
 802258a:	af00      	add	r7, sp, #0
 802258c:	6078      	str	r0, [r7, #4]
  return ((uint16_t)(peripheral->MCSM & (uint32_t)POSIF_MCSM_MCMPS_Msk));
 802258e:	687b      	ldr	r3, [r7, #4]
 8022590:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8022592:	b29b      	uxth	r3, r3
}
 8022594:	4618      	mov	r0, r3
 8022596:	370c      	adds	r7, #12
 8022598:	46bd      	mov	sp, r7
 802259a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802259e:	4770      	bx	lr

080225a0 <XMC_POSIF_MCM_UpdateMultiChannelPattern>:
{
 80225a0:	b480      	push	{r7}
 80225a2:	b083      	sub	sp, #12
 80225a4:	af00      	add	r7, sp, #0
 80225a6:	6078      	str	r0, [r7, #4]
  peripheral->MCMS |= (uint32_t)POSIF_MCMS_STMR_Msk;
 80225a8:	687b      	ldr	r3, [r7, #4]
 80225aa:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80225ac:	f043 0204 	orr.w	r2, r3, #4
 80225b0:	687b      	ldr	r3, [r7, #4]
 80225b2:	649a      	str	r2, [r3, #72]	; 0x48
}
 80225b4:	bf00      	nop
 80225b6:	370c      	adds	r7, #12
 80225b8:	46bd      	mov	sp, r7
 80225ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80225be:	4770      	bx	lr

080225c0 <XMC_POSIF_DisableEvent>:
{
 80225c0:	b480      	push	{r7}
 80225c2:	b083      	sub	sp, #12
 80225c4:	af00      	add	r7, sp, #0
 80225c6:	6078      	str	r0, [r7, #4]
 80225c8:	460b      	mov	r3, r1
 80225ca:	70fb      	strb	r3, [r7, #3]
  peripheral->PFLGE &= ~((uint32_t)1 << (uint8_t)event);
 80225cc:	687b      	ldr	r3, [r7, #4]
 80225ce:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80225d0:	78fb      	ldrb	r3, [r7, #3]
 80225d2:	2101      	movs	r1, #1
 80225d4:	fa01 f303 	lsl.w	r3, r1, r3
 80225d8:	43db      	mvns	r3, r3
 80225da:	401a      	ands	r2, r3
 80225dc:	687b      	ldr	r3, [r7, #4]
 80225de:	675a      	str	r2, [r3, #116]	; 0x74
}
 80225e0:	bf00      	nop
 80225e2:	370c      	adds	r7, #12
 80225e4:	46bd      	mov	sp, r7
 80225e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80225ea:	4770      	bx	lr

080225ec <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern>:
 *
 * \par<b>Description</b><br>
 * Configures \a MCSM register with Multi-Channel Pattern.\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern(uint16_t pattern)
{
 80225ec:	b580      	push	{r7, lr}
 80225ee:	b082      	sub	sp, #8
 80225f0:	af00      	add	r7, sp, #0
 80225f2:	4603      	mov	r3, r0
 80225f4:	80fb      	strh	r3, [r7, #6]

  XMC_POSIF_MCM_SetMultiChannelPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE, pattern);
 80225f6:	88fb      	ldrh	r3, [r7, #6]
 80225f8:	4619      	mov	r1, r3
 80225fa:	4803      	ldr	r0, [pc, #12]	; (8022608 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern+0x1c>)
 80225fc:	f7ff ffa7 	bl	802254e <XMC_POSIF_MCM_SetMultiChannelPattern>

}
 8022600:	bf00      	nop
 8022602:	3708      	adds	r7, #8
 8022604:	46bd      	mov	sp, r7
 8022606:	bd80      	pop	{r7, pc}
 8022608:	40028000 	.word	0x40028000

0802260c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateMultiChannelPattern>:
 *
 * \par<b>Description</b><br>
 * Performs shadow transfer of the Multi-Channel Pattern register by configuring.\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateMultiChannelPattern(void)
{
 802260c:	b580      	push	{r7, lr}
 802260e:	af00      	add	r7, sp, #0
  XMC_POSIF_MCM_UpdateMultiChannelPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8022610:	4802      	ldr	r0, [pc, #8]	; (802261c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateMultiChannelPattern+0x10>)
 8022612:	f7ff ffc5 	bl	80225a0 <XMC_POSIF_MCM_UpdateMultiChannelPattern>
}
 8022616:	bf00      	nop
 8022618:	bd80      	pop	{r7, pc}
 802261a:	bf00      	nop
 802261c:	40028000 	.word	0x40028000

08022620 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern>:
 *
 * \par<b>Description</b><br>
 * Returns configured multi channel pattern of \a peripheral. \n
 */
__STATIC_INLINE uint16_t Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern(void)
{
 8022620:	b580      	push	{r7, lr}
 8022622:	b082      	sub	sp, #8
 8022624:	af00      	add	r7, sp, #0
  uint16_t pattern;
  pattern = XMC_POSIF_MCM_GetMultiChannelPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8022626:	4805      	ldr	r0, [pc, #20]	; (802263c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern+0x1c>)
 8022628:	f7ff ffa0 	bl	802256c <XMC_POSIF_MCM_GetMultiChannelPattern>
 802262c:	4603      	mov	r3, r0
 802262e:	80fb      	strh	r3, [r7, #6]
  return(pattern);
 8022630:	88fb      	ldrh	r3, [r7, #6]
}
 8022632:	4618      	mov	r0, r3
 8022634:	3708      	adds	r7, #8
 8022636:	46bd      	mov	sp, r7
 8022638:	bd80      	pop	{r7, pc}
 802263a:	bf00      	nop
 802263c:	40028000 	.word	0x40028000

08022640 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern>:
 *
 * \par<b>Description</b><br>
 * Returns configured multi channel pattern in shadow register of \a peripheral. \n
 */
__STATIC_INLINE uint16_t Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern(void)
{
 8022640:	b580      	push	{r7, lr}
 8022642:	b082      	sub	sp, #8
 8022644:	af00      	add	r7, sp, #0
  uint16_t pattern;
  pattern = XMC_POSIF_MCM_GetShadowMultiChannelPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8022646:	4805      	ldr	r0, [pc, #20]	; (802265c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern+0x1c>)
 8022648:	f7ff ff9d 	bl	8022586 <XMC_POSIF_MCM_GetShadowMultiChannelPattern>
 802264c:	4603      	mov	r3, r0
 802264e:	80fb      	strh	r3, [r7, #6]
  return(pattern);
 8022650:	88fb      	ldrh	r3, [r7, #6]
}
 8022652:	4618      	mov	r0, r3
 8022654:	3708      	adds	r7, #8
 8022656:	46bd      	mov	sp, r7
 8022658:	bd80      	pop	{r7, pc}
 802265a:	bf00      	nop
 802265c:	40028000 	.word	0x40028000

08022660 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern>:
 *
 * \par<b>Description</b><br>
 * Configures current and expected hall pattern of \a peripheral. \n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(uint8_t pattern)
{
 8022660:	b580      	push	{r7, lr}
 8022662:	b082      	sub	sp, #8
 8022664:	af00      	add	r7, sp, #0
 8022666:	4603      	mov	r3, r0
 8022668:	71fb      	strb	r3, [r7, #7]
  XMC_POSIF_HSC_SetHallPatterns(MOTOR0_BLDC_SCALAR_POSIF_MODULE, pattern);
 802266a:	79fb      	ldrb	r3, [r7, #7]
 802266c:	4619      	mov	r1, r3
 802266e:	4803      	ldr	r0, [pc, #12]	; (802267c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern+0x1c>)
 8022670:	f7ff ff4f 	bl	8022512 <XMC_POSIF_HSC_SetHallPatterns>
}
 8022674:	bf00      	nop
 8022676:	3708      	adds	r7, #8
 8022678:	46bd      	mov	sp, r7
 802267a:	bd80      	pop	{r7, pc}
 802267c:	40028000 	.word	0x40028000

08022680 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern>:
 * \par<b>Description</b><br>
 * The transfer of hall sensor pattern shadow registers content to the hall sensor pattern register happens
 * on hardware trigger.
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern(void)
{
 8022680:	b580      	push	{r7, lr}
 8022682:	af00      	add	r7, sp, #0
  XMC_POSIF_HSC_UpdateHallPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 8022684:	4802      	ldr	r0, [pc, #8]	; (8022690 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern+0x10>)
 8022686:	f7ff ff55 	bl	8022534 <XMC_POSIF_HSC_UpdateHallPattern>
}
 802268a:	bf00      	nop
 802268c:	bd80      	pop	{r7, pc}
 802268e:	bf00      	nop
 8022690:	40028000 	.word	0x40028000

08022694 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern>:
 *
 * \par<b>Description</b><br>
 * Retrieves the expected hall sensor pattern from \a HALP register's \a HEP bit field of \a peripheral.\n
 */
__STATIC_INLINE uint8_t Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern(void)
{
 8022694:	b580      	push	{r7, lr}
 8022696:	b082      	sub	sp, #8
 8022698:	af00      	add	r7, sp, #0
  uint8_t pattern;
  pattern = XMC_POSIF_HSC_GetExpectedPattern(MOTOR0_BLDC_SCALAR_POSIF_MODULE);
 802269a:	4805      	ldr	r0, [pc, #20]	; (80226b0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern+0x1c>)
 802269c:	f7ff ff28 	bl	80224f0 <XMC_POSIF_HSC_GetExpectedPattern>
 80226a0:	4603      	mov	r3, r0
 80226a2:	71fb      	strb	r3, [r7, #7]
  return(pattern);
 80226a4:	79fb      	ldrb	r3, [r7, #7]
}
 80226a6:	4618      	mov	r0, r3
 80226a8:	3708      	adds	r7, #8
 80226aa:	46bd      	mov	sp, r7
 80226ac:	bd80      	pop	{r7, pc}
 80226ae:	bf00      	nop
 80226b0:	40028000 	.word	0x40028000

080226b4 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent>:
 *
 * \par<b>Description</b><br>
 * Disables event generation of peripheral.\n
 */
__STATIC_INLINE void Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent(const XMC_POSIF_IRQ_EVENT_t event)
{
 80226b4:	b580      	push	{r7, lr}
 80226b6:	b082      	sub	sp, #8
 80226b8:	af00      	add	r7, sp, #0
 80226ba:	4603      	mov	r3, r0
 80226bc:	71fb      	strb	r3, [r7, #7]
  XMC_POSIF_DisableEvent(MOTOR0_BLDC_SCALAR_POSIF_MODULE, event);
 80226be:	79fb      	ldrb	r3, [r7, #7]
 80226c0:	4619      	mov	r1, r3
 80226c2:	4803      	ldr	r0, [pc, #12]	; (80226d0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent+0x1c>)
 80226c4:	f7ff ff7c 	bl	80225c0 <XMC_POSIF_DisableEvent>
}
 80226c8:	bf00      	nop
 80226ca:	3708      	adds	r7, #8
 80226cc:	46bd      	mov	sp, r7
 80226ce:	bd80      	pop	{r7, pc}
 80226d0:	40028000 	.word	0x40028000

080226d4 <Motor0_BLDC_SCALAR_State_Identification>:
  Motor0_BLDC_SCALAR_PWM_BC.shadow_modulation_ptr(mcmval, mcmshadow);
}

#if (MOTOR0_BLDC_SCALAR_ENABLE_CATCH_FREE == 1U)
BLDC_SCALAR_STATE_IDENTIFICATION_t Motor0_BLDC_SCALAR_State_Identification(void)
{
 80226d4:	b580      	push	{r7, lr}
 80226d6:	b082      	sub	sp, #8
 80226d8:	af00      	add	r7, sp, #0
  BLDC_SCALAR_STATE_IDENTIFICATION_t status = BLDC_SCALAR_STATE_IDENTIFICATION_PROGRESS;
 80226da:	2300      	movs	r3, #0
 80226dc:	71fb      	strb	r3, [r7, #7]
  uint32_t speed;
  /* 3 hall events are detected */
  if (Motor0_BLDC_SCALAR_HALL_CatchFree.state_identification_done == 1U)
 80226de:	4b21      	ldr	r3, [pc, #132]	; (8022764 <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 80226e0:	781b      	ldrb	r3, [r3, #0]
 80226e2:	2b01      	cmp	r3, #1
 80226e4:	d125      	bne.n	8022732 <Motor0_BLDC_SCALAR_State_Identification+0x5e>
  {
    /* Calculate the speed and change the status */
    Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent(XMC_POSIF_IRQ_EVENT_CHE);
 80226e6:	2000      	movs	r0, #0
 80226e8:	f7ff ffe4 	bl	80226b4 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent>
    Motor0_BLDC_SCALAR_HALL_CatchFree.cf_capval = (Motor0_BLDC_SCALAR_HALL_CatchFree.cf_capval >> 1U) * BLDC_SCALAR_HALL_EVENTS_PER_CYCLE;
 80226ec:	4b1d      	ldr	r3, [pc, #116]	; (8022764 <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 80226ee:	685b      	ldr	r3, [r3, #4]
 80226f0:	085a      	lsrs	r2, r3, #1
 80226f2:	4613      	mov	r3, r2
 80226f4:	005b      	lsls	r3, r3, #1
 80226f6:	4413      	add	r3, r2
 80226f8:	005b      	lsls	r3, r3, #1
 80226fa:	461a      	mov	r2, r3
 80226fc:	4b19      	ldr	r3, [pc, #100]	; (8022764 <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 80226fe:	605a      	str	r2, [r3, #4]
    speed = (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speed_constant / (Motor0_BLDC_SCALAR_HALL_CatchFree.cf_capval));
 8022700:	4b19      	ldr	r3, [pc, #100]	; (8022768 <Motor0_BLDC_SCALAR_State_Identification+0x94>)
 8022702:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8022704:	4b17      	ldr	r3, [pc, #92]	; (8022764 <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 8022706:	685b      	ldr	r3, [r3, #4]
 8022708:	fbb2 f3f3 	udiv	r3, r2, r3
 802270c:	603b      	str	r3, [r7, #0]
    speed = ((speed * Motor0_BLDC_SCALAR.speed_mech_scale) >> BLDC_SCALAR_SPEED_SCALE_RES);
 802270e:	4b17      	ldr	r3, [pc, #92]	; (802276c <Motor0_BLDC_SCALAR_State_Identification+0x98>)
 8022710:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8022714:	683a      	ldr	r2, [r7, #0]
 8022716:	fb02 f303 	mul.w	r3, r2, r3
 802271a:	0a9b      	lsrs	r3, r3, #10
 802271c:	603b      	str	r3, [r7, #0]
    Motor0_BLDC_SCALAR.motor_speed = (int32_t)((int32_t)speed * Motor0_BLDC_SCALAR_HALL_CatchFree.identified_direction);
 802271e:	4b11      	ldr	r3, [pc, #68]	; (8022764 <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 8022720:	68db      	ldr	r3, [r3, #12]
 8022722:	683a      	ldr	r2, [r7, #0]
 8022724:	fb02 f303 	mul.w	r3, r2, r3
 8022728:	4a10      	ldr	r2, [pc, #64]	; (802276c <Motor0_BLDC_SCALAR_State_Identification+0x98>)
 802272a:	66d3      	str	r3, [r2, #108]	; 0x6c
    status = BLDC_SCALAR_STATE_IDENTIFICATION_COMPLETED;
 802272c:	2301      	movs	r3, #1
 802272e:	71fb      	strb	r3, [r7, #7]
 8022730:	e012      	b.n	8022758 <Motor0_BLDC_SCALAR_State_Identification+0x84>
  }
  else
  {
    /* Wait for timeout */
    Motor0_BLDC_SCALAR_HALL_CatchFree.catch_free_wait_counter++;
 8022732:	4b0c      	ldr	r3, [pc, #48]	; (8022764 <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 8022734:	689b      	ldr	r3, [r3, #8]
 8022736:	3301      	adds	r3, #1
 8022738:	4a0a      	ldr	r2, [pc, #40]	; (8022764 <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 802273a:	6093      	str	r3, [r2, #8]
    if (Motor0_BLDC_SCALAR_HALL_CatchFree.catch_free_wait_counter >= Motor0_BLDC_SCALAR_HALL_CatchFree.cf_detection_timeout)
 802273c:	4b09      	ldr	r3, [pc, #36]	; (8022764 <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 802273e:	689a      	ldr	r2, [r3, #8]
 8022740:	4b08      	ldr	r3, [pc, #32]	; (8022764 <Motor0_BLDC_SCALAR_State_Identification+0x90>)
 8022742:	69db      	ldr	r3, [r3, #28]
 8022744:	429a      	cmp	r2, r3
 8022746:	d307      	bcc.n	8022758 <Motor0_BLDC_SCALAR_State_Identification+0x84>
    {
      Motor0_BLDC_SCALAR.motor_speed = 0;
 8022748:	4b08      	ldr	r3, [pc, #32]	; (802276c <Motor0_BLDC_SCALAR_State_Identification+0x98>)
 802274a:	2200      	movs	r2, #0
 802274c:	66da      	str	r2, [r3, #108]	; 0x6c
      Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent(XMC_POSIF_IRQ_EVENT_CHE);
 802274e:	2000      	movs	r0, #0
 8022750:	f7ff ffb0 	bl	80226b4 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_DisableEvent>
      status = BLDC_SCALAR_STATE_IDENTIFICATION_COMPLETED;
 8022754:	2301      	movs	r3, #1
 8022756:	71fb      	strb	r3, [r7, #7]
    }
  }
  return status;
 8022758:	79fb      	ldrb	r3, [r7, #7]
}
 802275a:	4618      	mov	r0, r3
 802275c:	3708      	adds	r7, #8
 802275e:	46bd      	mov	sp, r7
 8022760:	bd80      	pop	{r7, pc}
 8022762:	bf00      	nop
 8022764:	1ffe9330 	.word	0x1ffe9330
 8022768:	1ffe92bc 	.word	0x1ffe92bc
 802276c:	1ffe9350 	.word	0x1ffe9350

08022770 <Motor0_BLDC_SCALAR_MotorParamInit>:
 **********************************************************************************************************************/


/* Reset and Initialize of the motor control parameters */
void Motor0_BLDC_SCALAR_MotorParamInit(void)
{
 8022770:	b480      	push	{r7}
 8022772:	b083      	sub	sp, #12
 8022774:	af00      	add	r7, sp, #0
#endif
#if ((MOTOR0_BLDC_SCALAR_VADC_ENABLE_POTENTIOMETER_MEASUREMENT == 1U) && (MOTOR0_BLDC_SCALAR_ENABLE_BIDIRECTIONAL_CTRL == 1U))
  volatile uint32_t adc_conversion_delay;  /* wait for the conversion delay */
#endif
  /* Reset runtime control parameters */
  Motor0_BLDC_SCALAR.amplitude               = 0U;
 8022776:	4b2b      	ldr	r3, [pc, #172]	; (8022824 <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 8022778:	2200      	movs	r2, #0
 802277a:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  Motor0_BLDC_SCALAR.motor_speed             = 0;
 802277e:	4b29      	ldr	r3, [pc, #164]	; (8022824 <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 8022780:	2200      	movs	r2, #0
 8022782:	66da      	str	r2, [r3, #108]	; 0x6c
  Motor0_BLDC_SCALAR.motor_current           = 0;
 8022784:	4b27      	ldr	r3, [pc, #156]	; (8022824 <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 8022786:	2200      	movs	r2, #0
 8022788:	671a      	str	r2, [r3, #112]	; 0x70
  Motor0_BLDC_SCALAR.motor_average_current   = 0;
 802278a:	4b26      	ldr	r3, [pc, #152]	; (8022824 <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 802278c:	2200      	movs	r2, #0
 802278e:	675a      	str	r2, [r3, #116]	; 0x74
  Motor0_BLDC_SCALAR.dclink_voltage          = 0U;
 8022790:	4b24      	ldr	r3, [pc, #144]	; (8022824 <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 8022792:	2200      	movs	r2, #0
 8022794:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

#if (MOTOR0_BLDC_SCALAR_ENABLE_OVER_CURRENT == 1U)
  Motor0_BLDC_SCALAR.overcurrent_counter         = 0U;
 8022798:	4b22      	ldr	r3, [pc, #136]	; (8022824 <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 802279a:	2200      	movs	r2, #0
 802279c:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
#if (MOTOR0_BLDC_SCALAR_ENABLE_UNDER_OVER_VOLTAGE == 1U)
  Motor0_BLDC_SCALAR.over_under_voltage_counter  = 0U;
#endif
#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U)
#if (MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING ==1U)
  Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_counter = 0U;
 80227a0:	4b21      	ldr	r3, [pc, #132]	; (8022828 <Motor0_BLDC_SCALAR_MotorParamInit+0xb8>)
 80227a2:	2200      	movs	r2, #0
 80227a4:	61da      	str	r2, [r3, #28]
#endif /* if(MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING == 1U) */
#if(MOTOR0_BLDC_SCALAR_ENABLE_IDC_LINK_CURRENT_FILTER == 1U)
  Motor0_BLDC_SCALAR_PT1_DirectCurrent.pt1_buf = 0;          /* Reset PT1 buffer */
 80227a6:	4b21      	ldr	r3, [pc, #132]	; (802282c <Motor0_BLDC_SCALAR_MotorParamInit+0xbc>)
 80227a8:	2200      	movs	r2, #0
 80227aa:	611a      	str	r2, [r3, #16]
#endif /* if(MOTOR0_BLDC_SCALAR_ENABLE_IDC_AVERAGE_CURRENT_FILTER == 1U) */
#endif

#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_POTENTIOMETER_MEASUREMENT == 0U)
#if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL) || (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEEDCURRENT_CTRL))
  start_value = Motor0_BLDC_SCALAR_SpeedControl.user_start_speed_set;
 80227ac:	4b20      	ldr	r3, [pc, #128]	; (8022830 <Motor0_BLDC_SCALAR_MotorParamInit+0xc0>)
 80227ae:	681b      	ldr	r3, [r3, #0]
 80227b0:	607b      	str	r3, [r7, #4]
  end_value = Motor0_BLDC_SCALAR_SpeedControl.user_speed_set;
 80227b2:	4b1f      	ldr	r3, [pc, #124]	; (8022830 <Motor0_BLDC_SCALAR_MotorParamInit+0xc0>)
 80227b4:	685b      	ldr	r3, [r3, #4]
 80227b6:	603b      	str	r3, [r7, #0]
    Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_POSITIVE_DIR;
  }
#else
  /* Initialize the rotation direction */
#if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U)
  if (start_value == (int32_t)0)
 80227b8:	687b      	ldr	r3, [r7, #4]
 80227ba:	2b00      	cmp	r3, #0
 80227bc:	d10b      	bne.n	80227d6 <Motor0_BLDC_SCALAR_MotorParamInit+0x66>
  {
    if (end_value >= (int32_t)0)
 80227be:	683b      	ldr	r3, [r7, #0]
 80227c0:	2b00      	cmp	r3, #0
 80227c2:	db03      	blt.n	80227cc <Motor0_BLDC_SCALAR_MotorParamInit+0x5c>
    {
      Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_POSITIVE_DIR;
 80227c4:	4b17      	ldr	r3, [pc, #92]	; (8022824 <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 80227c6:	2201      	movs	r2, #1
 80227c8:	679a      	str	r2, [r3, #120]	; 0x78
 80227ca:	e00f      	b.n	80227ec <Motor0_BLDC_SCALAR_MotorParamInit+0x7c>
    }
    else
    {
      Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_NEGATIVE_DIR;
 80227cc:	4b15      	ldr	r3, [pc, #84]	; (8022824 <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 80227ce:	f04f 32ff 	mov.w	r2, #4294967295
 80227d2:	679a      	str	r2, [r3, #120]	; 0x78
 80227d4:	e00a      	b.n	80227ec <Motor0_BLDC_SCALAR_MotorParamInit+0x7c>
    }
  }
  else
  {
    if (start_value > (int32_t)0)
 80227d6:	687b      	ldr	r3, [r7, #4]
 80227d8:	2b00      	cmp	r3, #0
 80227da:	dd03      	ble.n	80227e4 <Motor0_BLDC_SCALAR_MotorParamInit+0x74>
    {
      Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_POSITIVE_DIR;
 80227dc:	4b11      	ldr	r3, [pc, #68]	; (8022824 <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 80227de:	2201      	movs	r2, #1
 80227e0:	679a      	str	r2, [r3, #120]	; 0x78
 80227e2:	e003      	b.n	80227ec <Motor0_BLDC_SCALAR_MotorParamInit+0x7c>
    }
    else
    {
      Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_NEGATIVE_DIR;
 80227e4:	4b0f      	ldr	r3, [pc, #60]	; (8022824 <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 80227e6:	f04f 32ff 	mov.w	r2, #4294967295
 80227ea:	679a      	str	r2, [r3, #120]	; 0x78
  {
    Motor0_BLDC_SCALAR.motor_set_direction = BLDC_SCALAR_NEGATIVE_DIR;
  }
#endif
#endif
  Motor0_BLDC_SCALAR.actual_motor_direction = (Motor0_BLDC_SCALAR.motor_set_direction);
 80227ec:	4b0d      	ldr	r3, [pc, #52]	; (8022824 <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 80227ee:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80227f0:	4a0c      	ldr	r2, [pc, #48]	; (8022824 <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 80227f2:	67d3      	str	r3, [r2, #124]	; 0x7c
#if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U)

  /* Start the ramp from start value if analog input is disabled */
#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_POTENTIOMETER_MEASUREMENT == 0U)
#if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL) || (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEEDCURRENT_CTRL))
  Motor0_BLDC_SCALAR_Ramp.set_value = Motor0_BLDC_SCALAR_SpeedControl.user_start_speed_set;
 80227f4:	4b0e      	ldr	r3, [pc, #56]	; (8022830 <Motor0_BLDC_SCALAR_MotorParamInit+0xc0>)
 80227f6:	681b      	ldr	r3, [r3, #0]
 80227f8:	4a0e      	ldr	r2, [pc, #56]	; (8022834 <Motor0_BLDC_SCALAR_MotorParamInit+0xc4>)
 80227fa:	6013      	str	r3, [r2, #0]

#endif /* if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U) */

  /* Reset the PI integral buffer */
#if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL) || (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEEDCURRENT_CTRL))
  Motor0_BLDC_SCALAR_SpeedControl_PI.ik = 0;
 80227fc:	4b0e      	ldr	r3, [pc, #56]	; (8022838 <Motor0_BLDC_SCALAR_MotorParamInit+0xc8>)
 80227fe:	2200      	movs	r2, #0
 8022800:	605a      	str	r2, [r3, #4]
  Motor0_BLDC_SCALAR_SpeedControl_PI.uk = 0;
 8022802:	4b0d      	ldr	r3, [pc, #52]	; (8022838 <Motor0_BLDC_SCALAR_MotorParamInit+0xc8>)
 8022804:	2200      	movs	r2, #0
 8022806:	601a      	str	r2, [r3, #0]
  Motor0_BLDC_SCALAR_SpeedControl_PI.sat_state = 1U;
 8022808:	4b0b      	ldr	r3, [pc, #44]	; (8022838 <Motor0_BLDC_SCALAR_MotorParamInit+0xc8>)
 802280a:	2201      	movs	r2, #1
 802280c:	755a      	strb	r2, [r3, #21]
  Motor0_BLDC_SCALAR.speedcontrol_rate_counter = 0U;
 802280e:	4b05      	ldr	r3, [pc, #20]	; (8022824 <Motor0_BLDC_SCALAR_MotorParamInit+0xb4>)
 8022810:	2200      	movs	r2, #0
 8022812:	f883 20c3 	strb.w	r2, [r3, #195]	; 0xc3
#if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_CURRENT_CTRL) || (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEEDCURRENT_CTRL))
  Motor0_BLDC_SCALAR_CurrentControl_PI.ik = 0;
  Motor0_BLDC_SCALAR_CurrentControl_PI.sat_state = 1U;
#endif

}
 8022816:	bf00      	nop
 8022818:	370c      	adds	r7, #12
 802281a:	46bd      	mov	sp, r7
 802281c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022820:	4770      	bx	lr
 8022822:	bf00      	nop
 8022824:	1ffe9350 	.word	0x1ffe9350
 8022828:	1ffe92e8 	.word	0x1ffe92e8
 802282c:	1ffe9268 	.word	0x1ffe9268
 8022830:	1ffe930c 	.word	0x1ffe930c
 8022834:	1ffe9280 	.word	0x1ffe9280
 8022838:	1ffe9250 	.word	0x1ffe9250

0802283c <Motor0_BLDC_SCALAR_MotorVarInit>:
/**********************************************************************************************************************
* API IMPLEMENTATION
**********************************************************************************************************************/
/* One time initialization of the BLDC_SCALAR data structure variables based on configuration */
static void Motor0_BLDC_SCALAR_MotorVarInit(void)
{
 802283c:	b480      	push	{r7}
 802283e:	b083      	sub	sp, #12
 8022840:	af00      	add	r7, sp, #0
#if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U)

  /* Start the ramp from start value if analog input is disabled */
#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_POTENTIOMETER_MEASUREMENT == 0U)
#if ((MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL) || (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEEDCURRENT_CTRL))
  Motor0_BLDC_SCALAR_Ramp.set_value = Motor0_BLDC_SCALAR_SpeedControl.user_start_speed_set;
 8022842:	4b31      	ldr	r3, [pc, #196]	; (8022908 <Motor0_BLDC_SCALAR_MotorVarInit+0xcc>)
 8022844:	681b      	ldr	r3, [r3, #0]
 8022846:	4a31      	ldr	r2, [pc, #196]	; (802290c <Motor0_BLDC_SCALAR_MotorVarInit+0xd0>)
 8022848:	6013      	str	r3, [r2, #0]

#endif /* end of #if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U) */

/******************start: mc_pattern table*****************************/
  /* multi-channel pattern generation for high side sync modulation */
  for (mcm_index = 0U; mcm_index <= BLDC_SCALAR_MCM_PATTERN_TABLE_SIZE; mcm_index++)
 802284a:	2300      	movs	r3, #0
 802284c:	71fb      	strb	r3, [r7, #7]
 802284e:	e050      	b.n	80228f2 <Motor0_BLDC_SCALAR_MotorVarInit+0xb6>
  {
    if ((Motor0_BLDC_SCALAR.mc_pattern[1][mcm_index] & ((uint32_t)0xFU << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_U_SLICE_NUM))) ==
 8022850:	79fb      	ldrb	r3, [r7, #7]
 8022852:	4a2f      	ldr	r2, [pc, #188]	; (8022910 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 8022854:	3310      	adds	r3, #16
 8022856:	005b      	lsls	r3, r3, #1
 8022858:	4413      	add	r3, r2
 802285a:	889b      	ldrh	r3, [r3, #4]
 802285c:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8022860:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8022864:	d10f      	bne.n	8022886 <Motor0_BLDC_SCALAR_MotorVarInit+0x4a>
        ((uint32_t)0x1U << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_U_SLICE_NUM)))
    {
      Motor0_BLDC_SCALAR.mc_pattern[0][mcm_index] =  (uint16_t)((Motor0_BLDC_SCALAR.mc_pattern[1][mcm_index] | ((uint32_t)0x2U << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_U_SLICE_NUM))));
 8022866:	79fb      	ldrb	r3, [r7, #7]
 8022868:	4a29      	ldr	r2, [pc, #164]	; (8022910 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 802286a:	3310      	adds	r3, #16
 802286c:	005b      	lsls	r3, r3, #1
 802286e:	4413      	add	r3, r2
 8022870:	889a      	ldrh	r2, [r3, #4]
 8022872:	79fb      	ldrb	r3, [r7, #7]
 8022874:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8022878:	b291      	uxth	r1, r2
 802287a:	4a25      	ldr	r2, [pc, #148]	; (8022910 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 802287c:	005b      	lsls	r3, r3, #1
 802287e:	4413      	add	r3, r2
 8022880:	460a      	mov	r2, r1
 8022882:	809a      	strh	r2, [r3, #4]
 8022884:	e032      	b.n	80228ec <Motor0_BLDC_SCALAR_MotorVarInit+0xb0>
    }
    else if ((Motor0_BLDC_SCALAR.mc_pattern[1][mcm_index] & ((uint32_t)0xFU << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_V_SLICE_NUM))) ==
 8022886:	79fb      	ldrb	r3, [r7, #7]
 8022888:	4a21      	ldr	r2, [pc, #132]	; (8022910 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 802288a:	3310      	adds	r3, #16
 802288c:	005b      	lsls	r3, r3, #1
 802288e:	4413      	add	r3, r2
 8022890:	889b      	ldrh	r3, [r3, #4]
 8022892:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8022896:	2b10      	cmp	r3, #16
 8022898:	d10f      	bne.n	80228ba <Motor0_BLDC_SCALAR_MotorVarInit+0x7e>
        ((uint32_t)0x1U << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_V_SLICE_NUM)))
    {
      Motor0_BLDC_SCALAR.mc_pattern[0][mcm_index] =  (uint16_t)((Motor0_BLDC_SCALAR.mc_pattern[1][mcm_index] | ((uint32_t)0x2U << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_V_SLICE_NUM))));
 802289a:	79fb      	ldrb	r3, [r7, #7]
 802289c:	4a1c      	ldr	r2, [pc, #112]	; (8022910 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 802289e:	3310      	adds	r3, #16
 80228a0:	005b      	lsls	r3, r3, #1
 80228a2:	4413      	add	r3, r2
 80228a4:	889a      	ldrh	r2, [r3, #4]
 80228a6:	79fb      	ldrb	r3, [r7, #7]
 80228a8:	f042 0220 	orr.w	r2, r2, #32
 80228ac:	b291      	uxth	r1, r2
 80228ae:	4a18      	ldr	r2, [pc, #96]	; (8022910 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 80228b0:	005b      	lsls	r3, r3, #1
 80228b2:	4413      	add	r3, r2
 80228b4:	460a      	mov	r2, r1
 80228b6:	809a      	strh	r2, [r3, #4]
 80228b8:	e018      	b.n	80228ec <Motor0_BLDC_SCALAR_MotorVarInit+0xb0>
    }
    else if ((Motor0_BLDC_SCALAR.mc_pattern[1][mcm_index] & ((uint32_t)0xFU << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_W_SLICE_NUM))) ==
 80228ba:	79fb      	ldrb	r3, [r7, #7]
 80228bc:	4a14      	ldr	r2, [pc, #80]	; (8022910 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 80228be:	3310      	adds	r3, #16
 80228c0:	005b      	lsls	r3, r3, #1
 80228c2:	4413      	add	r3, r2
 80228c4:	889b      	ldrh	r3, [r3, #4]
 80228c6:	f003 030f 	and.w	r3, r3, #15
 80228ca:	2b01      	cmp	r3, #1
 80228cc:	d10e      	bne.n	80228ec <Motor0_BLDC_SCALAR_MotorVarInit+0xb0>
        ((uint32_t)0x1U << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_W_SLICE_NUM)))
    {
      Motor0_BLDC_SCALAR.mc_pattern[0][mcm_index] =  (uint16_t)((Motor0_BLDC_SCALAR.mc_pattern[1][mcm_index] | ((uint32_t)0x2U << (uint32_t)(4U * MOTOR0_BLDC_SCALAR_CCU8_PH_W_SLICE_NUM))));
 80228ce:	79fb      	ldrb	r3, [r7, #7]
 80228d0:	4a0f      	ldr	r2, [pc, #60]	; (8022910 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 80228d2:	3310      	adds	r3, #16
 80228d4:	005b      	lsls	r3, r3, #1
 80228d6:	4413      	add	r3, r2
 80228d8:	889a      	ldrh	r2, [r3, #4]
 80228da:	79fb      	ldrb	r3, [r7, #7]
 80228dc:	f042 0202 	orr.w	r2, r2, #2
 80228e0:	b291      	uxth	r1, r2
 80228e2:	4a0b      	ldr	r2, [pc, #44]	; (8022910 <Motor0_BLDC_SCALAR_MotorVarInit+0xd4>)
 80228e4:	005b      	lsls	r3, r3, #1
 80228e6:	4413      	add	r3, r2
 80228e8:	460a      	mov	r2, r1
 80228ea:	809a      	strh	r2, [r3, #4]
  for (mcm_index = 0U; mcm_index <= BLDC_SCALAR_MCM_PATTERN_TABLE_SIZE; mcm_index++)
 80228ec:	79fb      	ldrb	r3, [r7, #7]
 80228ee:	3301      	adds	r3, #1
 80228f0:	71fb      	strb	r3, [r7, #7]
 80228f2:	79fb      	ldrb	r3, [r7, #7]
 80228f4:	2b0f      	cmp	r3, #15
 80228f6:	d9ab      	bls.n	8022850 <Motor0_BLDC_SCALAR_MotorVarInit+0x14>

    }
  }
  /******************end: mc_pattern table*****************************/

}
 80228f8:	bf00      	nop
 80228fa:	bf00      	nop
 80228fc:	370c      	adds	r7, #12
 80228fe:	46bd      	mov	sp, r7
 8022900:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022904:	4770      	bx	lr
 8022906:	bf00      	nop
 8022908:	1ffe930c 	.word	0x1ffe930c
 802290c:	1ffe9280 	.word	0x1ffe9280
 8022910:	1ffe9350 	.word	0x1ffe9350

08022914 <Motor0_BLDC_SCALAR_MeasurementInit>:


static void Motor0_BLDC_SCALAR_MeasurementInit(void)
{
 8022914:	b580      	push	{r7, lr}
 8022916:	af00      	add	r7, sp, #0
  /* Initialize VADC peripheral */
  Motor0_BLDC_SCALAR_VADC_Init();
 8022918:	f7fe fcbc 	bl	8021294 <Motor0_BLDC_SCALAR_VADC_Init>

  /* Channel,Result register and Queue entry configuration for configured channels */
  /* Calling sequence of below functions will decide the Queue entries sequence in corresponding Queues. */
  #if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U)
  Motor0_BLDC_SCALAR_Current_Measurment_Init();
 802291c:	f7fd ff90 	bl	8020840 <Motor0_BLDC_SCALAR_Current_Measurment_Init>
  #endif

  #if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_USER_DEF4_MEASUREMENT == 1U)
  Motor0_BLDC_SCALAR_Volt_Userdef4_Init();
  #endif
}
 8022920:	bf00      	nop
 8022922:	bd80      	pop	{r7, pc}

08022924 <Motor0_BLDC_SCALAR_Init>:


/* Initialize the required peripherals, modules and interrupts */
void Motor0_BLDC_SCALAR_Init(void)
{
 8022924:	b580      	push	{r7, lr}
 8022926:	b082      	sub	sp, #8
 8022928:	af00      	add	r7, sp, #0
  volatile uint32_t delay_counter;

  /* Initialization settling period */
  for (delay_counter = 0U; delay_counter < (uint32_t)BLDC_SCALAR_SETTLING_TIME; delay_counter++)
 802292a:	2300      	movs	r3, #0
 802292c:	607b      	str	r3, [r7, #4]
 802292e:	e002      	b.n	8022936 <Motor0_BLDC_SCALAR_Init+0x12>
 8022930:	687b      	ldr	r3, [r7, #4]
 8022932:	3301      	adds	r3, #1
 8022934:	607b      	str	r3, [r7, #4]
 8022936:	687b      	ldr	r3, [r7, #4]
 8022938:	4a07      	ldr	r2, [pc, #28]	; (8022958 <Motor0_BLDC_SCALAR_Init+0x34>)
 802293a:	4293      	cmp	r3, r2
 802293c:	d9f8      	bls.n	8022930 <Motor0_BLDC_SCALAR_Init+0xc>
  {

  }

  /* Initializes block commutation module along with the peripherals - CCU8, GPIO */
  Motor0_BLDC_SCALAR_PWM_BC_Init();
 802293e:	f7fe f841 	bl	80209c4 <Motor0_BLDC_SCALAR_PWM_BC_Init>

  /* Initializes hall feedback module along with the peripherals - POSIF, CCU4, GPIO */
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_Init();
 8022942:	f7fe f927 	bl	8020b94 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Init>

  /* Initializes measurement module along with the peripherals - VADC, GPIO */
  Motor0_BLDC_SCALAR_MeasurementInit();
 8022946:	f7ff ffe5 	bl	8022914 <Motor0_BLDC_SCALAR_MeasurementInit>

  /* Initializes BLDC_SCALAR data structure elements based on the user configurations */
  Motor0_BLDC_SCALAR_MotorVarInit();
 802294a:	f7ff ff77 	bl	802283c <Motor0_BLDC_SCALAR_MotorVarInit>

  /* Initializes systick - this will start the statemachine interrupt */
  //BLDC_SCALAR_SYSTICK_TIMER_Init();

}
 802294e:	bf00      	nop
 8022950:	3708      	adds	r7, #8
 8022952:	46bd      	mov	sp, r7
 8022954:	bd80      	pop	{r7, pc}
 8022956:	bf00      	nop
 8022958:	0007fffe 	.word	0x0007fffe

0802295c <Motor0_BLDC_SCALAR_MotorStop>:
     Motor0_BLDC_SCALAR_MSM();
  }
}

void Motor0_BLDC_SCALAR_MotorStop(void)
{
 802295c:	b580      	push	{r7, lr}
 802295e:	af00      	add	r7, sp, #0
  /*stop pwm bc*/
  Motor0_BLDC_SCALAR_PWM_BC_Stop();
 8022960:	f7fe f844 	bl	80209ec <Motor0_BLDC_SCALAR_PWM_BC_Stop>

  /*stop posif*/
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_Stop();
 8022964:	f7fe f938 	bl	8020bd8 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_Stop>

#if (MOTOR0_BLDC_SCALAR_INVERTER_ENABLE_CONF != BLDC_SCALAR_INV_DISABLED)
  /*disable inverter*/
  Motor0_BLDC_SCALAR_PWM_BC_InverterDisable();
 8022968:	f7fe f860 	bl	8020a2c <Motor0_BLDC_SCALAR_PWM_BC_InverterDisable>
#endif

  Motor0_BLDC_SCALAR.motor_speed = 0;
 802296c:	4b0c      	ldr	r3, [pc, #48]	; (80229a0 <Motor0_BLDC_SCALAR_MotorStop+0x44>)
 802296e:	2200      	movs	r2, #0
 8022970:	66da      	str	r2, [r3, #108]	; 0x6c
  Motor0_BLDC_SCALAR.motor_current = 0;
 8022972:	4b0b      	ldr	r3, [pc, #44]	; (80229a0 <Motor0_BLDC_SCALAR_MotorStop+0x44>)
 8022974:	2200      	movs	r2, #0
 8022976:	671a      	str	r2, [r3, #112]	; 0x70
  Motor0_BLDC_SCALAR.motor_average_current = 0;
 8022978:	4b09      	ldr	r3, [pc, #36]	; (80229a0 <Motor0_BLDC_SCALAR_MotorStop+0x44>)
 802297a:	2200      	movs	r2, #0
 802297c:	675a      	str	r2, [r3, #116]	; 0x74

  if (Motor0_BLDC_SCALAR.error_status != 0U)
 802297e:	4b08      	ldr	r3, [pc, #32]	; (80229a0 <Motor0_BLDC_SCALAR_MotorStop+0x44>)
 8022980:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8022982:	2b00      	cmp	r3, #0
 8022984:	d006      	beq.n	8022994 <Motor0_BLDC_SCALAR_MotorStop+0x38>
  {
    Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_ERROR;
 8022986:	4b06      	ldr	r3, [pc, #24]	; (80229a0 <Motor0_BLDC_SCALAR_MotorStop+0x44>)
 8022988:	2208      	movs	r2, #8
 802298a:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
    /*Change motor control state machine to error*/
    Motor0_BLDC_SCALAR_MSM();
 802298e:	f005 fcfb 	bl	8028388 <__Motor0_BLDC_SCALAR_MSM_veneer>
  else
  {
    /* Change motor control state machine to stop */
    Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_STOP;
  }
}
 8022992:	e003      	b.n	802299c <Motor0_BLDC_SCALAR_MotorStop+0x40>
    Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_STOP;
 8022994:	4b02      	ldr	r3, [pc, #8]	; (80229a0 <Motor0_BLDC_SCALAR_MotorStop+0x44>)
 8022996:	2200      	movs	r2, #0
 8022998:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
}
 802299c:	bf00      	nop
 802299e:	bd80      	pop	{r7, pc}
 80229a0:	1ffe9350 	.word	0x1ffe9350

080229a4 <MotorInit>:
void HallTimerProc(void *args);
void MotorStepProc(void *args);


void MotorInit (void)
{
 80229a4:	b580      	push	{r7, lr}
 80229a6:	af00      	add	r7, sp, #0
    MotorStepTimer = SYSTIMER_CreateTimer(1000, SYSTIMER_MODE_PERIODIC, MotorStepProc, NULL );
 80229a8:	2300      	movs	r3, #0
 80229aa:	4a11      	ldr	r2, [pc, #68]	; (80229f0 <MotorInit+0x4c>)
 80229ac:	2101      	movs	r1, #1
 80229ae:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80229b2:	f003 fe15 	bl	80265e0 <SYSTIMER_CreateTimer>
 80229b6:	4603      	mov	r3, r0
 80229b8:	461a      	mov	r2, r3
 80229ba:	4b0e      	ldr	r3, [pc, #56]	; (80229f4 <MotorInit+0x50>)
 80229bc:	601a      	str	r2, [r3, #0]
	HallTimer = SYSTIMER_CreateTimer(100, SYSTIMER_MODE_PERIODIC, HallTimerProc, NULL );
 80229be:	2300      	movs	r3, #0
 80229c0:	4a0d      	ldr	r2, [pc, #52]	; (80229f8 <MotorInit+0x54>)
 80229c2:	2101      	movs	r1, #1
 80229c4:	2064      	movs	r0, #100	; 0x64
 80229c6:	f003 fe0b 	bl	80265e0 <SYSTIMER_CreateTimer>
 80229ca:	4603      	mov	r3, r0
 80229cc:	461a      	mov	r2, r3
 80229ce:	4b0b      	ldr	r3, [pc, #44]	; (80229fc <MotorInit+0x58>)
 80229d0:	601a      	str	r2, [r3, #0]

	SYSTIMER_StartTimer(HallTimer);
 80229d2:	4b0a      	ldr	r3, [pc, #40]	; (80229fc <MotorInit+0x58>)
 80229d4:	681b      	ldr	r3, [r3, #0]
 80229d6:	4618      	mov	r0, r3
 80229d8:	f003 fea0 	bl	802671c <SYSTIMER_StartTimer>
	SYSTIMER_StartTimer(MotorStepTimer);
 80229dc:	4b05      	ldr	r3, [pc, #20]	; (80229f4 <MotorInit+0x50>)
 80229de:	681b      	ldr	r3, [r3, #0]
 80229e0:	4618      	mov	r0, r3
 80229e2:	f003 fe9b 	bl	802671c <SYSTIMER_StartTimer>
    Motor0_BLDC_SCALAR_Init();
 80229e6:	f7ff ff9d 	bl	8022924 <Motor0_BLDC_SCALAR_Init>
}
 80229ea:	bf00      	nop
 80229ec:	bd80      	pop	{r7, pc}
 80229ee:	bf00      	nop
 80229f0:	08022b65 	.word	0x08022b65
 80229f4:	1ffe98e4 	.word	0x1ffe98e4
 80229f8:	08022a01 	.word	0x08022a01
 80229fc:	1ffe98e8 	.word	0x1ffe98e8

08022a00 <HallTimerProc>:
	Motor0_BLDC_SCALAR_GetMotorSpeed(&drive.RAWVelocity);
	Vel = abs(drive.RAWVelocity);
	drive.Velocity = (uint16_t)Vel;
}
void HallTimerProc(void *args)
{
 8022a00:	b580      	push	{r7, lr}
 8022a02:	b084      	sub	sp, #16
 8022a04:	af00      	add	r7, sp, #0
 8022a06:	6078      	str	r0, [r7, #4]
	uint32_t hall  = 0;
 8022a08:	2300      	movs	r3, #0
 8022a0a:	60fb      	str	r3, [r7, #12]
	static uint32_t prev_hall = 0;

	hall = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition();
 8022a0c:	f7fe f8fa 	bl	8020c04 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetHallPosition>
 8022a10:	60f8      	str	r0, [r7, #12]
	if (hall != prev_hall)
 8022a12:	4b52      	ldr	r3, [pc, #328]	; (8022b5c <HallTimerProc+0x15c>)
 8022a14:	681b      	ldr	r3, [r3, #0]
 8022a16:	68fa      	ldr	r2, [r7, #12]
 8022a18:	429a      	cmp	r2, r3
 8022a1a:	f000 8090 	beq.w	8022b3e <HallTimerProc+0x13e>
	{
		if ((hall == 1) && (prev_hall == 5)) drive.RAWPosition++;
 8022a1e:	68fb      	ldr	r3, [r7, #12]
 8022a20:	2b01      	cmp	r3, #1
 8022a22:	d108      	bne.n	8022a36 <HallTimerProc+0x36>
 8022a24:	4b4d      	ldr	r3, [pc, #308]	; (8022b5c <HallTimerProc+0x15c>)
 8022a26:	681b      	ldr	r3, [r3, #0]
 8022a28:	2b05      	cmp	r3, #5
 8022a2a:	d104      	bne.n	8022a36 <HallTimerProc+0x36>
 8022a2c:	4b4c      	ldr	r3, [pc, #304]	; (8022b60 <HallTimerProc+0x160>)
 8022a2e:	689b      	ldr	r3, [r3, #8]
 8022a30:	3301      	adds	r3, #1
 8022a32:	4a4b      	ldr	r2, [pc, #300]	; (8022b60 <HallTimerProc+0x160>)
 8022a34:	6093      	str	r3, [r2, #8]
		if ((hall == 1) && (prev_hall == 3)) drive.RAWPosition--;
 8022a36:	68fb      	ldr	r3, [r7, #12]
 8022a38:	2b01      	cmp	r3, #1
 8022a3a:	d108      	bne.n	8022a4e <HallTimerProc+0x4e>
 8022a3c:	4b47      	ldr	r3, [pc, #284]	; (8022b5c <HallTimerProc+0x15c>)
 8022a3e:	681b      	ldr	r3, [r3, #0]
 8022a40:	2b03      	cmp	r3, #3
 8022a42:	d104      	bne.n	8022a4e <HallTimerProc+0x4e>
 8022a44:	4b46      	ldr	r3, [pc, #280]	; (8022b60 <HallTimerProc+0x160>)
 8022a46:	689b      	ldr	r3, [r3, #8]
 8022a48:	3b01      	subs	r3, #1
 8022a4a:	4a45      	ldr	r2, [pc, #276]	; (8022b60 <HallTimerProc+0x160>)
 8022a4c:	6093      	str	r3, [r2, #8]

		if ((hall == 3) && (prev_hall == 1)) drive.RAWPosition++;
 8022a4e:	68fb      	ldr	r3, [r7, #12]
 8022a50:	2b03      	cmp	r3, #3
 8022a52:	d108      	bne.n	8022a66 <HallTimerProc+0x66>
 8022a54:	4b41      	ldr	r3, [pc, #260]	; (8022b5c <HallTimerProc+0x15c>)
 8022a56:	681b      	ldr	r3, [r3, #0]
 8022a58:	2b01      	cmp	r3, #1
 8022a5a:	d104      	bne.n	8022a66 <HallTimerProc+0x66>
 8022a5c:	4b40      	ldr	r3, [pc, #256]	; (8022b60 <HallTimerProc+0x160>)
 8022a5e:	689b      	ldr	r3, [r3, #8]
 8022a60:	3301      	adds	r3, #1
 8022a62:	4a3f      	ldr	r2, [pc, #252]	; (8022b60 <HallTimerProc+0x160>)
 8022a64:	6093      	str	r3, [r2, #8]
		if ((hall == 3) && (prev_hall == 2)) drive.RAWPosition--;
 8022a66:	68fb      	ldr	r3, [r7, #12]
 8022a68:	2b03      	cmp	r3, #3
 8022a6a:	d108      	bne.n	8022a7e <HallTimerProc+0x7e>
 8022a6c:	4b3b      	ldr	r3, [pc, #236]	; (8022b5c <HallTimerProc+0x15c>)
 8022a6e:	681b      	ldr	r3, [r3, #0]
 8022a70:	2b02      	cmp	r3, #2
 8022a72:	d104      	bne.n	8022a7e <HallTimerProc+0x7e>
 8022a74:	4b3a      	ldr	r3, [pc, #232]	; (8022b60 <HallTimerProc+0x160>)
 8022a76:	689b      	ldr	r3, [r3, #8]
 8022a78:	3b01      	subs	r3, #1
 8022a7a:	4a39      	ldr	r2, [pc, #228]	; (8022b60 <HallTimerProc+0x160>)
 8022a7c:	6093      	str	r3, [r2, #8]

		if ((hall == 2) && (prev_hall == 3)) drive.RAWPosition++;
 8022a7e:	68fb      	ldr	r3, [r7, #12]
 8022a80:	2b02      	cmp	r3, #2
 8022a82:	d108      	bne.n	8022a96 <HallTimerProc+0x96>
 8022a84:	4b35      	ldr	r3, [pc, #212]	; (8022b5c <HallTimerProc+0x15c>)
 8022a86:	681b      	ldr	r3, [r3, #0]
 8022a88:	2b03      	cmp	r3, #3
 8022a8a:	d104      	bne.n	8022a96 <HallTimerProc+0x96>
 8022a8c:	4b34      	ldr	r3, [pc, #208]	; (8022b60 <HallTimerProc+0x160>)
 8022a8e:	689b      	ldr	r3, [r3, #8]
 8022a90:	3301      	adds	r3, #1
 8022a92:	4a33      	ldr	r2, [pc, #204]	; (8022b60 <HallTimerProc+0x160>)
 8022a94:	6093      	str	r3, [r2, #8]
		if ((hall == 2) && (prev_hall == 6)) drive.RAWPosition--;
 8022a96:	68fb      	ldr	r3, [r7, #12]
 8022a98:	2b02      	cmp	r3, #2
 8022a9a:	d108      	bne.n	8022aae <HallTimerProc+0xae>
 8022a9c:	4b2f      	ldr	r3, [pc, #188]	; (8022b5c <HallTimerProc+0x15c>)
 8022a9e:	681b      	ldr	r3, [r3, #0]
 8022aa0:	2b06      	cmp	r3, #6
 8022aa2:	d104      	bne.n	8022aae <HallTimerProc+0xae>
 8022aa4:	4b2e      	ldr	r3, [pc, #184]	; (8022b60 <HallTimerProc+0x160>)
 8022aa6:	689b      	ldr	r3, [r3, #8]
 8022aa8:	3b01      	subs	r3, #1
 8022aaa:	4a2d      	ldr	r2, [pc, #180]	; (8022b60 <HallTimerProc+0x160>)
 8022aac:	6093      	str	r3, [r2, #8]

		if ((hall == 6) && (prev_hall == 2)) drive.RAWPosition++;
 8022aae:	68fb      	ldr	r3, [r7, #12]
 8022ab0:	2b06      	cmp	r3, #6
 8022ab2:	d108      	bne.n	8022ac6 <HallTimerProc+0xc6>
 8022ab4:	4b29      	ldr	r3, [pc, #164]	; (8022b5c <HallTimerProc+0x15c>)
 8022ab6:	681b      	ldr	r3, [r3, #0]
 8022ab8:	2b02      	cmp	r3, #2
 8022aba:	d104      	bne.n	8022ac6 <HallTimerProc+0xc6>
 8022abc:	4b28      	ldr	r3, [pc, #160]	; (8022b60 <HallTimerProc+0x160>)
 8022abe:	689b      	ldr	r3, [r3, #8]
 8022ac0:	3301      	adds	r3, #1
 8022ac2:	4a27      	ldr	r2, [pc, #156]	; (8022b60 <HallTimerProc+0x160>)
 8022ac4:	6093      	str	r3, [r2, #8]
		if ((hall == 6) && (prev_hall == 4)) drive.RAWPosition--;
 8022ac6:	68fb      	ldr	r3, [r7, #12]
 8022ac8:	2b06      	cmp	r3, #6
 8022aca:	d108      	bne.n	8022ade <HallTimerProc+0xde>
 8022acc:	4b23      	ldr	r3, [pc, #140]	; (8022b5c <HallTimerProc+0x15c>)
 8022ace:	681b      	ldr	r3, [r3, #0]
 8022ad0:	2b04      	cmp	r3, #4
 8022ad2:	d104      	bne.n	8022ade <HallTimerProc+0xde>
 8022ad4:	4b22      	ldr	r3, [pc, #136]	; (8022b60 <HallTimerProc+0x160>)
 8022ad6:	689b      	ldr	r3, [r3, #8]
 8022ad8:	3b01      	subs	r3, #1
 8022ada:	4a21      	ldr	r2, [pc, #132]	; (8022b60 <HallTimerProc+0x160>)
 8022adc:	6093      	str	r3, [r2, #8]

		if ((hall == 4) && (prev_hall == 6)) drive.RAWPosition++;
 8022ade:	68fb      	ldr	r3, [r7, #12]
 8022ae0:	2b04      	cmp	r3, #4
 8022ae2:	d108      	bne.n	8022af6 <HallTimerProc+0xf6>
 8022ae4:	4b1d      	ldr	r3, [pc, #116]	; (8022b5c <HallTimerProc+0x15c>)
 8022ae6:	681b      	ldr	r3, [r3, #0]
 8022ae8:	2b06      	cmp	r3, #6
 8022aea:	d104      	bne.n	8022af6 <HallTimerProc+0xf6>
 8022aec:	4b1c      	ldr	r3, [pc, #112]	; (8022b60 <HallTimerProc+0x160>)
 8022aee:	689b      	ldr	r3, [r3, #8]
 8022af0:	3301      	adds	r3, #1
 8022af2:	4a1b      	ldr	r2, [pc, #108]	; (8022b60 <HallTimerProc+0x160>)
 8022af4:	6093      	str	r3, [r2, #8]
		if ((hall == 4) && (prev_hall == 5)) drive.RAWPosition--;
 8022af6:	68fb      	ldr	r3, [r7, #12]
 8022af8:	2b04      	cmp	r3, #4
 8022afa:	d108      	bne.n	8022b0e <HallTimerProc+0x10e>
 8022afc:	4b17      	ldr	r3, [pc, #92]	; (8022b5c <HallTimerProc+0x15c>)
 8022afe:	681b      	ldr	r3, [r3, #0]
 8022b00:	2b05      	cmp	r3, #5
 8022b02:	d104      	bne.n	8022b0e <HallTimerProc+0x10e>
 8022b04:	4b16      	ldr	r3, [pc, #88]	; (8022b60 <HallTimerProc+0x160>)
 8022b06:	689b      	ldr	r3, [r3, #8]
 8022b08:	3b01      	subs	r3, #1
 8022b0a:	4a15      	ldr	r2, [pc, #84]	; (8022b60 <HallTimerProc+0x160>)
 8022b0c:	6093      	str	r3, [r2, #8]

		if ((hall == 5) && (prev_hall == 4)) drive.RAWPosition++;
 8022b0e:	68fb      	ldr	r3, [r7, #12]
 8022b10:	2b05      	cmp	r3, #5
 8022b12:	d108      	bne.n	8022b26 <HallTimerProc+0x126>
 8022b14:	4b11      	ldr	r3, [pc, #68]	; (8022b5c <HallTimerProc+0x15c>)
 8022b16:	681b      	ldr	r3, [r3, #0]
 8022b18:	2b04      	cmp	r3, #4
 8022b1a:	d104      	bne.n	8022b26 <HallTimerProc+0x126>
 8022b1c:	4b10      	ldr	r3, [pc, #64]	; (8022b60 <HallTimerProc+0x160>)
 8022b1e:	689b      	ldr	r3, [r3, #8]
 8022b20:	3301      	adds	r3, #1
 8022b22:	4a0f      	ldr	r2, [pc, #60]	; (8022b60 <HallTimerProc+0x160>)
 8022b24:	6093      	str	r3, [r2, #8]
		if ((hall == 5) && (prev_hall == 1)) drive.RAWPosition--;
 8022b26:	68fb      	ldr	r3, [r7, #12]
 8022b28:	2b05      	cmp	r3, #5
 8022b2a:	d108      	bne.n	8022b3e <HallTimerProc+0x13e>
 8022b2c:	4b0b      	ldr	r3, [pc, #44]	; (8022b5c <HallTimerProc+0x15c>)
 8022b2e:	681b      	ldr	r3, [r3, #0]
 8022b30:	2b01      	cmp	r3, #1
 8022b32:	d104      	bne.n	8022b3e <HallTimerProc+0x13e>
 8022b34:	4b0a      	ldr	r3, [pc, #40]	; (8022b60 <HallTimerProc+0x160>)
 8022b36:	689b      	ldr	r3, [r3, #8]
 8022b38:	3b01      	subs	r3, #1
 8022b3a:	4a09      	ldr	r2, [pc, #36]	; (8022b60 <HallTimerProc+0x160>)
 8022b3c:	6093      	str	r3, [r2, #8]
	}
	prev_hall = hall;
 8022b3e:	4a07      	ldr	r2, [pc, #28]	; (8022b5c <HallTimerProc+0x15c>)
 8022b40:	68fb      	ldr	r3, [r7, #12]
 8022b42:	6013      	str	r3, [r2, #0]
	drive.Position = (uint16_t) abs(drive.RAWPosition);
 8022b44:	4b06      	ldr	r3, [pc, #24]	; (8022b60 <HallTimerProc+0x160>)
 8022b46:	689b      	ldr	r3, [r3, #8]
 8022b48:	2b00      	cmp	r3, #0
 8022b4a:	bfb8      	it	lt
 8022b4c:	425b      	neglt	r3, r3
 8022b4e:	b29a      	uxth	r2, r3
 8022b50:	4b03      	ldr	r3, [pc, #12]	; (8022b60 <HallTimerProc+0x160>)
 8022b52:	801a      	strh	r2, [r3, #0]
}
 8022b54:	bf00      	nop
 8022b56:	3710      	adds	r7, #16
 8022b58:	46bd      	mov	sp, r7
 8022b5a:	bd80      	pop	{r7, pc}
 8022b5c:	1ffe98ec 	.word	0x1ffe98ec
 8022b60:	1ffe98cc 	.word	0x1ffe98cc

08022b64 <MotorStepProc>:

void MotorStepProc(void *args)
{
 8022b64:	b580      	push	{r7, lr}
 8022b66:	b082      	sub	sp, #8
 8022b68:	af00      	add	r7, sp, #0
 8022b6a:	6078      	str	r0, [r7, #4]
	Motor0_BLDC_SCALAR_MSM();
 8022b6c:	f005 fc0c 	bl	8028388 <__Motor0_BLDC_SCALAR_MSM_veneer>
}
 8022b70:	bf00      	nop
 8022b72:	3708      	adds	r7, #8
 8022b74:	46bd      	mov	sp, r7
 8022b76:	bd80      	pop	{r7, pc}

08022b78 <CAN0_3_IRQHandler>:
// private vars
uint16_t VehicleSpeed;
uint16_t VehicleSpeedThreshold;

void DSC1IsrHandler(void)
{
 8022b78:	b480      	push	{r7}
 8022b7a:	b085      	sub	sp, #20
 8022b7c:	af00      	add	r7, sp, #0
	XMC_CAN_MO_t* Msg;
	Msg = CAN_EXT_LMO_01_Config.mo_ptr;
 8022b7e:	4b58      	ldr	r3, [pc, #352]	; (8022ce0 <CAN0_3_IRQHandler+0x168>)
 8022b80:	681b      	ldr	r3, [r3, #0]
 8022b82:	60fb      	str	r3, [r7, #12]

	uint32_t data[2] = {0,0};
 8022b84:	2300      	movs	r3, #0
 8022b86:	607b      	str	r3, [r7, #4]
 8022b88:	2300      	movs	r3, #0
 8022b8a:	60bb      	str	r3, [r7, #8]

	if(Msg->can_identifier == (DSC1_ID_BASE + ((Presets.DOOR_NUMBER - 1) * 0x0100)) )
 8022b8c:	68fb      	ldr	r3, [r7, #12]
 8022b8e:	685b      	ldr	r3, [r3, #4]
 8022b90:	f3c3 031c 	ubfx	r3, r3, #0, #29
 8022b94:	4619      	mov	r1, r3
 8022b96:	4b53      	ldr	r3, [pc, #332]	; (8022ce4 <CAN0_3_IRQHandler+0x16c>)
 8022b98:	689b      	ldr	r3, [r3, #8]
 8022b9a:	3b01      	subs	r3, #1
 8022b9c:	021a      	lsls	r2, r3, #8
 8022b9e:	4b52      	ldr	r3, [pc, #328]	; (8022ce8 <CAN0_3_IRQHandler+0x170>)
 8022ba0:	4413      	add	r3, r2
 8022ba2:	4299      	cmp	r1, r3
 8022ba4:	d102      	bne.n	8022bac <CAN0_3_IRQHandler+0x34>
	{
		data[0] = Msg->can_data[0];
 8022ba6:	68fb      	ldr	r3, [r7, #12]
 8022ba8:	691b      	ldr	r3, [r3, #16]
 8022baa:	607b      	str	r3, [r7, #4]
		//data[1] = Msg->can_data[1];
	}
	//Parce to CanCmd struct


	if((data[0] & DSC1_CLOSE_CMD_Msk) && !(data[0] & DSC1_OPEN_CMD_Msk))
 8022bac:	687b      	ldr	r3, [r7, #4]
 8022bae:	f003 0302 	and.w	r3, r3, #2
 8022bb2:	2b00      	cmp	r3, #0
 8022bb4:	d008      	beq.n	8022bc8 <CAN0_3_IRQHandler+0x50>
 8022bb6:	687b      	ldr	r3, [r7, #4]
 8022bb8:	f003 0301 	and.w	r3, r3, #1
 8022bbc:	2b00      	cmp	r3, #0
 8022bbe:	d103      	bne.n	8022bc8 <CAN0_3_IRQHandler+0x50>
	{
		CanCmd.close = 1;
 8022bc0:	4b4a      	ldr	r3, [pc, #296]	; (8022cec <CAN0_3_IRQHandler+0x174>)
 8022bc2:	2201      	movs	r2, #1
 8022bc4:	701a      	strb	r2, [r3, #0]
 8022bc6:	e002      	b.n	8022bce <CAN0_3_IRQHandler+0x56>
	}
	else
	{
		CanCmd.close = 0;
 8022bc8:	4b48      	ldr	r3, [pc, #288]	; (8022cec <CAN0_3_IRQHandler+0x174>)
 8022bca:	2200      	movs	r2, #0
 8022bcc:	701a      	strb	r2, [r3, #0]
	}

	if((data[0] & DSC1_OPEN_CMD_Msk) && !(data[0] & DSC1_CLOSE_CMD_Msk))
 8022bce:	687b      	ldr	r3, [r7, #4]
 8022bd0:	f003 0301 	and.w	r3, r3, #1
 8022bd4:	2b00      	cmp	r3, #0
 8022bd6:	d008      	beq.n	8022bea <CAN0_3_IRQHandler+0x72>
 8022bd8:	687b      	ldr	r3, [r7, #4]
 8022bda:	f003 0302 	and.w	r3, r3, #2
 8022bde:	2b00      	cmp	r3, #0
 8022be0:	d103      	bne.n	8022bea <CAN0_3_IRQHandler+0x72>
	{
		CanCmd.open = 1;
 8022be2:	4b42      	ldr	r3, [pc, #264]	; (8022cec <CAN0_3_IRQHandler+0x174>)
 8022be4:	2201      	movs	r2, #1
 8022be6:	705a      	strb	r2, [r3, #1]
 8022be8:	e002      	b.n	8022bf0 <CAN0_3_IRQHandler+0x78>
	}
	else
	{
		CanCmd.open = 0;
 8022bea:	4b40      	ldr	r3, [pc, #256]	; (8022cec <CAN0_3_IRQHandler+0x174>)
 8022bec:	2200      	movs	r2, #0
 8022bee:	705a      	strb	r2, [r3, #1]
	}

	if( ((data[0] & DSC1_EXTERN_PASSENGER_BUTTON_ON_Msk) && !(data[0] & DSC1_EXTERN_PASSENGER_BUTTON_NON_Msk)) ||
 8022bf0:	687b      	ldr	r3, [r7, #4]
 8022bf2:	f003 0310 	and.w	r3, r3, #16
 8022bf6:	2b00      	cmp	r3, #0
 8022bf8:	d004      	beq.n	8022c04 <CAN0_3_IRQHandler+0x8c>
 8022bfa:	687b      	ldr	r3, [r7, #4]
 8022bfc:	f003 0320 	and.w	r3, r3, #32
 8022c00:	2b00      	cmp	r3, #0
 8022c02:	d009      	beq.n	8022c18 <CAN0_3_IRQHandler+0xa0>
		((data[0] & DSC1_INTERN_PASSENGER_BUTTON_ON_Msk) && !(data[0] & DSC1_INTERN_PASSENGER_BUTTON_NON_Msk)) )
 8022c04:	687b      	ldr	r3, [r7, #4]
 8022c06:	f003 0304 	and.w	r3, r3, #4
	if( ((data[0] & DSC1_EXTERN_PASSENGER_BUTTON_ON_Msk) && !(data[0] & DSC1_EXTERN_PASSENGER_BUTTON_NON_Msk)) ||
 8022c0a:	2b00      	cmp	r3, #0
 8022c0c:	d008      	beq.n	8022c20 <CAN0_3_IRQHandler+0xa8>
		((data[0] & DSC1_INTERN_PASSENGER_BUTTON_ON_Msk) && !(data[0] & DSC1_INTERN_PASSENGER_BUTTON_NON_Msk)) )
 8022c0e:	687b      	ldr	r3, [r7, #4]
 8022c10:	f003 0308 	and.w	r3, r3, #8
 8022c14:	2b00      	cmp	r3, #0
 8022c16:	d103      	bne.n	8022c20 <CAN0_3_IRQHandler+0xa8>
	{
		CanCmd.passengersButtonEn = 1;
 8022c18:	4b34      	ldr	r3, [pc, #208]	; (8022cec <CAN0_3_IRQHandler+0x174>)
 8022c1a:	2201      	movs	r2, #1
 8022c1c:	709a      	strb	r2, [r3, #2]
 8022c1e:	e002      	b.n	8022c26 <CAN0_3_IRQHandler+0xae>
	}
	else
	{
		CanCmd.passengersButtonEn = 0;
 8022c20:	4b32      	ldr	r3, [pc, #200]	; (8022cec <CAN0_3_IRQHandler+0x174>)
 8022c22:	2200      	movs	r2, #0
 8022c24:	709a      	strb	r2, [r3, #2]
	}

	if((data[0] & DSC1_OPEN_DRIVER_DOOR_Msk) && !(data[0] & DSC1_CLOSE_DRIVER_DOOR_Msk))
 8022c26:	687b      	ldr	r3, [r7, #4]
 8022c28:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8022c2c:	2b00      	cmp	r3, #0
 8022c2e:	d008      	beq.n	8022c42 <CAN0_3_IRQHandler+0xca>
 8022c30:	687b      	ldr	r3, [r7, #4]
 8022c32:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8022c36:	2b00      	cmp	r3, #0
 8022c38:	d103      	bne.n	8022c42 <CAN0_3_IRQHandler+0xca>
	{
		CanCmd.openDriverDoor = 1;
 8022c3a:	4b2c      	ldr	r3, [pc, #176]	; (8022cec <CAN0_3_IRQHandler+0x174>)
 8022c3c:	2201      	movs	r2, #1
 8022c3e:	70da      	strb	r2, [r3, #3]
 8022c40:	e002      	b.n	8022c48 <CAN0_3_IRQHandler+0xd0>
	}
	else
	{
		CanCmd.openDriverDoor = 0;
 8022c42:	4b2a      	ldr	r3, [pc, #168]	; (8022cec <CAN0_3_IRQHandler+0x174>)
 8022c44:	2200      	movs	r2, #0
 8022c46:	70da      	strb	r2, [r3, #3]
	}

	if((data[0] & DSC1_CLOSE_DRIVER_DOOR_Msk) && !(data[0] & DSC1_OPEN_DRIVER_DOOR_Msk))
 8022c48:	687b      	ldr	r3, [r7, #4]
 8022c4a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8022c4e:	2b00      	cmp	r3, #0
 8022c50:	d008      	beq.n	8022c64 <CAN0_3_IRQHandler+0xec>
 8022c52:	687b      	ldr	r3, [r7, #4]
 8022c54:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8022c58:	2b00      	cmp	r3, #0
 8022c5a:	d103      	bne.n	8022c64 <CAN0_3_IRQHandler+0xec>
	{
		CanCmd.closeDriverDoor = 1;
 8022c5c:	4b23      	ldr	r3, [pc, #140]	; (8022cec <CAN0_3_IRQHandler+0x174>)
 8022c5e:	2201      	movs	r2, #1
 8022c60:	711a      	strb	r2, [r3, #4]
 8022c62:	e002      	b.n	8022c6a <CAN0_3_IRQHandler+0xf2>
	}
	else
	{
		CanCmd.closeDriverDoor = 0;
 8022c64:	4b21      	ldr	r3, [pc, #132]	; (8022cec <CAN0_3_IRQHandler+0x174>)
 8022c66:	2200      	movs	r2, #0
 8022c68:	711a      	strb	r2, [r3, #4]
	}

	if((data[0] & DSC1_IGNITION_ON_Msk) && !(data[0] & DSC1_IGNITION_NON_Msk))
 8022c6a:	687b      	ldr	r3, [r7, #4]
 8022c6c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8022c70:	2b00      	cmp	r3, #0
 8022c72:	d008      	beq.n	8022c86 <CAN0_3_IRQHandler+0x10e>
 8022c74:	687b      	ldr	r3, [r7, #4]
 8022c76:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8022c7a:	2b00      	cmp	r3, #0
 8022c7c:	d103      	bne.n	8022c86 <CAN0_3_IRQHandler+0x10e>
	{
		CanCmd.ignitionOn = 1;
 8022c7e:	4b1b      	ldr	r3, [pc, #108]	; (8022cec <CAN0_3_IRQHandler+0x174>)
 8022c80:	2201      	movs	r2, #1
 8022c82:	715a      	strb	r2, [r3, #5]
 8022c84:	e002      	b.n	8022c8c <CAN0_3_IRQHandler+0x114>
	}
	else
	{
		CanCmd.ignitionOn = 0;
 8022c86:	4b19      	ldr	r3, [pc, #100]	; (8022cec <CAN0_3_IRQHandler+0x174>)
 8022c88:	2200      	movs	r2, #0
 8022c8a:	715a      	strb	r2, [r3, #5]
	}

	if((data[0] & DSC1_LINK_ON_Msk) && !(data[0] & DSC1_LINK_NON_Msk))
 8022c8c:	687b      	ldr	r3, [r7, #4]
 8022c8e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8022c92:	2b00      	cmp	r3, #0
 8022c94:	d008      	beq.n	8022ca8 <CAN0_3_IRQHandler+0x130>
 8022c96:	687b      	ldr	r3, [r7, #4]
 8022c98:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8022c9c:	2b00      	cmp	r3, #0
 8022c9e:	d103      	bne.n	8022ca8 <CAN0_3_IRQHandler+0x130>
	{
		CanCmd.linkOn = 1;
 8022ca0:	4b12      	ldr	r3, [pc, #72]	; (8022cec <CAN0_3_IRQHandler+0x174>)
 8022ca2:	2201      	movs	r2, #1
 8022ca4:	719a      	strb	r2, [r3, #6]
 8022ca6:	e002      	b.n	8022cae <CAN0_3_IRQHandler+0x136>
	}
	else
	{
		CanCmd.linkOn = 0;
 8022ca8:	4b10      	ldr	r3, [pc, #64]	; (8022cec <CAN0_3_IRQHandler+0x174>)
 8022caa:	2200      	movs	r2, #0
 8022cac:	719a      	strb	r2, [r3, #6]
	}

	if((data[0] & DSC1_PARKING_LIGHTS_ON_Msk) && !(data[0] & DSC1_PARKING_LIGHTS_NON_Msk))
 8022cae:	687b      	ldr	r3, [r7, #4]
 8022cb0:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8022cb4:	2b00      	cmp	r3, #0
 8022cb6:	d008      	beq.n	8022cca <CAN0_3_IRQHandler+0x152>
 8022cb8:	687b      	ldr	r3, [r7, #4]
 8022cba:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8022cbe:	2b00      	cmp	r3, #0
 8022cc0:	d103      	bne.n	8022cca <CAN0_3_IRQHandler+0x152>
	{
		CanCmd.parkingLightsEn = 1;
 8022cc2:	4b0a      	ldr	r3, [pc, #40]	; (8022cec <CAN0_3_IRQHandler+0x174>)
 8022cc4:	2201      	movs	r2, #1
 8022cc6:	71da      	strb	r2, [r3, #7]
 8022cc8:	e003      	b.n	8022cd2 <CAN0_3_IRQHandler+0x15a>
	}
	else
	{
		CanCmd.parkingLightsEn = 0;
 8022cca:	4b08      	ldr	r3, [pc, #32]	; (8022cec <CAN0_3_IRQHandler+0x174>)
 8022ccc:	2200      	movs	r2, #0
 8022cce:	71da      	strb	r2, [r3, #7]
	}
}
 8022cd0:	bf00      	nop
 8022cd2:	bf00      	nop
 8022cd4:	3714      	adds	r7, #20
 8022cd6:	46bd      	mov	sp, r7
 8022cd8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022cdc:	4770      	bx	lr
 8022cde:	bf00      	nop
 8022ce0:	08028a44 	.word	0x08028a44
 8022ce4:	1ffe9930 	.word	0x1ffe9930
 8022ce8:	18b6cc27 	.word	0x18b6cc27
 8022cec:	1ffe98f0 	.word	0x1ffe98f0

08022cf0 <CAN0_5_IRQHandler>:

void DSC2IsrHandler (void)
{
 8022cf0:	b480      	push	{r7}
 8022cf2:	b085      	sub	sp, #20
 8022cf4:	af00      	add	r7, sp, #0
	XMC_CAN_MO_t* Msg;
	Msg = CAN_EXT_LMO_02_Config.mo_ptr;
 8022cf6:	4b10      	ldr	r3, [pc, #64]	; (8022d38 <CAN0_5_IRQHandler+0x48>)
 8022cf8:	681b      	ldr	r3, [r3, #0]
 8022cfa:	60fb      	str	r3, [r7, #12]

	uint32_t data[2] = {0,0};
 8022cfc:	2300      	movs	r3, #0
 8022cfe:	607b      	str	r3, [r7, #4]
 8022d00:	2300      	movs	r3, #0
 8022d02:	60bb      	str	r3, [r7, #8]

	if(Msg->can_identifier == (DCS2_ID_BASE + ((Presets.DOOR_NUMBER - 1) * 0x0100)) )
 8022d04:	68fb      	ldr	r3, [r7, #12]
 8022d06:	685b      	ldr	r3, [r3, #4]
 8022d08:	f3c3 031c 	ubfx	r3, r3, #0, #29
 8022d0c:	4619      	mov	r1, r3
 8022d0e:	4b0b      	ldr	r3, [pc, #44]	; (8022d3c <CAN0_5_IRQHandler+0x4c>)
 8022d10:	689b      	ldr	r3, [r3, #8]
 8022d12:	3b01      	subs	r3, #1
 8022d14:	021a      	lsls	r2, r3, #8
 8022d16:	4b0a      	ldr	r3, [pc, #40]	; (8022d40 <CAN0_5_IRQHandler+0x50>)
 8022d18:	4413      	add	r3, r2
 8022d1a:	4299      	cmp	r1, r3
 8022d1c:	d105      	bne.n	8022d2a <CAN0_5_IRQHandler+0x3a>
	{
		data[0] = Msg->can_data[0];
 8022d1e:	68fb      	ldr	r3, [r7, #12]
 8022d20:	691b      	ldr	r3, [r3, #16]
 8022d22:	607b      	str	r3, [r7, #4]
		data[1] = Msg->can_data[1];
 8022d24:	68fb      	ldr	r3, [r7, #12]
 8022d26:	695b      	ldr	r3, [r3, #20]
 8022d28:	60bb      	str	r3, [r7, #8]
	}

	// Parce to CanPeriphControl struct
}
 8022d2a:	bf00      	nop
 8022d2c:	3714      	adds	r7, #20
 8022d2e:	46bd      	mov	sp, r7
 8022d30:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022d34:	4770      	bx	lr
 8022d36:	bf00      	nop
 8022d38:	08028a50 	.word	0x08028a50
 8022d3c:	1ffe9930 	.word	0x1ffe9930
 8022d40:	18b7cc27 	.word	0x18b7cc27

08022d44 <CAN0_6_IRQHandler>:


void DSC3IsrHandler (void)
{
 8022d44:	b480      	push	{r7}
 8022d46:	b085      	sub	sp, #20
 8022d48:	af00      	add	r7, sp, #0
	XMC_CAN_MO_t* Msg;
	Msg = CAN_EXT_LMO_03_Config.mo_ptr;
 8022d4a:	4b10      	ldr	r3, [pc, #64]	; (8022d8c <CAN0_6_IRQHandler+0x48>)
 8022d4c:	681b      	ldr	r3, [r3, #0]
 8022d4e:	60fb      	str	r3, [r7, #12]

	uint32_t data[2] = {0,0};
 8022d50:	2300      	movs	r3, #0
 8022d52:	607b      	str	r3, [r7, #4]
 8022d54:	2300      	movs	r3, #0
 8022d56:	60bb      	str	r3, [r7, #8]

	if(Msg->can_identifier == (DCS3_ID_BASE + ((Presets.DOOR_NUMBER - 1) * 0x0100)) )
 8022d58:	68fb      	ldr	r3, [r7, #12]
 8022d5a:	685b      	ldr	r3, [r3, #4]
 8022d5c:	f3c3 031c 	ubfx	r3, r3, #0, #29
 8022d60:	4619      	mov	r1, r3
 8022d62:	4b0b      	ldr	r3, [pc, #44]	; (8022d90 <CAN0_6_IRQHandler+0x4c>)
 8022d64:	689b      	ldr	r3, [r3, #8]
 8022d66:	3b01      	subs	r3, #1
 8022d68:	021a      	lsls	r2, r3, #8
 8022d6a:	4b0a      	ldr	r3, [pc, #40]	; (8022d94 <CAN0_6_IRQHandler+0x50>)
 8022d6c:	4413      	add	r3, r2
 8022d6e:	4299      	cmp	r1, r3
 8022d70:	d105      	bne.n	8022d7e <CAN0_6_IRQHandler+0x3a>
	{
		data[0] = Msg->can_data[0];
 8022d72:	68fb      	ldr	r3, [r7, #12]
 8022d74:	691b      	ldr	r3, [r3, #16]
 8022d76:	607b      	str	r3, [r7, #4]
		data[1] = Msg->can_data[1];
 8022d78:	68fb      	ldr	r3, [r7, #12]
 8022d7a:	695b      	ldr	r3, [r3, #20]
 8022d7c:	60bb      	str	r3, [r7, #8]
	}

	// don't parce yet. Need to think how it can be doing
}
 8022d7e:	bf00      	nop
 8022d80:	3714      	adds	r7, #20
 8022d82:	46bd      	mov	sp, r7
 8022d84:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022d88:	4770      	bx	lr
 8022d8a:	bf00      	nop
 8022d8c:	08028a5c 	.word	0x08028a5c
 8022d90:	1ffe9930 	.word	0x1ffe9930
 8022d94:	18efcc27 	.word	0x18efcc27

08022d98 <CAN0_2_IRQHandler>:

void CCVSIsrHandler(void)
{
 8022d98:	b480      	push	{r7}
 8022d9a:	b085      	sub	sp, #20
 8022d9c:	af00      	add	r7, sp, #0
	XMC_CAN_MO_t* Msg;
	Msg = CAN_EXT_LMO_04_Config.mo_ptr;
 8022d9e:	4b0d      	ldr	r3, [pc, #52]	; (8022dd4 <CAN0_2_IRQHandler+0x3c>)
 8022da0:	681b      	ldr	r3, [r3, #0]
 8022da2:	60fb      	str	r3, [r7, #12]

	uint32_t data[2] = {0,0};
 8022da4:	2300      	movs	r3, #0
 8022da6:	607b      	str	r3, [r7, #4]
 8022da8:	2300      	movs	r3, #0
 8022daa:	60bb      	str	r3, [r7, #8]

	if(Msg->can_identifier == CCVS_ID)
 8022dac:	68fb      	ldr	r3, [r7, #12]
 8022dae:	685b      	ldr	r3, [r3, #4]
 8022db0:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 8022db4:	4a08      	ldr	r2, [pc, #32]	; (8022dd8 <CAN0_2_IRQHandler+0x40>)
 8022db6:	4293      	cmp	r3, r2
 8022db8:	d105      	bne.n	8022dc6 <CAN0_2_IRQHandler+0x2e>
	{
		data[0] = Msg->can_data[0];
 8022dba:	68fb      	ldr	r3, [r7, #12]
 8022dbc:	691b      	ldr	r3, [r3, #16]
 8022dbe:	607b      	str	r3, [r7, #4]
		data[1] = Msg->can_data[1];
 8022dc0:	68fb      	ldr	r3, [r7, #12]
 8022dc2:	695b      	ldr	r3, [r3, #20]
 8022dc4:	60bb      	str	r3, [r7, #8]
	}
	// Parce to CanCmd.speedIsZero  throw compare with (uint16_t)Presets.VEHICLE_SPEED_THRESHOLD
}
 8022dc6:	bf00      	nop
 8022dc8:	3714      	adds	r7, #20
 8022dca:	46bd      	mov	sp, r7
 8022dcc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022dd0:	4770      	bx	lr
 8022dd2:	bf00      	nop
 8022dd4:	08028a68 	.word	0x08028a68
 8022dd8:	18fef100 	.word	0x18fef100

08022ddc <CAN0_4_IRQHandler>:

void TDIsrHandler (void)
{
 8022ddc:	b480      	push	{r7}
 8022dde:	b085      	sub	sp, #20
 8022de0:	af00      	add	r7, sp, #0
	XMC_CAN_MO_t* Msg;
	Msg = CAN_EXT_LMO_05_Config.mo_ptr;
 8022de2:	4b0d      	ldr	r3, [pc, #52]	; (8022e18 <CAN0_4_IRQHandler+0x3c>)
 8022de4:	681b      	ldr	r3, [r3, #0]
 8022de6:	60fb      	str	r3, [r7, #12]

	uint32_t data[2] = {0,0};
 8022de8:	2300      	movs	r3, #0
 8022dea:	607b      	str	r3, [r7, #4]
 8022dec:	2300      	movs	r3, #0
 8022dee:	60bb      	str	r3, [r7, #8]

	if(Msg->can_identifier == TD_ID)
 8022df0:	68fb      	ldr	r3, [r7, #12]
 8022df2:	685b      	ldr	r3, [r3, #4]
 8022df4:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 8022df8:	4a08      	ldr	r2, [pc, #32]	; (8022e1c <CAN0_4_IRQHandler+0x40>)
 8022dfa:	4293      	cmp	r3, r2
 8022dfc:	d105      	bne.n	8022e0a <CAN0_4_IRQHandler+0x2e>
	{
		data[0] = Msg->can_data[0];
 8022dfe:	68fb      	ldr	r3, [r7, #12]
 8022e00:	691b      	ldr	r3, [r3, #16]
 8022e02:	607b      	str	r3, [r7, #4]
		data[1] = Msg->can_data[1];
 8022e04:	68fb      	ldr	r3, [r7, #12]
 8022e06:	695b      	ldr	r3, [r3, #20]
 8022e08:	60bb      	str	r3, [r7, #8]
	}

	//Parce to CanTime
}
 8022e0a:	bf00      	nop
 8022e0c:	3714      	adds	r7, #20
 8022e0e:	46bd      	mov	sp, r7
 8022e10:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022e14:	4770      	bx	lr
 8022e16:	bf00      	nop
 8022e18:	08028a74 	.word	0x08028a74
 8022e1c:	18fee600 	.word	0x18fee600

08022e20 <XMC_GPIO_SetOutputHigh>:
{
 8022e20:	b480      	push	{r7}
 8022e22:	b083      	sub	sp, #12
 8022e24:	af00      	add	r7, sp, #0
 8022e26:	6078      	str	r0, [r7, #4]
 8022e28:	460b      	mov	r3, r1
 8022e2a:	70fb      	strb	r3, [r7, #3]
  port->OMR = (uint32_t)0x1U << pin;
 8022e2c:	78fb      	ldrb	r3, [r7, #3]
 8022e2e:	2201      	movs	r2, #1
 8022e30:	409a      	lsls	r2, r3
 8022e32:	687b      	ldr	r3, [r7, #4]
 8022e34:	605a      	str	r2, [r3, #4]
}
 8022e36:	bf00      	nop
 8022e38:	370c      	adds	r7, #12
 8022e3a:	46bd      	mov	sp, r7
 8022e3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022e40:	4770      	bx	lr

08022e42 <XMC_GPIO_SetOutputLow>:
{
 8022e42:	b480      	push	{r7}
 8022e44:	b083      	sub	sp, #12
 8022e46:	af00      	add	r7, sp, #0
 8022e48:	6078      	str	r0, [r7, #4]
 8022e4a:	460b      	mov	r3, r1
 8022e4c:	70fb      	strb	r3, [r7, #3]
  port->OMR = 0x10000U << pin;
 8022e4e:	78fb      	ldrb	r3, [r7, #3]
 8022e50:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8022e54:	409a      	lsls	r2, r3
 8022e56:	687b      	ldr	r3, [r7, #4]
 8022e58:	605a      	str	r2, [r3, #4]
}
 8022e5a:	bf00      	nop
 8022e5c:	370c      	adds	r7, #12
 8022e5e:	46bd      	mov	sp, r7
 8022e60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022e64:	4770      	bx	lr

08022e66 <DIGITAL_IO_SetOutputHigh>:
* }
*  @endcode
*/

__STATIC_INLINE void DIGITAL_IO_SetOutputHigh(const DIGITAL_IO_t *const handler)
{
 8022e66:	b580      	push	{r7, lr}
 8022e68:	b082      	sub	sp, #8
 8022e6a:	af00      	add	r7, sp, #0
 8022e6c:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_SetOutputHigh: handler null pointer", handler != NULL);
  XMC_GPIO_SetOutputHigh(handler->gpio_port, handler->gpio_pin);
 8022e6e:	687b      	ldr	r3, [r7, #4]
 8022e70:	681a      	ldr	r2, [r3, #0]
 8022e72:	687b      	ldr	r3, [r7, #4]
 8022e74:	7c1b      	ldrb	r3, [r3, #16]
 8022e76:	4619      	mov	r1, r3
 8022e78:	4610      	mov	r0, r2
 8022e7a:	f7ff ffd1 	bl	8022e20 <XMC_GPIO_SetOutputHigh>
}
 8022e7e:	bf00      	nop
 8022e80:	3708      	adds	r7, #8
 8022e82:	46bd      	mov	sp, r7
 8022e84:	bd80      	pop	{r7, pc}

08022e86 <DIGITAL_IO_SetOutputLow>:
* }
*  @endcode
*/

__STATIC_INLINE void DIGITAL_IO_SetOutputLow(const DIGITAL_IO_t *const handler)
{
 8022e86:	b580      	push	{r7, lr}
 8022e88:	b082      	sub	sp, #8
 8022e8a:	af00      	add	r7, sp, #0
 8022e8c:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_SetOutputLow: handler null pointer", handler != NULL);
  XMC_GPIO_SetOutputLow(handler->gpio_port,handler->gpio_pin);
 8022e8e:	687b      	ldr	r3, [r7, #4]
 8022e90:	681a      	ldr	r2, [r3, #0]
 8022e92:	687b      	ldr	r3, [r7, #4]
 8022e94:	7c1b      	ldrb	r3, [r3, #16]
 8022e96:	4619      	mov	r1, r3
 8022e98:	4610      	mov	r0, r2
 8022e9a:	f7ff ffd2 	bl	8022e42 <XMC_GPIO_SetOutputLow>
}
 8022e9e:	bf00      	nop
 8022ea0:	3708      	adds	r7, #8
 8022ea2:	46bd      	mov	sp, r7
 8022ea4:	bd80      	pop	{r7, pc}
	...

08022ea8 <InitBuzzer>:
#include "MainAlg/presets.h"



void InitBuzzer(int32_t buzzer_type)
{
 8022ea8:	b580      	push	{r7, lr}
 8022eaa:	b082      	sub	sp, #8
 8022eac:	af00      	add	r7, sp, #0
 8022eae:	6078      	str	r0, [r7, #4]
	PWM_CCU4_SetFreqAndDutyCycle(&BUZZ_PWM, 440, 1000);
 8022eb0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8022eb4:	f44f 71dc 	mov.w	r1, #440	; 0x1b8
 8022eb8:	4807      	ldr	r0, [pc, #28]	; (8022ed8 <InitBuzzer+0x30>)
 8022eba:	f003 ff61 	bl	8026d80 <PWM_CCU4_SetFreqAndDutyCycle>
	DIGITAL_IO_SetOutputHigh(&TRANS_OUT);
 8022ebe:	4807      	ldr	r0, [pc, #28]	; (8022edc <InitBuzzer+0x34>)
 8022ec0:	f7ff ffd1 	bl	8022e66 <DIGITAL_IO_SetOutputHigh>
	DIGITAL_IO_SetOutputLow(&HS_SW_8);
 8022ec4:	4806      	ldr	r0, [pc, #24]	; (8022ee0 <InitBuzzer+0x38>)
 8022ec6:	f7ff ffde 	bl	8022e86 <DIGITAL_IO_SetOutputLow>
	PWM_CCU4_Stop(&BUZZ_PWM);
 8022eca:	4803      	ldr	r0, [pc, #12]	; (8022ed8 <InitBuzzer+0x30>)
 8022ecc:	f003 ff39 	bl	8026d42 <PWM_CCU4_Stop>
}
 8022ed0:	bf00      	nop
 8022ed2:	3708      	adds	r7, #8
 8022ed4:	46bd      	mov	sp, r7
 8022ed6:	bd80      	pop	{r7, pc}
 8022ed8:	1ffe9428 	.word	0x1ffe9428
 8022edc:	080288a4 	.word	0x080288a4
 8022ee0:	080287f0 	.word	0x080287f0

08022ee4 <CCU43_2_IRQHandler>:
	}
}


void BuzzerCmpISRHandler (void)
{
 8022ee4:	b580      	push	{r7, lr}
 8022ee6:	af00      	add	r7, sp, #0
	PWM_CCU4_ClearEvent(&BUZZ_PWM,XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP);
 8022ee8:	2102      	movs	r1, #2
 8022eea:	4804      	ldr	r0, [pc, #16]	; (8022efc <CCU43_2_IRQHandler+0x18>)
 8022eec:	f003 ffac 	bl	8026e48 <PWM_CCU4_ClearEvent>
	DIGITAL_IO_SetOutputLow(&TRANS_OUT);
 8022ef0:	4803      	ldr	r0, [pc, #12]	; (8022f00 <CCU43_2_IRQHandler+0x1c>)
 8022ef2:	f7ff ffc8 	bl	8022e86 <DIGITAL_IO_SetOutputLow>
}
 8022ef6:	bf00      	nop
 8022ef8:	bd80      	pop	{r7, pc}
 8022efa:	bf00      	nop
 8022efc:	1ffe9428 	.word	0x1ffe9428
 8022f00:	080288a4 	.word	0x080288a4

08022f04 <CCU43_0_IRQHandler>:

void BuzzerOvfISRHandler (void)
{
 8022f04:	b580      	push	{r7, lr}
 8022f06:	af00      	add	r7, sp, #0
	PWM_CCU4_ClearEvent(&BUZZ_PWM,XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 8022f08:	2100      	movs	r1, #0
 8022f0a:	4804      	ldr	r0, [pc, #16]	; (8022f1c <CCU43_0_IRQHandler+0x18>)
 8022f0c:	f003 ff9c 	bl	8026e48 <PWM_CCU4_ClearEvent>
	DIGITAL_IO_SetOutputHigh(&TRANS_OUT);
 8022f10:	4803      	ldr	r0, [pc, #12]	; (8022f20 <CCU43_0_IRQHandler+0x1c>)
 8022f12:	f7ff ffa8 	bl	8022e66 <DIGITAL_IO_SetOutputHigh>
}
 8022f16:	bf00      	nop
 8022f18:	bd80      	pop	{r7, pc}
 8022f1a:	bf00      	nop
 8022f1c:	1ffe9428 	.word	0x1ffe9428
 8022f20:	080288a4 	.word	0x080288a4

08022f24 <XMC_GPIO_SetOutputHigh>:
{
 8022f24:	b480      	push	{r7}
 8022f26:	b083      	sub	sp, #12
 8022f28:	af00      	add	r7, sp, #0
 8022f2a:	6078      	str	r0, [r7, #4]
 8022f2c:	460b      	mov	r3, r1
 8022f2e:	70fb      	strb	r3, [r7, #3]
  port->OMR = (uint32_t)0x1U << pin;
 8022f30:	78fb      	ldrb	r3, [r7, #3]
 8022f32:	2201      	movs	r2, #1
 8022f34:	409a      	lsls	r2, r3
 8022f36:	687b      	ldr	r3, [r7, #4]
 8022f38:	605a      	str	r2, [r3, #4]
}
 8022f3a:	bf00      	nop
 8022f3c:	370c      	adds	r7, #12
 8022f3e:	46bd      	mov	sp, r7
 8022f40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022f44:	4770      	bx	lr

08022f46 <XMC_GPIO_SetOutputLow>:
{
 8022f46:	b480      	push	{r7}
 8022f48:	b083      	sub	sp, #12
 8022f4a:	af00      	add	r7, sp, #0
 8022f4c:	6078      	str	r0, [r7, #4]
 8022f4e:	460b      	mov	r3, r1
 8022f50:	70fb      	strb	r3, [r7, #3]
  port->OMR = 0x10000U << pin;
 8022f52:	78fb      	ldrb	r3, [r7, #3]
 8022f54:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8022f58:	409a      	lsls	r2, r3
 8022f5a:	687b      	ldr	r3, [r7, #4]
 8022f5c:	605a      	str	r2, [r3, #4]
}
 8022f5e:	bf00      	nop
 8022f60:	370c      	adds	r7, #12
 8022f62:	46bd      	mov	sp, r7
 8022f64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022f68:	4770      	bx	lr

08022f6a <DIGITAL_IO_SetOutputHigh>:
{
 8022f6a:	b580      	push	{r7, lr}
 8022f6c:	b082      	sub	sp, #8
 8022f6e:	af00      	add	r7, sp, #0
 8022f70:	6078      	str	r0, [r7, #4]
  XMC_GPIO_SetOutputHigh(handler->gpio_port, handler->gpio_pin);
 8022f72:	687b      	ldr	r3, [r7, #4]
 8022f74:	681a      	ldr	r2, [r3, #0]
 8022f76:	687b      	ldr	r3, [r7, #4]
 8022f78:	7c1b      	ldrb	r3, [r3, #16]
 8022f7a:	4619      	mov	r1, r3
 8022f7c:	4610      	mov	r0, r2
 8022f7e:	f7ff ffd1 	bl	8022f24 <XMC_GPIO_SetOutputHigh>
}
 8022f82:	bf00      	nop
 8022f84:	3708      	adds	r7, #8
 8022f86:	46bd      	mov	sp, r7
 8022f88:	bd80      	pop	{r7, pc}

08022f8a <DIGITAL_IO_SetOutputLow>:
{
 8022f8a:	b580      	push	{r7, lr}
 8022f8c:	b082      	sub	sp, #8
 8022f8e:	af00      	add	r7, sp, #0
 8022f90:	6078      	str	r0, [r7, #4]
  XMC_GPIO_SetOutputLow(handler->gpio_port,handler->gpio_pin);
 8022f92:	687b      	ldr	r3, [r7, #4]
 8022f94:	681a      	ldr	r2, [r3, #0]
 8022f96:	687b      	ldr	r3, [r7, #4]
 8022f98:	7c1b      	ldrb	r3, [r3, #16]
 8022f9a:	4619      	mov	r1, r3
 8022f9c:	4610      	mov	r0, r2
 8022f9e:	f7ff ffd2 	bl	8022f46 <XMC_GPIO_SetOutputLow>
}
 8022fa2:	bf00      	nop
 8022fa4:	3708      	adds	r7, #8
 8022fa6:	46bd      	mov	sp, r7
 8022fa8:	bd80      	pop	{r7, pc}
	...

08022fac <InitLedRubber>:
int32_t LedPwmTimer = 0;



void InitLedRubber(int32_t mode)
{
 8022fac:	b580      	push	{r7, lr}
 8022fae:	b082      	sub	sp, #8
 8022fb0:	af00      	add	r7, sp, #0
 8022fb2:	6078      	str	r0, [r7, #4]
	if(mode == MODE_ON)
 8022fb4:	687b      	ldr	r3, [r7, #4]
 8022fb6:	2b01      	cmp	r3, #1
 8022fb8:	d118      	bne.n	8022fec <InitLedRubber+0x40>
	{
		  LedPwmTimer = SYSTIMER_CreateTimer(100, SYSTIMER_MODE_PERIODIC, LedPwmTimerProc, NULL );
 8022fba:	2300      	movs	r3, #0
 8022fbc:	4a0d      	ldr	r2, [pc, #52]	; (8022ff4 <InitLedRubber+0x48>)
 8022fbe:	2101      	movs	r1, #1
 8022fc0:	2064      	movs	r0, #100	; 0x64
 8022fc2:	f003 fb0d 	bl	80265e0 <SYSTIMER_CreateTimer>
 8022fc6:	4603      	mov	r3, r0
 8022fc8:	461a      	mov	r2, r3
 8022fca:	4b0b      	ldr	r3, [pc, #44]	; (8022ff8 <InitLedRubber+0x4c>)
 8022fcc:	601a      	str	r2, [r3, #0]
		  SYSTIMER_StartTimer(LedPwmTimer);
 8022fce:	4b0a      	ldr	r3, [pc, #40]	; (8022ff8 <InitLedRubber+0x4c>)
 8022fd0:	681b      	ldr	r3, [r3, #0]
 8022fd2:	4618      	mov	r0, r3
 8022fd4:	f003 fba2 	bl	802671c <SYSTIMER_StartTimer>
		  DIGITAL_IO_SetOutputHigh(&LED_SW_NRES);
 8022fd8:	4808      	ldr	r0, [pc, #32]	; (8022ffc <InitLedRubber+0x50>)
 8022fda:	f7ff ffc6 	bl	8022f6a <DIGITAL_IO_SetOutputHigh>

		  DIGITAL_IO_SetOutputHigh(&LED_POWER_EN2);
 8022fde:	4808      	ldr	r0, [pc, #32]	; (8023000 <InitLedRubber+0x54>)
 8022fe0:	f7ff ffc3 	bl	8022f6a <DIGITAL_IO_SetOutputHigh>
		  DIGITAL_IO_SetOutputHigh(&LED_POWER_EN1);
 8022fe4:	4807      	ldr	r0, [pc, #28]	; (8023004 <InitLedRubber+0x58>)
 8022fe6:	f7ff ffc0 	bl	8022f6a <DIGITAL_IO_SetOutputHigh>
 8022fea:	e000      	b.n	8022fee <InitLedRubber+0x42>
	}
	else
	{
		return;
 8022fec:	bf00      	nop
	}
}
 8022fee:	3708      	adds	r7, #8
 8022ff0:	46bd      	mov	sp, r7
 8022ff2:	bd80      	pop	{r7, pc}
 8022ff4:	08023009 	.word	0x08023009
 8022ff8:	1ffe9914 	.word	0x1ffe9914
 8022ffc:	08028714 	.word	0x08028714
 8023000:	080287c8 	.word	0x080287c8
 8023004:	080287dc 	.word	0x080287dc

08023008 <LedPwmTimerProc>:
	}
	previous_mode = mode;

}
void LedPwmTimerProc(void *args)
{
 8023008:	b580      	push	{r7, lr}
 802300a:	b082      	sub	sp, #8
 802300c:	af00      	add	r7, sp, #0
 802300e:	6078      	str	r0, [r7, #4]
	static int32_t timer = 0;

	if (timer >= 100)
 8023010:	4b39      	ldr	r3, [pc, #228]	; (80230f8 <LedPwmTimerProc+0xf0>)
 8023012:	681b      	ldr	r3, [r3, #0]
 8023014:	2b63      	cmp	r3, #99	; 0x63
 8023016:	dd02      	ble.n	802301e <LedPwmTimerProc+0x16>
	{
		timer = 0;
 8023018:	4b37      	ldr	r3, [pc, #220]	; (80230f8 <LedPwmTimerProc+0xf0>)
 802301a:	2200      	movs	r2, #0
 802301c:	601a      	str	r2, [r3, #0]
	}
	if(!timer)
 802301e:	4b36      	ldr	r3, [pc, #216]	; (80230f8 <LedPwmTimerProc+0xf0>)
 8023020:	681b      	ldr	r3, [r3, #0]
 8023022:	2b00      	cmp	r3, #0
 8023024:	d129      	bne.n	802307a <LedPwmTimerProc+0x72>
	{
		if(led_rubber.red_outern)
 8023026:	4b35      	ldr	r3, [pc, #212]	; (80230fc <LedPwmTimerProc+0xf4>)
 8023028:	681b      	ldr	r3, [r3, #0]
 802302a:	2b00      	cmp	r3, #0
 802302c:	d002      	beq.n	8023034 <LedPwmTimerProc+0x2c>
		{
			DIGITAL_IO_SetOutputHigh(&LED_SW_1);
 802302e:	4834      	ldr	r0, [pc, #208]	; (8023100 <LedPwmTimerProc+0xf8>)
 8023030:	f7ff ff9b 	bl	8022f6a <DIGITAL_IO_SetOutputHigh>
		}
		if(led_rubber.green_outern)
 8023034:	4b31      	ldr	r3, [pc, #196]	; (80230fc <LedPwmTimerProc+0xf4>)
 8023036:	685b      	ldr	r3, [r3, #4]
 8023038:	2b00      	cmp	r3, #0
 802303a:	d002      	beq.n	8023042 <LedPwmTimerProc+0x3a>
		{
			DIGITAL_IO_SetOutputHigh(&LED_SW_2);
 802303c:	4831      	ldr	r0, [pc, #196]	; (8023104 <LedPwmTimerProc+0xfc>)
 802303e:	f7ff ff94 	bl	8022f6a <DIGITAL_IO_SetOutputHigh>
		}
		if(led_rubber.blue_outern)
 8023042:	4b2e      	ldr	r3, [pc, #184]	; (80230fc <LedPwmTimerProc+0xf4>)
 8023044:	689b      	ldr	r3, [r3, #8]
 8023046:	2b00      	cmp	r3, #0
 8023048:	d002      	beq.n	8023050 <LedPwmTimerProc+0x48>
		{
			DIGITAL_IO_SetOutputHigh(&LED_SW_3);
 802304a:	482f      	ldr	r0, [pc, #188]	; (8023108 <LedPwmTimerProc+0x100>)
 802304c:	f7ff ff8d 	bl	8022f6a <DIGITAL_IO_SetOutputHigh>
		}
		if(led_rubber.red_intern)
 8023050:	4b2a      	ldr	r3, [pc, #168]	; (80230fc <LedPwmTimerProc+0xf4>)
 8023052:	68db      	ldr	r3, [r3, #12]
 8023054:	2b00      	cmp	r3, #0
 8023056:	d002      	beq.n	802305e <LedPwmTimerProc+0x56>
		{
			DIGITAL_IO_SetOutputHigh(&LED_SW_4);
 8023058:	482c      	ldr	r0, [pc, #176]	; (802310c <LedPwmTimerProc+0x104>)
 802305a:	f7ff ff86 	bl	8022f6a <DIGITAL_IO_SetOutputHigh>
		}
		if(led_rubber.green_intern)
 802305e:	4b27      	ldr	r3, [pc, #156]	; (80230fc <LedPwmTimerProc+0xf4>)
 8023060:	691b      	ldr	r3, [r3, #16]
 8023062:	2b00      	cmp	r3, #0
 8023064:	d002      	beq.n	802306c <LedPwmTimerProc+0x64>
		{
			DIGITAL_IO_SetOutputHigh(&LED_SW_5);
 8023066:	482a      	ldr	r0, [pc, #168]	; (8023110 <LedPwmTimerProc+0x108>)
 8023068:	f7ff ff7f 	bl	8022f6a <DIGITAL_IO_SetOutputHigh>
		}
		if(led_rubber.blue_intern)
 802306c:	4b23      	ldr	r3, [pc, #140]	; (80230fc <LedPwmTimerProc+0xf4>)
 802306e:	695b      	ldr	r3, [r3, #20]
 8023070:	2b00      	cmp	r3, #0
 8023072:	d002      	beq.n	802307a <LedPwmTimerProc+0x72>
		{
			DIGITAL_IO_SetOutputHigh(&LED_SW_6);
 8023074:	4827      	ldr	r0, [pc, #156]	; (8023114 <LedPwmTimerProc+0x10c>)
 8023076:	f7ff ff78 	bl	8022f6a <DIGITAL_IO_SetOutputHigh>
		}
	}


	if ((led_rubber.red_outern <= timer))
 802307a:	4b20      	ldr	r3, [pc, #128]	; (80230fc <LedPwmTimerProc+0xf4>)
 802307c:	681a      	ldr	r2, [r3, #0]
 802307e:	4b1e      	ldr	r3, [pc, #120]	; (80230f8 <LedPwmTimerProc+0xf0>)
 8023080:	681b      	ldr	r3, [r3, #0]
 8023082:	429a      	cmp	r2, r3
 8023084:	dc02      	bgt.n	802308c <LedPwmTimerProc+0x84>
	{
		DIGITAL_IO_SetOutputLow(&LED_SW_1);
 8023086:	481e      	ldr	r0, [pc, #120]	; (8023100 <LedPwmTimerProc+0xf8>)
 8023088:	f7ff ff7f 	bl	8022f8a <DIGITAL_IO_SetOutputLow>
	}
	if ((led_rubber.green_outern <= timer))
 802308c:	4b1b      	ldr	r3, [pc, #108]	; (80230fc <LedPwmTimerProc+0xf4>)
 802308e:	685a      	ldr	r2, [r3, #4]
 8023090:	4b19      	ldr	r3, [pc, #100]	; (80230f8 <LedPwmTimerProc+0xf0>)
 8023092:	681b      	ldr	r3, [r3, #0]
 8023094:	429a      	cmp	r2, r3
 8023096:	dc02      	bgt.n	802309e <LedPwmTimerProc+0x96>
	{
		DIGITAL_IO_SetOutputLow(&LED_SW_2);
 8023098:	481a      	ldr	r0, [pc, #104]	; (8023104 <LedPwmTimerProc+0xfc>)
 802309a:	f7ff ff76 	bl	8022f8a <DIGITAL_IO_SetOutputLow>
	}
	if ((led_rubber.blue_outern <= timer))
 802309e:	4b17      	ldr	r3, [pc, #92]	; (80230fc <LedPwmTimerProc+0xf4>)
 80230a0:	689a      	ldr	r2, [r3, #8]
 80230a2:	4b15      	ldr	r3, [pc, #84]	; (80230f8 <LedPwmTimerProc+0xf0>)
 80230a4:	681b      	ldr	r3, [r3, #0]
 80230a6:	429a      	cmp	r2, r3
 80230a8:	dc02      	bgt.n	80230b0 <LedPwmTimerProc+0xa8>
	{
		DIGITAL_IO_SetOutputLow(&LED_SW_3);
 80230aa:	4817      	ldr	r0, [pc, #92]	; (8023108 <LedPwmTimerProc+0x100>)
 80230ac:	f7ff ff6d 	bl	8022f8a <DIGITAL_IO_SetOutputLow>
	}
	if ((led_rubber.red_intern <= timer))
 80230b0:	4b12      	ldr	r3, [pc, #72]	; (80230fc <LedPwmTimerProc+0xf4>)
 80230b2:	68da      	ldr	r2, [r3, #12]
 80230b4:	4b10      	ldr	r3, [pc, #64]	; (80230f8 <LedPwmTimerProc+0xf0>)
 80230b6:	681b      	ldr	r3, [r3, #0]
 80230b8:	429a      	cmp	r2, r3
 80230ba:	dc02      	bgt.n	80230c2 <LedPwmTimerProc+0xba>
	{
		DIGITAL_IO_SetOutputLow(&LED_SW_4);
 80230bc:	4813      	ldr	r0, [pc, #76]	; (802310c <LedPwmTimerProc+0x104>)
 80230be:	f7ff ff64 	bl	8022f8a <DIGITAL_IO_SetOutputLow>
	}
	if ((led_rubber.green_intern <= timer))
 80230c2:	4b0e      	ldr	r3, [pc, #56]	; (80230fc <LedPwmTimerProc+0xf4>)
 80230c4:	691a      	ldr	r2, [r3, #16]
 80230c6:	4b0c      	ldr	r3, [pc, #48]	; (80230f8 <LedPwmTimerProc+0xf0>)
 80230c8:	681b      	ldr	r3, [r3, #0]
 80230ca:	429a      	cmp	r2, r3
 80230cc:	dc02      	bgt.n	80230d4 <LedPwmTimerProc+0xcc>
	{
		DIGITAL_IO_SetOutputLow(&LED_SW_5);
 80230ce:	4810      	ldr	r0, [pc, #64]	; (8023110 <LedPwmTimerProc+0x108>)
 80230d0:	f7ff ff5b 	bl	8022f8a <DIGITAL_IO_SetOutputLow>
	}
	if ((led_rubber.blue_intern <= timer))
 80230d4:	4b09      	ldr	r3, [pc, #36]	; (80230fc <LedPwmTimerProc+0xf4>)
 80230d6:	695a      	ldr	r2, [r3, #20]
 80230d8:	4b07      	ldr	r3, [pc, #28]	; (80230f8 <LedPwmTimerProc+0xf0>)
 80230da:	681b      	ldr	r3, [r3, #0]
 80230dc:	429a      	cmp	r2, r3
 80230de:	dc02      	bgt.n	80230e6 <LedPwmTimerProc+0xde>
	{
		DIGITAL_IO_SetOutputLow(&LED_SW_6);
 80230e0:	480c      	ldr	r0, [pc, #48]	; (8023114 <LedPwmTimerProc+0x10c>)
 80230e2:	f7ff ff52 	bl	8022f8a <DIGITAL_IO_SetOutputLow>
	}

	timer++;
 80230e6:	4b04      	ldr	r3, [pc, #16]	; (80230f8 <LedPwmTimerProc+0xf0>)
 80230e8:	681b      	ldr	r3, [r3, #0]
 80230ea:	3301      	adds	r3, #1
 80230ec:	4a02      	ldr	r2, [pc, #8]	; (80230f8 <LedPwmTimerProc+0xf0>)
 80230ee:	6013      	str	r3, [r2, #0]
}
 80230f0:	bf00      	nop
 80230f2:	3708      	adds	r7, #8
 80230f4:	46bd      	mov	sp, r7
 80230f6:	bd80      	pop	{r7, pc}
 80230f8:	1ffe9918 	.word	0x1ffe9918
 80230fc:	1ffe98fc 	.word	0x1ffe98fc
 8023100:	080287b4 	.word	0x080287b4
 8023104:	080287a0 	.word	0x080287a0
 8023108:	0802878c 	.word	0x0802878c
 802310c:	08028778 	.word	0x08028778
 8023110:	08028764 	.word	0x08028764
 8023114:	08028750 	.word	0x08028750

08023118 <XMC_GPIO_SetOutputHigh>:
{
 8023118:	b480      	push	{r7}
 802311a:	b083      	sub	sp, #12
 802311c:	af00      	add	r7, sp, #0
 802311e:	6078      	str	r0, [r7, #4]
 8023120:	460b      	mov	r3, r1
 8023122:	70fb      	strb	r3, [r7, #3]
  port->OMR = (uint32_t)0x1U << pin;
 8023124:	78fb      	ldrb	r3, [r7, #3]
 8023126:	2201      	movs	r2, #1
 8023128:	409a      	lsls	r2, r3
 802312a:	687b      	ldr	r3, [r7, #4]
 802312c:	605a      	str	r2, [r3, #4]
}
 802312e:	bf00      	nop
 8023130:	370c      	adds	r7, #12
 8023132:	46bd      	mov	sp, r7
 8023134:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023138:	4770      	bx	lr

0802313a <XMC_GPIO_SetOutputLow>:
{
 802313a:	b480      	push	{r7}
 802313c:	b083      	sub	sp, #12
 802313e:	af00      	add	r7, sp, #0
 8023140:	6078      	str	r0, [r7, #4]
 8023142:	460b      	mov	r3, r1
 8023144:	70fb      	strb	r3, [r7, #3]
  port->OMR = 0x10000U << pin;
 8023146:	78fb      	ldrb	r3, [r7, #3]
 8023148:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 802314c:	409a      	lsls	r2, r3
 802314e:	687b      	ldr	r3, [r7, #4]
 8023150:	605a      	str	r2, [r3, #4]
}
 8023152:	bf00      	nop
 8023154:	370c      	adds	r7, #12
 8023156:	46bd      	mov	sp, r7
 8023158:	f85d 7b04 	ldr.w	r7, [sp], #4
 802315c:	4770      	bx	lr

0802315e <DIGITAL_IO_SetOutputHigh>:
{
 802315e:	b580      	push	{r7, lr}
 8023160:	b082      	sub	sp, #8
 8023162:	af00      	add	r7, sp, #0
 8023164:	6078      	str	r0, [r7, #4]
  XMC_GPIO_SetOutputHigh(handler->gpio_port, handler->gpio_pin);
 8023166:	687b      	ldr	r3, [r7, #4]
 8023168:	681a      	ldr	r2, [r3, #0]
 802316a:	687b      	ldr	r3, [r7, #4]
 802316c:	7c1b      	ldrb	r3, [r3, #16]
 802316e:	4619      	mov	r1, r3
 8023170:	4610      	mov	r0, r2
 8023172:	f7ff ffd1 	bl	8023118 <XMC_GPIO_SetOutputHigh>
}
 8023176:	bf00      	nop
 8023178:	3708      	adds	r7, #8
 802317a:	46bd      	mov	sp, r7
 802317c:	bd80      	pop	{r7, pc}

0802317e <DIGITAL_IO_SetOutputLow>:
{
 802317e:	b580      	push	{r7, lr}
 8023180:	b082      	sub	sp, #8
 8023182:	af00      	add	r7, sp, #0
 8023184:	6078      	str	r0, [r7, #4]
  XMC_GPIO_SetOutputLow(handler->gpio_port,handler->gpio_pin);
 8023186:	687b      	ldr	r3, [r7, #4]
 8023188:	681a      	ldr	r2, [r3, #0]
 802318a:	687b      	ldr	r3, [r7, #4]
 802318c:	7c1b      	ldrb	r3, [r3, #16]
 802318e:	4619      	mov	r1, r3
 8023190:	4610      	mov	r0, r2
 8023192:	f7ff ffd2 	bl	802313a <XMC_GPIO_SetOutputLow>
}
 8023196:	bf00      	nop
 8023198:	3708      	adds	r7, #8
 802319a:	46bd      	mov	sp, r7
 802319c:	bd80      	pop	{r7, pc}
	...

080231a0 <DoorPeriphInit>:
//int32_t TrapSensor = 0;
//int32_t Open1DoorBut = 0;


void DoorPeriphInit(void)
{
 80231a0:	b580      	push	{r7, lr}
 80231a2:	af00      	add	r7, sp, #0

	InitLedRubber(MODE_ON);
 80231a4:	2001      	movs	r0, #1
 80231a6:	f7ff ff01 	bl	8022fac <InitLedRubber>
	InitBuzzer(BUZZER_TYPE_SFM);
 80231aa:	2000      	movs	r0, #0
 80231ac:	f7ff fe7c 	bl	8022ea8 <InitBuzzer>

	DIGITAL_IO_SetOutputHigh(&LS_SW_NRES);
 80231b0:	480b      	ldr	r0, [pc, #44]	; (80231e0 <DoorPeriphInit+0x40>)
 80231b2:	f7ff ffd4 	bl	802315e <DIGITAL_IO_SetOutputHigh>
	DIGITAL_IO_SetOutputLow(&DI_PNP_EN);
 80231b6:	480b      	ldr	r0, [pc, #44]	; (80231e4 <DoorPeriphInit+0x44>)
 80231b8:	f7ff ffe1 	bl	802317e <DIGITAL_IO_SetOutputLow>
	DIGITAL_IO_SetOutputLow(&DI_NPN_EN);
 80231bc:	480a      	ldr	r0, [pc, #40]	; (80231e8 <DoorPeriphInit+0x48>)
 80231be:	f7ff ffde 	bl	802317e <DIGITAL_IO_SetOutputLow>
	DIGITAL_IO_SetOutputLow(&GROUP_IN_EN);
 80231c2:	480a      	ldr	r0, [pc, #40]	; (80231ec <DoorPeriphInit+0x4c>)
 80231c4:	f7ff ffdb 	bl	802317e <DIGITAL_IO_SetOutputLow>
	DIGITAL_IO_SetOutputHigh(&POWER_SWITCH);
 80231c8:	4809      	ldr	r0, [pc, #36]	; (80231f0 <DoorPeriphInit+0x50>)
 80231ca:	f7ff ffc8 	bl	802315e <DIGITAL_IO_SetOutputHigh>

	PWM_CCU4_SetFreqAndDutyCycle(&CLUTCH_PWM, 2000, 6000); //5200///5600
 80231ce:	f241 7270 	movw	r2, #6000	; 0x1770
 80231d2:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 80231d6:	4807      	ldr	r0, [pc, #28]	; (80231f4 <DoorPeriphInit+0x54>)
 80231d8:	f003 fdd2 	bl	8026d80 <PWM_CCU4_SetFreqAndDutyCycle>

}
 80231dc:	bf00      	nop
 80231de:	bd80      	pop	{r7, pc}
 80231e0:	08028868 	.word	0x08028868
 80231e4:	08028674 	.word	0x08028674
 80231e8:	08028660 	.word	0x08028660
 80231ec:	08028688 	.word	0x08028688
 80231f0:	08028890 	.word	0x08028890
 80231f4:	1ffe9450 	.word	0x1ffe9450

080231f8 <MainAlgInit>:
int32_t serv_from_but = 0;



void MainAlgInit(void)
{
 80231f8:	b580      	push	{r7, lr}
 80231fa:	af00      	add	r7, sp, #0

	DoorPeriphInit();
 80231fc:	f7ff ffd0 	bl	80231a0 <DoorPeriphInit>
	MotorInit();
 8023200:	f7ff fbd0 	bl	80229a4 <MotorInit>

	MainTimer = SYSTIMER_CreateTimer((MAIN_TIMER_TIME_MS * 1000), SYSTIMER_MODE_PERIODIC, MainProc, NULL );
 8023204:	2300      	movs	r3, #0
 8023206:	4a0b      	ldr	r2, [pc, #44]	; (8023234 <MainAlgInit+0x3c>)
 8023208:	2101      	movs	r1, #1
 802320a:	f242 7010 	movw	r0, #10000	; 0x2710
 802320e:	f003 f9e7 	bl	80265e0 <SYSTIMER_CreateTimer>
 8023212:	4603      	mov	r3, r0
 8023214:	461a      	mov	r2, r3
 8023216:	4b08      	ldr	r3, [pc, #32]	; (8023238 <MainAlgInit+0x40>)
 8023218:	601a      	str	r2, [r3, #0]
	SYSTIMER_StartTimer(MainTimer);
 802321a:	4b07      	ldr	r3, [pc, #28]	; (8023238 <MainAlgInit+0x40>)
 802321c:	681b      	ldr	r3, [r3, #0]
 802321e:	4618      	mov	r0, r3
 8023220:	f003 fa7c 	bl	802671c <SYSTIMER_StartTimer>

//	SaveTimer = SYSTIMER_CreateTimer((1000*1000), SYSTIMER_MODE_PERIODIC, SaveProc, NULL);
//	SYSTIMER_StartTimer(SaveTimer);

	OPEN_DIR = -Presets.CLOSE_DIR;
 8023224:	4b05      	ldr	r3, [pc, #20]	; (802323c <MainAlgInit+0x44>)
 8023226:	681b      	ldr	r3, [r3, #0]
 8023228:	425b      	negs	r3, r3
 802322a:	4a05      	ldr	r2, [pc, #20]	; (8023240 <MainAlgInit+0x48>)
 802322c:	6013      	str	r3, [r2, #0]

}
 802322e:	bf00      	nop
 8023230:	bd80      	pop	{r7, pc}
 8023232:	bf00      	nop
 8023234:	08023245 	.word	0x08023245
 8023238:	1ffe992c 	.word	0x1ffe992c
 802323c:	1ffe9930 	.word	0x1ffe9930
 8023240:	1ffe9414 	.word	0x1ffe9414

08023244 <MainProc>:

void MainProc (void *args)
{
 8023244:	b480      	push	{r7}
 8023246:	b083      	sub	sp, #12
 8023248:	af00      	add	r7, sp, #0
 802324a:	6078      	str	r0, [r7, #4]

}
 802324c:	bf00      	nop
 802324e:	370c      	adds	r7, #12
 8023250:	46bd      	mov	sp, r7
 8023252:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023256:	4770      	bx	lr

08023258 <ReadAllPresets>:
/* ---------------------------------------------------------------------------*/

/* ---------------------------------------------------------------------------*/
/* Public Functions ----------------------------------------------------------*/
/* ---------------------------------------------------------------------------*/
void ReadAllPresets( const PresetsTypeDef *const pntrPresets ) {
 8023258:	b580      	push	{r7, lr}
 802325a:	b082      	sub	sp, #8
 802325c:	af00      	add	r7, sp, #0
 802325e:	6078      	str	r0, [r7, #4]
	E_EEPROM_XMC4_ReadArray( 0, (uint8_t*)pntrPresets, sizeof(*pntrPresets) );
 8023260:	224c      	movs	r2, #76	; 0x4c
 8023262:	6879      	ldr	r1, [r7, #4]
 8023264:	2000      	movs	r0, #0
 8023266:	f000 f903 	bl	8023470 <E_EEPROM_XMC4_ReadArray>
}
 802326a:	bf00      	nop
 802326c:	3708      	adds	r7, #8
 802326e:	46bd      	mov	sp, r7
 8023270:	bd80      	pop	{r7, pc}

08023272 <SaveAllPresets>:
	E_EEPROM_XMC4_ReadArray( (uint16_t)offset, pntrParam, 4 ); // read 4 bytes (one parameter)
}



E_EEPROM_XMC4_STATUS_t SaveAllPresets( const PresetsTypeDef *const pntrPresets ) {
 8023272:	b580      	push	{r7, lr}
 8023274:	b082      	sub	sp, #8
 8023276:	af00      	add	r7, sp, #0
 8023278:	6078      	str	r0, [r7, #4]
	E_EEPROM_XMC4_WriteArray( 0, (uint8_t*)pntrPresets, sizeof(*pntrPresets) );
 802327a:	224c      	movs	r2, #76	; 0x4c
 802327c:	6879      	ldr	r1, [r7, #4]
 802327e:	2000      	movs	r0, #0
 8023280:	f000 f8c4 	bl	802340c <E_EEPROM_XMC4_WriteArray>
	return E_EEPROM_XMC4_UpdateFlashContents();
 8023284:	f000 f91c 	bl	80234c0 <E_EEPROM_XMC4_UpdateFlashContents>
 8023288:	4603      	mov	r3, r0
}
 802328a:	4618      	mov	r0, r3
 802328c:	3708      	adds	r7, #8
 802328e:	46bd      	mov	sp, r7
 8023290:	bd80      	pop	{r7, pc}
	...

08023294 <XMC_FLASH_SetMargin>:
 *
 * \par<b>Related APIs:</b><BR>
 * None
 */
__STATIC_INLINE void XMC_FLASH_SetMargin(const XMC_FLASH_MARGIN_t margin)
{
 8023294:	b480      	push	{r7}
 8023296:	b083      	sub	sp, #12
 8023298:	af00      	add	r7, sp, #0
 802329a:	4603      	mov	r3, r0
 802329c:	71fb      	strb	r3, [r7, #7]
  FLASH0->MARP = (FLASH0->MARP & (uint32_t)~FLASH_MARP_MARGIN_Msk) | margin;
 802329e:	4b09      	ldr	r3, [pc, #36]	; (80232c4 <XMC_FLASH_SetMargin+0x30>)
 80232a0:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80232a4:	699b      	ldr	r3, [r3, #24]
 80232a6:	f023 020f 	bic.w	r2, r3, #15
 80232aa:	79fb      	ldrb	r3, [r7, #7]
 80232ac:	4905      	ldr	r1, [pc, #20]	; (80232c4 <XMC_FLASH_SetMargin+0x30>)
 80232ae:	4313      	orrs	r3, r2
 80232b0:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
 80232b4:	6193      	str	r3, [r2, #24]
}
 80232b6:	bf00      	nop
 80232b8:	370c      	adds	r7, #12
 80232ba:	46bd      	mov	sp, r7
 80232bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80232c0:	4770      	bx	lr
 80232c2:	bf00      	nop
 80232c4:	58001000 	.word	0x58001000

080232c8 <XMC_FLASH_EnableDoubleBitErrorTrap>:
 *
 * \par<b>Related APIs:</b><BR>
 * None
 */
__STATIC_INLINE void XMC_FLASH_EnableDoubleBitErrorTrap(void)
{
 80232c8:	b480      	push	{r7}
 80232ca:	af00      	add	r7, sp, #0
  FLASH0->MARP &= (uint32_t)~FLASH_MARP_TRAPDIS_Msk;
 80232cc:	4b07      	ldr	r3, [pc, #28]	; (80232ec <XMC_FLASH_EnableDoubleBitErrorTrap+0x24>)
 80232ce:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80232d2:	699b      	ldr	r3, [r3, #24]
 80232d4:	4a05      	ldr	r2, [pc, #20]	; (80232ec <XMC_FLASH_EnableDoubleBitErrorTrap+0x24>)
 80232d6:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 80232da:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 80232de:	6193      	str	r3, [r2, #24]
}
 80232e0:	bf00      	nop
 80232e2:	46bd      	mov	sp, r7
 80232e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80232e8:	4770      	bx	lr
 80232ea:	bf00      	nop
 80232ec:	58001000 	.word	0x58001000

080232f0 <XMC_FLASH_DisableDoubleBitErrorTrap>:
 *
 * \par<b>Related APIs:</b><BR>
 * None
 */
__STATIC_INLINE void XMC_FLASH_DisableDoubleBitErrorTrap(void)
{
 80232f0:	b480      	push	{r7}
 80232f2:	af00      	add	r7, sp, #0
  FLASH0->MARP |= FLASH_MARP_TRAPDIS_Msk;
 80232f4:	4b07      	ldr	r3, [pc, #28]	; (8023314 <XMC_FLASH_DisableDoubleBitErrorTrap+0x24>)
 80232f6:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80232fa:	699b      	ldr	r3, [r3, #24]
 80232fc:	4a05      	ldr	r2, [pc, #20]	; (8023314 <XMC_FLASH_DisableDoubleBitErrorTrap+0x24>)
 80232fe:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8023302:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8023306:	6193      	str	r3, [r2, #24]
}
 8023308:	bf00      	nop
 802330a:	46bd      	mov	sp, r7
 802330c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023310:	4770      	bx	lr
 8023312:	bf00      	nop
 8023314:	58001000 	.word	0x58001000

08023318 <XMC_FCE_InitializeSeedValue>:
 *
 * \par
 * The function sets the initial CRC (seed) value in the CRC register.
 */
__STATIC_INLINE void XMC_FCE_InitializeSeedValue(const XMC_FCE_t *const engine, uint32_t seedvalue)
{
 8023318:	b480      	push	{r7}
 802331a:	b083      	sub	sp, #12
 802331c:	af00      	add	r7, sp, #0
 802331e:	6078      	str	r0, [r7, #4]
 8023320:	6039      	str	r1, [r7, #0]
  engine->kernel_ptr->CRC = seedvalue;
 8023322:	687b      	ldr	r3, [r7, #4]
 8023324:	681b      	ldr	r3, [r3, #0]
 8023326:	683a      	ldr	r2, [r7, #0]
 8023328:	619a      	str	r2, [r3, #24]
}
 802332a:	bf00      	nop
 802332c:	370c      	adds	r7, #12
 802332e:	46bd      	mov	sp, r7
 8023330:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023334:	4770      	bx	lr
	...

08023338 <E_EEPROM_XMC4_Init>:

/* ---------------------------------------------------------------------------*/
/* Public Functions ----------------------------------------------------------*/
/* ---------------------------------------------------------------------------*/
E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_Init(E_EEPROM_XMC4_t *const handle)
{
 8023338:	b580      	push	{r7, lr}
 802333a:	b084      	sub	sp, #16
 802333c:	af00      	add	r7, sp, #0
 802333e:	6078      	str	r0, [r7, #4]
  uint32_t sector_count;
  E_EEPROM_XMC4_STATUS_t status ;

  XMC_ASSERT("E_EEPROM_XMC4_Init:Invalid handle Pointer", (handle != NULL));

  status = E_EEPROM_XMC4_STATUS_OK;
 8023340:	2300      	movs	r3, #0
 8023342:	72fb      	strb	r3, [r7, #11]

  if (handle->initialized == (bool)false)
 8023344:	687b      	ldr	r3, [r7, #4]
 8023346:	781b      	ldrb	r3, [r3, #0]
 8023348:	f083 0301 	eor.w	r3, r3, #1
 802334c:	b2db      	uxtb	r3, r3
 802334e:	2b00      	cmp	r3, #0
 8023350:	d04c      	beq.n	80233ec <E_EEPROM_XMC4_Init+0xb4>
  {
    e_eeprom_xmc4_data_buffer.block_cycle_count = 0U;
 8023352:	4b29      	ldr	r3, [pc, #164]	; (80233f8 <E_EEPROM_XMC4_Init+0xc0>)
 8023354:	2200      	movs	r2, #0
 8023356:	605a      	str	r2, [r3, #4]
    e_eeprom_xmc4_sector_info.flash_data_addr = E_EEPROM_XMC4_EMPTY;
 8023358:	4b28      	ldr	r3, [pc, #160]	; (80233fc <E_EEPROM_XMC4_Init+0xc4>)
 802335a:	2200      	movs	r2, #0
 802335c:	605a      	str	r2, [r3, #4]

    XMC_FLASH_SetMargin(XMC_FLASH_MARGIN_TIGHT0);
 802335e:	2001      	movs	r0, #1
 8023360:	f7ff ff98 	bl	8023294 <XMC_FLASH_SetMargin>
    XMC_FLASH_DisableDoubleBitErrorTrap();
 8023364:	f7ff ffc4 	bl	80232f0 <XMC_FLASH_DisableDoubleBitErrorTrap>

    XMC_FCE_Enable();
 8023368:	f002 fa14 	bl	8025794 <XMC_FCE_Enable>

    /* Initialize FCE module for Hardware calculations */
    (void)XMC_FCE_Init(&e_eeprom_xmc4_fce);
 802336c:	4824      	ldr	r0, [pc, #144]	; (8023400 <E_EEPROM_XMC4_Init+0xc8>)
 802336e:	f002 f9fc 	bl	802576a <XMC_FCE_Init>

    /* Iterate all 4 sectors to find out which is the active sector having the latest data block*/
    for (sector_count = 0U; sector_count < E_EEPROM_XMC4_MAX_SECTORS ; sector_count++)
 8023372:	2300      	movs	r3, #0
 8023374:	60fb      	str	r3, [r7, #12]
 8023376:	e005      	b.n	8023384 <E_EEPROM_XMC4_Init+0x4c>
    {
      E_EEPROM_XMC4_lInitReadSectorInfo(sector_count);
 8023378:	68f8      	ldr	r0, [r7, #12]
 802337a:	f000 f945 	bl	8023608 <E_EEPROM_XMC4_lInitReadSectorInfo>
    for (sector_count = 0U; sector_count < E_EEPROM_XMC4_MAX_SECTORS ; sector_count++)
 802337e:	68fb      	ldr	r3, [r7, #12]
 8023380:	3301      	adds	r3, #1
 8023382:	60fb      	str	r3, [r7, #12]
 8023384:	68fb      	ldr	r3, [r7, #12]
 8023386:	2b03      	cmp	r3, #3
 8023388:	d9f6      	bls.n	8023378 <E_EEPROM_XMC4_Init+0x40>
    }

    XMC_FLASH_SetMargin(XMC_FLASH_MARGIN_DEFAULT);
 802338a:	2000      	movs	r0, #0
 802338c:	f7ff ff82 	bl	8023294 <XMC_FLASH_SetMargin>

    /* Implement the OVER ERASE CHECK code here and return the status*/

    /* If Read was successful*/
    if (status == E_EEPROM_XMC4_STATUS_OK)
 8023390:	7afb      	ldrb	r3, [r7, #11]
 8023392:	2b00      	cmp	r3, #0
 8023394:	d125      	bne.n	80233e2 <E_EEPROM_XMC4_Init+0xaa>
    {
      /* Execute erase state machine to free up the unwanted sectors and keep
       * only the sector which has latest valid block. If no valid block found then all sectors are emptied.
       */
      status = E_EEPROM_XMC4_lInitEraseStateMachine();
 8023396:	f000 f98f 	bl	80236b8 <E_EEPROM_XMC4_lInitEraseStateMachine>
 802339a:	4603      	mov	r3, r0
 802339c:	72fb      	strb	r3, [r7, #11]

      /* If erase operations were successful, continue block data updates to RAM buffer */
      if (status == E_EEPROM_XMC4_STATUS_OK)
 802339e:	7afb      	ldrb	r3, [r7, #11]
 80233a0:	2b00      	cmp	r3, #0
 80233a2:	d11e      	bne.n	80233e2 <E_EEPROM_XMC4_Init+0xaa>
      {

        /* If a valid latest block were not detected, we shall assume that all sectors may be empty.
         * Then make Sector-0 as current sector and next free address as Sector0 start address
         */
        if (e_eeprom_xmc4_sector_info.flash_data_addr == E_EEPROM_XMC4_EMPTY)
 80233a4:	4b15      	ldr	r3, [pc, #84]	; (80233fc <E_EEPROM_XMC4_Init+0xc4>)
 80233a6:	685b      	ldr	r3, [r3, #4]
 80233a8:	2b00      	cmp	r3, #0
 80233aa:	d106      	bne.n	80233ba <E_EEPROM_XMC4_Init+0x82>
        {
          e_eeprom_xmc4_sector_info.current_sector = E_EEPROM_XMC4_SECTOR_0;
 80233ac:	4b13      	ldr	r3, [pc, #76]	; (80233fc <E_EEPROM_XMC4_Init+0xc4>)
 80233ae:	2200      	movs	r2, #0
 80233b0:	609a      	str	r2, [r3, #8]
          e_eeprom_xmc4_sector_info.next_free_start_addr =  E_EEPROM_XMC4_SECTOR0_START_ADDR;
 80233b2:	4b12      	ldr	r3, [pc, #72]	; (80233fc <E_EEPROM_XMC4_Init+0xc4>)
 80233b4:	4a13      	ldr	r2, [pc, #76]	; (8023404 <E_EEPROM_XMC4_Init+0xcc>)
 80233b6:	601a      	str	r2, [r3, #0]
 80233b8:	e013      	b.n	80233e2 <E_EEPROM_XMC4_Init+0xaa>
        }
        else
        {
          /* If a valid latest block was detected, copy the valid block from flash to RAM. */
          E_EEPROM_XMC4_lCopyFlashToRam();
 80233ba:	f000 f9d5 	bl	8023768 <E_EEPROM_XMC4_lCopyFlashToRam>

          if ((e_eeprom_xmc4_sector_info.next_free_start_addr - e_eeprom_xmc4_sector_info.flash_data_addr) !=
 80233be:	4b0f      	ldr	r3, [pc, #60]	; (80233fc <E_EEPROM_XMC4_Init+0xc4>)
 80233c0:	681a      	ldr	r2, [r3, #0]
 80233c2:	4b0e      	ldr	r3, [pc, #56]	; (80233fc <E_EEPROM_XMC4_Init+0xc4>)
 80233c4:	685b      	ldr	r3, [r3, #4]
 80233c6:	1ad3      	subs	r3, r2, r3
 80233c8:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80233cc:	d001      	beq.n	80233d2 <E_EEPROM_XMC4_Init+0x9a>
              E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE)
          {
            status = E_EEPROM_XMC4_STATUS_ERROR_OLD_DATA;
 80233ce:	2301      	movs	r3, #1
 80233d0:	72fb      	strb	r3, [r7, #11]
          }

          if (e_eeprom_xmc4_sector_info.next_free_start_addr >= E_EEPROM_XMC4_SECTOR4_START_ADDR)
 80233d2:	4b0a      	ldr	r3, [pc, #40]	; (80233fc <E_EEPROM_XMC4_Init+0xc4>)
 80233d4:	681b      	ldr	r3, [r3, #0]
 80233d6:	4a0c      	ldr	r2, [pc, #48]	; (8023408 <E_EEPROM_XMC4_Init+0xd0>)
 80233d8:	4293      	cmp	r3, r2
 80233da:	d902      	bls.n	80233e2 <E_EEPROM_XMC4_Init+0xaa>
          {
            e_eeprom_xmc4_sector_info.next_free_start_addr =  E_EEPROM_XMC4_SECTOR0_START_ADDR;
 80233dc:	4b07      	ldr	r3, [pc, #28]	; (80233fc <E_EEPROM_XMC4_Init+0xc4>)
 80233de:	4a09      	ldr	r2, [pc, #36]	; (8023404 <E_EEPROM_XMC4_Init+0xcc>)
 80233e0:	601a      	str	r2, [r3, #0]

        }
      }
    }

    XMC_FLASH_EnableDoubleBitErrorTrap();
 80233e2:	f7ff ff71 	bl	80232c8 <XMC_FLASH_EnableDoubleBitErrorTrap>

    handle->initialized = (bool)true;
 80233e6:	687b      	ldr	r3, [r7, #4]
 80233e8:	2201      	movs	r2, #1
 80233ea:	701a      	strb	r2, [r3, #0]
  }

  return (status);
 80233ec:	7afb      	ldrb	r3, [r7, #11]
}
 80233ee:	4618      	mov	r0, r3
 80233f0:	3710      	adds	r7, #16
 80233f2:	46bd      	mov	sp, r7
 80233f4:	bd80      	pop	{r7, pc}
 80233f6:	bf00      	nop
 80233f8:	1ffe997c 	.word	0x1ffe997c
 80233fc:	1ffe9418 	.word	0x1ffe9418
 8023400:	08028498 	.word	0x08028498
 8023404:	0c010000 	.word	0x0c010000
 8023408:	0c01ffff 	.word	0x0c01ffff

0802340c <E_EEPROM_XMC4_WriteArray>:



/* Update a set of bytes to RAM buffer*/
bool E_EEPROM_XMC4_WriteArray(const uint16_t offset_address, const uint8_t *const data, const uint16_t length)
{
 802340c:	b580      	push	{r7, lr}
 802340e:	b086      	sub	sp, #24
 8023410:	af00      	add	r7, sp, #0
 8023412:	4603      	mov	r3, r0
 8023414:	6039      	str	r1, [r7, #0]
 8023416:	80fb      	strh	r3, [r7, #6]
 8023418:	4613      	mov	r3, r2
 802341a:	80bb      	strh	r3, [r7, #4]
  bool status;

  XMC_ASSERT("E_EEPROM_XMC4_WriteArray: Wrong offset address", (offset_address < E_EEPROM_XMC4_DATA_BLOCK_SIZE));
  XMC_ASSERT("E_EEPROM_XMC4_WriteArray: Wrong length", ((offset_address + length) <= E_EEPROM_XMC4_DATA_BLOCK_SIZE));

  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
 802341c:	88fb      	ldrh	r3, [r7, #6]
 802341e:	4a13      	ldr	r2, [pc, #76]	; (802346c <E_EEPROM_XMC4_WriteArray+0x60>)
 8023420:	4413      	add	r3, r2
 8023422:	613b      	str	r3, [r7, #16]
  status = (memcmp(address_ptr, data, length) != 0);
 8023424:	88bb      	ldrh	r3, [r7, #4]
 8023426:	461a      	mov	r2, r3
 8023428:	6839      	ldr	r1, [r7, #0]
 802342a:	6938      	ldr	r0, [r7, #16]
 802342c:	f004 ff8a 	bl	8028344 <memcmp>
 8023430:	4603      	mov	r3, r0
 8023432:	2b00      	cmp	r3, #0
 8023434:	bf14      	ite	ne
 8023436:	2301      	movne	r3, #1
 8023438:	2300      	moveq	r3, #0
 802343a:	73fb      	strb	r3, [r7, #15]

  for (i = 0U; i < length; i++)
 802343c:	2300      	movs	r3, #0
 802343e:	82fb      	strh	r3, [r7, #22]
 8023440:	e00a      	b.n	8023458 <E_EEPROM_XMC4_WriteArray+0x4c>
  {
      *(address_ptr + i) = *(data + i);
 8023442:	8afb      	ldrh	r3, [r7, #22]
 8023444:	683a      	ldr	r2, [r7, #0]
 8023446:	441a      	add	r2, r3
 8023448:	8afb      	ldrh	r3, [r7, #22]
 802344a:	6939      	ldr	r1, [r7, #16]
 802344c:	440b      	add	r3, r1
 802344e:	7812      	ldrb	r2, [r2, #0]
 8023450:	701a      	strb	r2, [r3, #0]
  for (i = 0U; i < length; i++)
 8023452:	8afb      	ldrh	r3, [r7, #22]
 8023454:	3301      	adds	r3, #1
 8023456:	82fb      	strh	r3, [r7, #22]
 8023458:	8afa      	ldrh	r2, [r7, #22]
 802345a:	88bb      	ldrh	r3, [r7, #4]
 802345c:	429a      	cmp	r2, r3
 802345e:	d3f0      	bcc.n	8023442 <E_EEPROM_XMC4_WriteArray+0x36>
  }

  return status;
 8023460:	7bfb      	ldrb	r3, [r7, #15]
}
 8023462:	4618      	mov	r0, r3
 8023464:	3718      	adds	r7, #24
 8023466:	46bd      	mov	sp, r7
 8023468:	bd80      	pop	{r7, pc}
 802346a:	bf00      	nop
 802346c:	1ffe9984 	.word	0x1ffe9984

08023470 <E_EEPROM_XMC4_ReadArray>:



/* Read a set of bytes from RAM Buffer */
void E_EEPROM_XMC4_ReadArray(const uint16_t offset_address, uint8_t *const data, const uint16_t length)
{
 8023470:	b480      	push	{r7}
 8023472:	b085      	sub	sp, #20
 8023474:	af00      	add	r7, sp, #0
 8023476:	4603      	mov	r3, r0
 8023478:	6039      	str	r1, [r7, #0]
 802347a:	80fb      	strh	r3, [r7, #6]
 802347c:	4613      	mov	r3, r2
 802347e:	80bb      	strh	r3, [r7, #4]
  uint16_t i;
  uint8_t  *address_ptr;
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong offset address", (offset_address < E_EEPROM_XMC4_DATA_BLOCK_SIZE));
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong length", ((offset_address + length) <= E_EEPROM_XMC4_DATA_BLOCK_SIZE));
  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
 8023480:	88fb      	ldrh	r3, [r7, #6]
 8023482:	4a0e      	ldr	r2, [pc, #56]	; (80234bc <E_EEPROM_XMC4_ReadArray+0x4c>)
 8023484:	4413      	add	r3, r2
 8023486:	60bb      	str	r3, [r7, #8]

  for (i=0U; i<length; i++)
 8023488:	2300      	movs	r3, #0
 802348a:	81fb      	strh	r3, [r7, #14]
 802348c:	e00a      	b.n	80234a4 <E_EEPROM_XMC4_ReadArray+0x34>
  {
    *(data + i) = *(address_ptr + i);
 802348e:	89fb      	ldrh	r3, [r7, #14]
 8023490:	68ba      	ldr	r2, [r7, #8]
 8023492:	441a      	add	r2, r3
 8023494:	89fb      	ldrh	r3, [r7, #14]
 8023496:	6839      	ldr	r1, [r7, #0]
 8023498:	440b      	add	r3, r1
 802349a:	7812      	ldrb	r2, [r2, #0]
 802349c:	701a      	strb	r2, [r3, #0]
  for (i=0U; i<length; i++)
 802349e:	89fb      	ldrh	r3, [r7, #14]
 80234a0:	3301      	adds	r3, #1
 80234a2:	81fb      	strh	r3, [r7, #14]
 80234a4:	89fa      	ldrh	r2, [r7, #14]
 80234a6:	88bb      	ldrh	r3, [r7, #4]
 80234a8:	429a      	cmp	r2, r3
 80234aa:	d3f0      	bcc.n	802348e <E_EEPROM_XMC4_ReadArray+0x1e>
  }
}
 80234ac:	bf00      	nop
 80234ae:	bf00      	nop
 80234b0:	3714      	adds	r7, #20
 80234b2:	46bd      	mov	sp, r7
 80234b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80234b8:	4770      	bx	lr
 80234ba:	bf00      	nop
 80234bc:	1ffe9984 	.word	0x1ffe9984

080234c0 <E_EEPROM_XMC4_UpdateFlashContents>:



/* Copy data blocks from RAM to FLASH */
E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_UpdateFlashContents(void)
{
 80234c0:	b580      	push	{r7, lr}
 80234c2:	b082      	sub	sp, #8
 80234c4:	af00      	add	r7, sp, #0
  E_EEPROM_XMC4_STATUS_t status;
  uint32_t sector_start_addr;

  status = E_EEPROM_XMC4_STATUS_OK;
 80234c6:	2300      	movs	r3, #0
 80234c8:	71fb      	strb	r3, [r7, #7]

  /* Calculate the starting address of the active sector from where the first write started for the current cycle*/
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR +
                     (E_EEPROM_XMC4_SECTOR_SIZE * e_eeprom_xmc4_sector_info.current_sector);
 80234ca:	4b22      	ldr	r3, [pc, #136]	; (8023554 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 80234cc:	689b      	ldr	r3, [r3, #8]
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR +
 80234ce:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80234d2:	3304      	adds	r3, #4
 80234d4:	039b      	lsls	r3, r3, #14
 80234d6:	603b      	str	r3, [r7, #0]

  /* If the next free address crosses current active sector starting address, then all the sectors are fully written*/
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
 80234d8:	4b1e      	ldr	r3, [pc, #120]	; (8023554 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 80234da:	681b      	ldr	r3, [r3, #0]
 80234dc:	683a      	ldr	r2, [r7, #0]
 80234de:	429a      	cmp	r2, r3
 80234e0:	d111      	bne.n	8023506 <E_EEPROM_XMC4_UpdateFlashContents+0x46>
     (e_eeprom_xmc4_data_buffer.block_cycle_count != 0U))
 80234e2:	4b1d      	ldr	r3, [pc, #116]	; (8023558 <E_EEPROM_XMC4_UpdateFlashContents+0x98>)
 80234e4:	685b      	ldr	r3, [r3, #4]
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
 80234e6:	2b00      	cmp	r3, #0
 80234e8:	d00d      	beq.n	8023506 <E_EEPROM_XMC4_UpdateFlashContents+0x46>
  {
    /* Update the current sector to the latest sector on which the last write was executed. */
    e_eeprom_xmc4_sector_info.current_sector =  ((e_eeprom_xmc4_sector_info.flash_data_addr &
 80234ea:	4b1a      	ldr	r3, [pc, #104]	; (8023554 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 80234ec:	685b      	ldr	r3, [r3, #4]
                                                E_EEPROM_XMC4_SECTOR_POSITION_MASK) >>
 80234ee:	0b9b      	lsrs	r3, r3, #14
 80234f0:	f003 0303 	and.w	r3, r3, #3
    e_eeprom_xmc4_sector_info.current_sector =  ((e_eeprom_xmc4_sector_info.flash_data_addr &
 80234f4:	4a17      	ldr	r2, [pc, #92]	; (8023554 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 80234f6:	6093      	str	r3, [r2, #8]
                                                E_EEPROM_XMC4_SECTOR_POSITION);

    /* Mark all the sectors as filled with data */
    e_eeprom_xmc4_sector_info.erase_state = E_EEPROM_XMC4_ALL_SECTORS_FILLED ;
 80234f8:	4b16      	ldr	r3, [pc, #88]	; (8023554 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 80234fa:	220f      	movs	r2, #15
 80234fc:	60da      	str	r2, [r3, #12]

    /* Execute erase state machine to free up the unwanted sectors and keep only the sector which has latest block*/
    status = E_EEPROM_XMC4_lInitEraseStateMachine();
 80234fe:	f000 f8db 	bl	80236b8 <E_EEPROM_XMC4_lInitEraseStateMachine>
 8023502:	4603      	mov	r3, r0
 8023504:	71fb      	strb	r3, [r7, #7]
  }

  if (status ==  E_EEPROM_XMC4_STATUS_OK)
 8023506:	79fb      	ldrb	r3, [r7, #7]
 8023508:	2b00      	cmp	r3, #0
 802350a:	d11d      	bne.n	8023548 <E_EEPROM_XMC4_UpdateFlashContents+0x88>
  {
    e_eeprom_xmc4_data_buffer.block_cycle_count++;
 802350c:	4b12      	ldr	r3, [pc, #72]	; (8023558 <E_EEPROM_XMC4_UpdateFlashContents+0x98>)
 802350e:	685b      	ldr	r3, [r3, #4]
 8023510:	3301      	adds	r3, #1
 8023512:	4a11      	ldr	r2, [pc, #68]	; (8023558 <E_EEPROM_XMC4_UpdateFlashContents+0x98>)
 8023514:	6053      	str	r3, [r2, #4]

    status = E_EEPROM_XMC4_lWriteToFlash();
 8023516:	f000 f839 	bl	802358c <E_EEPROM_XMC4_lWriteToFlash>
 802351a:	4603      	mov	r3, r0
 802351c:	71fb      	strb	r3, [r7, #7]

    /* If the flash write succeeds, update the latest flash data location in RAM for reference */
    if (status == E_EEPROM_XMC4_STATUS_OK)
 802351e:	79fb      	ldrb	r3, [r7, #7]
 8023520:	2b00      	cmp	r3, #0
 8023522:	d103      	bne.n	802352c <E_EEPROM_XMC4_UpdateFlashContents+0x6c>
    {
      e_eeprom_xmc4_sector_info.flash_data_addr = e_eeprom_xmc4_sector_info.next_free_start_addr;
 8023524:	4b0b      	ldr	r3, [pc, #44]	; (8023554 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 8023526:	681b      	ldr	r3, [r3, #0]
 8023528:	4a0a      	ldr	r2, [pc, #40]	; (8023554 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 802352a:	6053      	str	r3, [r2, #4]
    }

    /* Update the next free address to write the new data block*/
    e_eeprom_xmc4_sector_info.next_free_start_addr += E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 802352c:	4b09      	ldr	r3, [pc, #36]	; (8023554 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 802352e:	681b      	ldr	r3, [r3, #0]
 8023530:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8023534:	4a07      	ldr	r2, [pc, #28]	; (8023554 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 8023536:	6013      	str	r3, [r2, #0]

    /* If the next free address crosses 3rd sector end address relocate the address to 0th sector starting address*/
    if (e_eeprom_xmc4_sector_info.next_free_start_addr >= E_EEPROM_XMC4_SECTOR4_START_ADDR)
 8023538:	4b06      	ldr	r3, [pc, #24]	; (8023554 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 802353a:	681b      	ldr	r3, [r3, #0]
 802353c:	4a07      	ldr	r2, [pc, #28]	; (802355c <E_EEPROM_XMC4_UpdateFlashContents+0x9c>)
 802353e:	4293      	cmp	r3, r2
 8023540:	d902      	bls.n	8023548 <E_EEPROM_XMC4_UpdateFlashContents+0x88>
    {
      e_eeprom_xmc4_sector_info.next_free_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR;
 8023542:	4b04      	ldr	r3, [pc, #16]	; (8023554 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 8023544:	4a06      	ldr	r2, [pc, #24]	; (8023560 <E_EEPROM_XMC4_UpdateFlashContents+0xa0>)
 8023546:	601a      	str	r2, [r3, #0]
    }
  }

  return (status);
 8023548:	79fb      	ldrb	r3, [r7, #7]
}
 802354a:	4618      	mov	r0, r3
 802354c:	3708      	adds	r7, #8
 802354e:	46bd      	mov	sp, r7
 8023550:	bd80      	pop	{r7, pc}
 8023552:	bf00      	nop
 8023554:	1ffe9418 	.word	0x1ffe9418
 8023558:	1ffe997c 	.word	0x1ffe997c
 802355c:	0c01ffff 	.word	0x0c01ffff
 8023560:	0c010000 	.word	0x0c010000

08023564 <E_EEPROM_XMC4_IsFlashEmpty>:


/* Check the availability data in the flash emulated EEPROM area */
bool E_EEPROM_XMC4_IsFlashEmpty(void)
{
 8023564:	b480      	push	{r7}
 8023566:	b083      	sub	sp, #12
 8023568:	af00      	add	r7, sp, #0
  bool status = false;
 802356a:	2300      	movs	r3, #0
 802356c:	71fb      	strb	r3, [r7, #7]

  /* If data available flash_data_addr will have a valid address*/
  if (e_eeprom_xmc4_sector_info.flash_data_addr == 0U)
 802356e:	4b06      	ldr	r3, [pc, #24]	; (8023588 <E_EEPROM_XMC4_IsFlashEmpty+0x24>)
 8023570:	685b      	ldr	r3, [r3, #4]
 8023572:	2b00      	cmp	r3, #0
 8023574:	d101      	bne.n	802357a <E_EEPROM_XMC4_IsFlashEmpty+0x16>
  {
    status = true;
 8023576:	2301      	movs	r3, #1
 8023578:	71fb      	strb	r3, [r7, #7]
  }
  return (status);
 802357a:	79fb      	ldrb	r3, [r7, #7]
}
 802357c:	4618      	mov	r0, r3
 802357e:	370c      	adds	r7, #12
 8023580:	46bd      	mov	sp, r7
 8023582:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023586:	4770      	bx	lr
 8023588:	1ffe9418 	.word	0x1ffe9418

0802358c <E_EEPROM_XMC4_lWriteToFlash>:
/* Private Functions ---------------------------------------------------------*/
/* ---------------------------------------------------------------------------*/

/* Local function to program data blocks from RAM into FLASH */
static E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_lWriteToFlash(void)
{
 802358c:	b580      	push	{r7, lr}
 802358e:	b084      	sub	sp, #16
 8023590:	af00      	add	r7, sp, #0
  uint32_t *flash_addr_ptr;
  uint32_t *ram_addr_ptr;
  uint32_t  page_index;
  E_EEPROM_XMC4_STATUS_t status;

  status = E_EEPROM_XMC4_STATUS_OK;
 8023592:	2300      	movs	r3, #0
 8023594:	70fb      	strb	r3, [r7, #3]
  flash_addr_ptr = (uint32_t*)e_eeprom_xmc4_sector_info.next_free_start_addr;
 8023596:	4b18      	ldr	r3, [pc, #96]	; (80235f8 <E_EEPROM_XMC4_lWriteToFlash+0x6c>)
 8023598:	681b      	ldr	r3, [r3, #0]
 802359a:	60fb      	str	r3, [r7, #12]
  ram_addr_ptr   = (uint32_t*)(void*)&e_eeprom_xmc4_data_buffer;
 802359c:	4b17      	ldr	r3, [pc, #92]	; (80235fc <E_EEPROM_XMC4_lWriteToFlash+0x70>)
 802359e:	60bb      	str	r3, [r7, #8]

  e_eeprom_xmc4_data_buffer.crc = E_EEPROM_XMC4_lCalculateCRC((uint32_t*)(void*)
 80235a0:	4817      	ldr	r0, [pc, #92]	; (8023600 <E_EEPROM_XMC4_lWriteToFlash+0x74>)
 80235a2:	f000 f8c9 	bl	8023738 <E_EEPROM_XMC4_lCalculateCRC>
 80235a6:	4603      	mov	r3, r0
 80235a8:	4a14      	ldr	r2, [pc, #80]	; (80235fc <E_EEPROM_XMC4_lWriteToFlash+0x70>)
 80235aa:	6013      	str	r3, [r2, #0]
                                                             (&(e_eeprom_xmc4_data_buffer.block_cycle_count)));

  for (page_index = 0U ; page_index < E_EEPROM_XMC4_MAX_PAGES; page_index++)
 80235ac:	2300      	movs	r3, #0
 80235ae:	607b      	str	r3, [r7, #4]
 80235b0:	e01a      	b.n	80235e8 <E_EEPROM_XMC4_lWriteToFlash+0x5c>
  {
    XMC_FLASH_ClearStatus();
 80235b2:	f000 f989 	bl	80238c8 <XMC_FLASH_ClearStatus>

    XMC_FLASH_ProgramPage(flash_addr_ptr,ram_addr_ptr);
 80235b6:	68b9      	ldr	r1, [r7, #8]
 80235b8:	68f8      	ldr	r0, [r7, #12]
 80235ba:	f000 f999 	bl	80238f0 <XMC_FLASH_ProgramPage>

    if ((XMC_FLASH_GetStatus() & (uint32_t)(XMC_FLASH_STATUS_VERIFY_ERROR | XMC_FLASH_STATUS_OPERATION_ERROR)) != 0)
 80235be:	f000 f989 	bl	80238d4 <XMC_FLASH_GetStatus>
 80235c2:	4602      	mov	r2, r0
 80235c4:	4b0f      	ldr	r3, [pc, #60]	; (8023604 <E_EEPROM_XMC4_lWriteToFlash+0x78>)
 80235c6:	4013      	ands	r3, r2
 80235c8:	2b00      	cmp	r3, #0
 80235ca:	d002      	beq.n	80235d2 <E_EEPROM_XMC4_lWriteToFlash+0x46>
    {
      status = E_EEPROM_XMC4_STATUS_WRITE_ERROR;
 80235cc:	2303      	movs	r3, #3
 80235ce:	70fb      	strb	r3, [r7, #3]
      break;
 80235d0:	e00d      	b.n	80235ee <E_EEPROM_XMC4_lWriteToFlash+0x62>
    }
    ram_addr_ptr   += E_EEPROM_XMC4_MIN_WORDS_PER_PAGE ;
 80235d2:	68bb      	ldr	r3, [r7, #8]
 80235d4:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80235d8:	60bb      	str	r3, [r7, #8]
    flash_addr_ptr += E_EEPROM_XMC4_MIN_WORDS_PER_PAGE ;
 80235da:	68fb      	ldr	r3, [r7, #12]
 80235dc:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80235e0:	60fb      	str	r3, [r7, #12]
  for (page_index = 0U ; page_index < E_EEPROM_XMC4_MAX_PAGES; page_index++)
 80235e2:	687b      	ldr	r3, [r7, #4]
 80235e4:	3301      	adds	r3, #1
 80235e6:	607b      	str	r3, [r7, #4]
 80235e8:	687b      	ldr	r3, [r7, #4]
 80235ea:	2b07      	cmp	r3, #7
 80235ec:	d9e1      	bls.n	80235b2 <E_EEPROM_XMC4_lWriteToFlash+0x26>
  }

  return (status);
 80235ee:	78fb      	ldrb	r3, [r7, #3]
}
 80235f0:	4618      	mov	r0, r3
 80235f2:	3710      	adds	r7, #16
 80235f4:	46bd      	mov	sp, r7
 80235f6:	bd80      	pop	{r7, pc}
 80235f8:	1ffe9418 	.word	0x1ffe9418
 80235fc:	1ffe997c 	.word	0x1ffe997c
 8023600:	1ffe9980 	.word	0x1ffe9980
 8023604:	80000100 	.word	0x80000100

08023608 <E_EEPROM_XMC4_lInitReadSectorInfo>:



static void E_EEPROM_XMC4_lInitReadSectorInfo(const uint32_t sector)
{
 8023608:	b580      	push	{r7, lr}
 802360a:	b08a      	sub	sp, #40	; 0x28
 802360c:	af00      	add	r7, sp, #0
 802360e:	6078      	str	r0, [r7, #4]
  uint32_t block_cycle_count;
  uint32_t written_crc;
  uint32_t calculated_crc;

  /* Initialize starting address and last block address of the sector. */
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector);
 8023610:	687b      	ldr	r3, [r7, #4]
 8023612:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8023616:	3304      	adds	r3, #4
 8023618:	039b      	lsls	r3, r3, #14
 802361a:	61fb      	str	r3, [r7, #28]
  block_read_addr = (sector_start_addr + E_EEPROM_XMC4_SECTOR_SIZE) - E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 802361c:	69fb      	ldr	r3, [r7, #28]
 802361e:	f503 5360 	add.w	r3, r3, #14336	; 0x3800
 8023622:	627b      	str	r3, [r7, #36]	; 0x24
  free_block_addr = E_EEPROM_XMC4_EMPTY;
 8023624:	2300      	movs	r3, #0
 8023626:	623b      	str	r3, [r7, #32]

  do
  {
    /* Read first 32 bit data from the block which indicates the block cycle counter. */
    data_ptr = (uint32_t*)block_read_addr;
 8023628:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802362a:	61bb      	str	r3, [r7, #24]
    block_cycle_count = *(data_ptr + E_EEPROM_XMC4_BCC_OFFSET);
 802362c:	69bb      	ldr	r3, [r7, #24]
 802362e:	685b      	ldr	r3, [r3, #4]
 8023630:	617b      	str	r3, [r7, #20]

    /* Check if block cycle count is a non zero value*/
    if (block_cycle_count != E_EEPROM_XMC4_EMPTY)
 8023632:	697b      	ldr	r3, [r7, #20]
 8023634:	2b00      	cmp	r3, #0
 8023636:	d02e      	beq.n	8023696 <E_EEPROM_XMC4_lInitReadSectorInfo+0x8e>
    {
      /* Mark sector as non-empty sector*/
      e_eeprom_xmc4_sector_info.erase_state |= ((uint32_t)1U << sector);
 8023638:	4b1d      	ldr	r3, [pc, #116]	; (80236b0 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa8>)
 802363a:	68da      	ldr	r2, [r3, #12]
 802363c:	2101      	movs	r1, #1
 802363e:	687b      	ldr	r3, [r7, #4]
 8023640:	fa01 f303 	lsl.w	r3, r1, r3
 8023644:	4313      	orrs	r3, r2
 8023646:	4a1a      	ldr	r2, [pc, #104]	; (80236b0 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa8>)
 8023648:	60d3      	str	r3, [r2, #12]

      /* If this is the first non empty block identified, then store the address as next free address */
      if (free_block_addr == E_EEPROM_XMC4_EMPTY)
 802364a:	6a3b      	ldr	r3, [r7, #32]
 802364c:	2b00      	cmp	r3, #0
 802364e:	d103      	bne.n	8023658 <E_EEPROM_XMC4_lInitReadSectorInfo+0x50>
      {
        free_block_addr = block_read_addr + E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 8023650:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8023652:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8023656:	623b      	str	r3, [r7, #32]
      }

      /* Read the second 32bit data which indicates the CRC */
      written_crc = *data_ptr;
 8023658:	69bb      	ldr	r3, [r7, #24]
 802365a:	681b      	ldr	r3, [r3, #0]
 802365c:	613b      	str	r3, [r7, #16]
      /* Calculate the CRC for the written data in flash (3rd word to the last word)*/
      calculated_crc = E_EEPROM_XMC4_lCalculateCRC(data_ptr + E_EEPROM_XMC4_BCC_OFFSET);
 802365e:	69bb      	ldr	r3, [r7, #24]
 8023660:	3304      	adds	r3, #4
 8023662:	4618      	mov	r0, r3
 8023664:	f000 f868 	bl	8023738 <E_EEPROM_XMC4_lCalculateCRC>
 8023668:	60f8      	str	r0, [r7, #12]

      if (calculated_crc == written_crc)
 802366a:	68fa      	ldr	r2, [r7, #12]
 802366c:	693b      	ldr	r3, [r7, #16]
 802366e:	429a      	cmp	r2, r3
 8023670:	d111      	bne.n	8023696 <E_EEPROM_XMC4_lInitReadSectorInfo+0x8e>
      {
        /* If both CRC matches and the current block cycle counter is greater than the previous recorded value,
         * Update the Data structure with the current block as the "latest" one and the current sector as "active".
         * Exit from the function.
         */
        if (block_cycle_count > e_eeprom_xmc4_data_buffer.block_cycle_count)
 8023672:	4b10      	ldr	r3, [pc, #64]	; (80236b4 <E_EEPROM_XMC4_lInitReadSectorInfo+0xac>)
 8023674:	685b      	ldr	r3, [r3, #4]
 8023676:	697a      	ldr	r2, [r7, #20]
 8023678:	429a      	cmp	r2, r3
 802367a:	d90c      	bls.n	8023696 <E_EEPROM_XMC4_lInitReadSectorInfo+0x8e>
        {
          e_eeprom_xmc4_data_buffer.block_cycle_count = block_cycle_count;
 802367c:	4a0d      	ldr	r2, [pc, #52]	; (80236b4 <E_EEPROM_XMC4_lInitReadSectorInfo+0xac>)
 802367e:	697b      	ldr	r3, [r7, #20]
 8023680:	6053      	str	r3, [r2, #4]
          e_eeprom_xmc4_sector_info.current_sector = sector;
 8023682:	4a0b      	ldr	r2, [pc, #44]	; (80236b0 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa8>)
 8023684:	687b      	ldr	r3, [r7, #4]
 8023686:	6093      	str	r3, [r2, #8]
          e_eeprom_xmc4_sector_info.flash_data_addr = block_read_addr;
 8023688:	4a09      	ldr	r2, [pc, #36]	; (80236b0 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa8>)
 802368a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802368c:	6053      	str	r3, [r2, #4]
          e_eeprom_xmc4_sector_info.next_free_start_addr = free_block_addr;
 802368e:	4a08      	ldr	r2, [pc, #32]	; (80236b0 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa8>)
 8023690:	6a3b      	ldr	r3, [r7, #32]
 8023692:	6013      	str	r3, [r2, #0]
          break;
 8023694:	e008      	b.n	80236a8 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa0>
        }
      }
    }
    /* Move the block read address to one block size up starting from the bottom of sector */
    block_read_addr -= E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 8023696:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8023698:	f5a3 6300 	sub.w	r3, r3, #2048	; 0x800
 802369c:	627b      	str	r3, [r7, #36]	; 0x24

  /* Iterate the read process until the block read address crosses sector start address or a
   * latest valid block is identified.
   */
  } while ( block_read_addr >= sector_start_addr );
 802369e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80236a0:	69fb      	ldr	r3, [r7, #28]
 80236a2:	429a      	cmp	r2, r3
 80236a4:	d2c0      	bcs.n	8023628 <E_EEPROM_XMC4_lInitReadSectorInfo+0x20>

}
 80236a6:	bf00      	nop
 80236a8:	bf00      	nop
 80236aa:	3728      	adds	r7, #40	; 0x28
 80236ac:	46bd      	mov	sp, r7
 80236ae:	bd80      	pop	{r7, pc}
 80236b0:	1ffe9418 	.word	0x1ffe9418
 80236b4:	1ffe997c 	.word	0x1ffe997c

080236b8 <E_EEPROM_XMC4_lInitEraseStateMachine>:



static E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_lInitEraseStateMachine(void)
{
 80236b8:	b580      	push	{r7, lr}
 80236ba:	b084      	sub	sp, #16
 80236bc:	af00      	add	r7, sp, #0
  uint32_t sector_count;
  uint32_t sector_start_addr;
  E_EEPROM_XMC4_STATUS_t status ;

  status = E_EEPROM_XMC4_STATUS_OK;
 80236be:	2300      	movs	r3, #0
 80236c0:	72fb      	strb	r3, [r7, #11]
  sector_count = 0U;
 80236c2:	2300      	movs	r3, #0
 80236c4:	60fb      	str	r3, [r7, #12]

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 80236c6:	4b1b      	ldr	r3, [pc, #108]	; (8023734 <E_EEPROM_XMC4_lInitEraseStateMachine+0x7c>)
 80236c8:	689b      	ldr	r3, [r3, #8]
 80236ca:	68fa      	ldr	r2, [r7, #12]
 80236cc:	429a      	cmp	r2, r3
 80236ce:	d026      	beq.n	802371e <E_EEPROM_XMC4_lInitEraseStateMachine+0x66>
    {
      /* Check if the sector was previously identified as non-empty. i.e It is having old data or corrupted data
       * If so erase the sector and mark it as erase attempted.
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
 80236d0:	4b18      	ldr	r3, [pc, #96]	; (8023734 <E_EEPROM_XMC4_lInitEraseStateMachine+0x7c>)
 80236d2:	68da      	ldr	r2, [r3, #12]
 80236d4:	68fb      	ldr	r3, [r7, #12]
 80236d6:	fa22 f303 	lsr.w	r3, r2, r3
 80236da:	f003 0301 	and.w	r3, r3, #1
 80236de:	2b00      	cmp	r3, #0
 80236e0:	d01d      	beq.n	802371e <E_EEPROM_XMC4_lInitEraseStateMachine+0x66>
      {
        sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector_count);
 80236e2:	68fb      	ldr	r3, [r7, #12]
 80236e4:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80236e8:	3304      	adds	r3, #4
 80236ea:	039b      	lsls	r3, r3, #14
 80236ec:	607b      	str	r3, [r7, #4]

        XMC_FLASH_ClearStatus();
 80236ee:	f000 f8eb 	bl	80238c8 <XMC_FLASH_ClearStatus>
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);
 80236f2:	687b      	ldr	r3, [r7, #4]
 80236f4:	4618      	mov	r0, r3
 80236f6:	f000 f92f 	bl	8023958 <XMC_FLASH_EraseSector>

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
 80236fa:	f000 f8eb 	bl	80238d4 <XMC_FLASH_GetStatus>
 80236fe:	4603      	mov	r3, r0
 8023700:	2b20      	cmp	r3, #32
 8023702:	d002      	beq.n	802370a <E_EEPROM_XMC4_lInitEraseStateMachine+0x52>
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
 8023704:	2304      	movs	r3, #4
 8023706:	72fb      	strb	r3, [r7, #11]
          break;
 8023708:	e00f      	b.n	802372a <E_EEPROM_XMC4_lInitEraseStateMachine+0x72>
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 802370a:	4b0a      	ldr	r3, [pc, #40]	; (8023734 <E_EEPROM_XMC4_lInitEraseStateMachine+0x7c>)
 802370c:	68da      	ldr	r2, [r3, #12]
 802370e:	2101      	movs	r1, #1
 8023710:	68fb      	ldr	r3, [r7, #12]
 8023712:	fa01 f303 	lsl.w	r3, r1, r3
 8023716:	43db      	mvns	r3, r3
 8023718:	4013      	ands	r3, r2
 802371a:	4a06      	ldr	r2, [pc, #24]	; (8023734 <E_EEPROM_XMC4_lInitEraseStateMachine+0x7c>)
 802371c:	60d3      	str	r3, [r2, #12]
      }
    }
    sector_count++;
 802371e:	68fb      	ldr	r3, [r7, #12]
 8023720:	3301      	adds	r3, #1
 8023722:	60fb      	str	r3, [r7, #12]
    /* Iterate the erase loop until all 4 sectors are checked. Break and return failure on any sector erase errors.*/
  } while ( sector_count < E_EEPROM_XMC4_MAX_SECTORS );
 8023724:	68fb      	ldr	r3, [r7, #12]
 8023726:	2b03      	cmp	r3, #3
 8023728:	d9cd      	bls.n	80236c6 <E_EEPROM_XMC4_lInitEraseStateMachine+0xe>

  return (status);
 802372a:	7afb      	ldrb	r3, [r7, #11]
}
 802372c:	4618      	mov	r0, r3
 802372e:	3710      	adds	r7, #16
 8023730:	46bd      	mov	sp, r7
 8023732:	bd80      	pop	{r7, pc}
 8023734:	1ffe9418 	.word	0x1ffe9418

08023738 <E_EEPROM_XMC4_lCalculateCRC>:

/* Local function to CRC */
static uint32_t E_EEPROM_XMC4_lCalculateCRC(const uint32_t *data_start_addr)
{
 8023738:	b580      	push	{r7, lr}
 802373a:	b084      	sub	sp, #16
 802373c:	af00      	add	r7, sp, #0
 802373e:	6078      	str	r0, [r7, #4]
  uint32_t result;

  /* Reset the CRC result register before new CRC calculation */
  XMC_FCE_InitializeSeedValue(&e_eeprom_xmc4_fce, 0U);
 8023740:	2100      	movs	r1, #0
 8023742:	4808      	ldr	r0, [pc, #32]	; (8023764 <E_EEPROM_XMC4_lCalculateCRC+0x2c>)
 8023744:	f7ff fde8 	bl	8023318 <XMC_FCE_InitializeSeedValue>

  (void)XMC_FCE_CalculateCRC32(&e_eeprom_xmc4_fce, data_start_addr, E_EEPROM_XMC4_DATA_SIZE_FOR_CRC, &result);
 8023748:	f107 030c 	add.w	r3, r7, #12
 802374c:	f240 72fc 	movw	r2, #2044	; 0x7fc
 8023750:	6879      	ldr	r1, [r7, #4]
 8023752:	4804      	ldr	r0, [pc, #16]	; (8023764 <E_EEPROM_XMC4_lCalculateCRC+0x2c>)
 8023754:	f002 f832 	bl	80257bc <XMC_FCE_CalculateCRC32>

  return (result);
 8023758:	68fb      	ldr	r3, [r7, #12]
}
 802375a:	4618      	mov	r0, r3
 802375c:	3710      	adds	r7, #16
 802375e:	46bd      	mov	sp, r7
 8023760:	bd80      	pop	{r7, pc}
 8023762:	bf00      	nop
 8023764:	08028498 	.word	0x08028498

08023768 <E_EEPROM_XMC4_lCopyFlashToRam>:



/* Local function to copy data blocks from FLASH to RAM */
static void E_EEPROM_XMC4_lCopyFlashToRam(void)
{
 8023768:	b480      	push	{r7}
 802376a:	b085      	sub	sp, #20
 802376c:	af00      	add	r7, sp, #0
  uint32_t *flash_addr_ptr;
  uint32_t *ram_addr_ptr;
  uint32_t byte_index;

  flash_addr_ptr = (uint32_t*)e_eeprom_xmc4_sector_info.flash_data_addr;
 802376e:	4b10      	ldr	r3, [pc, #64]	; (80237b0 <E_EEPROM_XMC4_lCopyFlashToRam+0x48>)
 8023770:	685b      	ldr	r3, [r3, #4]
 8023772:	60bb      	str	r3, [r7, #8]
  ram_addr_ptr = (uint32_t*)(void*)&e_eeprom_xmc4_data_buffer;
 8023774:	4b0f      	ldr	r3, [pc, #60]	; (80237b4 <E_EEPROM_XMC4_lCopyFlashToRam+0x4c>)
 8023776:	607b      	str	r3, [r7, #4]

  for(byte_index = 0U ; byte_index < E_EEPROM_XMC4_MAX_WORDS; byte_index++)
 8023778:	2300      	movs	r3, #0
 802377a:	60fb      	str	r3, [r7, #12]
 802377c:	e00c      	b.n	8023798 <E_EEPROM_XMC4_lCopyFlashToRam+0x30>
  {
    *(ram_addr_ptr + byte_index) = *(flash_addr_ptr + byte_index);
 802377e:	68fb      	ldr	r3, [r7, #12]
 8023780:	009b      	lsls	r3, r3, #2
 8023782:	68ba      	ldr	r2, [r7, #8]
 8023784:	441a      	add	r2, r3
 8023786:	68fb      	ldr	r3, [r7, #12]
 8023788:	009b      	lsls	r3, r3, #2
 802378a:	6879      	ldr	r1, [r7, #4]
 802378c:	440b      	add	r3, r1
 802378e:	6812      	ldr	r2, [r2, #0]
 8023790:	601a      	str	r2, [r3, #0]
  for(byte_index = 0U ; byte_index < E_EEPROM_XMC4_MAX_WORDS; byte_index++)
 8023792:	68fb      	ldr	r3, [r7, #12]
 8023794:	3301      	adds	r3, #1
 8023796:	60fb      	str	r3, [r7, #12]
 8023798:	68fb      	ldr	r3, [r7, #12]
 802379a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 802379e:	d3ee      	bcc.n	802377e <E_EEPROM_XMC4_lCopyFlashToRam+0x16>
  }
}
 80237a0:	bf00      	nop
 80237a2:	bf00      	nop
 80237a4:	3714      	adds	r7, #20
 80237a6:	46bd      	mov	sp, r7
 80237a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80237ac:	4770      	bx	lr
 80237ae:	bf00      	nop
 80237b0:	1ffe9418 	.word	0x1ffe9418
 80237b4:	1ffe997c 	.word	0x1ffe997c

080237b8 <XMC_FLASH_lEnterPageModeCommand>:

/*
 * Command to program the PFLASH in to page mode, so that assembly buffer is used
 */
void XMC_FLASH_lEnterPageModeCommand(void)
{
 80237b8:	b480      	push	{r7}
 80237ba:	b083      	sub	sp, #12
 80237bc:	af00      	add	r7, sp, #0
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 80237be:	4b05      	ldr	r3, [pc, #20]	; (80237d4 <XMC_FLASH_lEnterPageModeCommand+0x1c>)
 80237c0:	607b      	str	r3, [r7, #4]
  *address = (uint32_t)0x50U;
 80237c2:	687b      	ldr	r3, [r7, #4]
 80237c4:	2250      	movs	r2, #80	; 0x50
 80237c6:	601a      	str	r2, [r3, #0]
}
 80237c8:	bf00      	nop
 80237ca:	370c      	adds	r7, #12
 80237cc:	46bd      	mov	sp, r7
 80237ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80237d2:	4770      	bx	lr
 80237d4:	0c005554 	.word	0x0c005554

080237d8 <XMC_FLASH_lLoadPageCommand>:

/*
 * Command to load the data into the page assembly buffer
 */
void XMC_FLASH_lLoadPageCommand(uint32_t low_word, uint32_t high_word)
{
 80237d8:	b480      	push	{r7}
 80237da:	b085      	sub	sp, #20
 80237dc:	af00      	add	r7, sp, #0
 80237de:	6078      	str	r0, [r7, #4]
 80237e0:	6039      	str	r1, [r7, #0]
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x55f0U);
 80237e2:	4b08      	ldr	r3, [pc, #32]	; (8023804 <XMC_FLASH_lLoadPageCommand+0x2c>)
 80237e4:	60fb      	str	r3, [r7, #12]
  *address = low_word;
 80237e6:	68fb      	ldr	r3, [r7, #12]
 80237e8:	687a      	ldr	r2, [r7, #4]
 80237ea:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x55f4U);
 80237ec:	4b06      	ldr	r3, [pc, #24]	; (8023808 <XMC_FLASH_lLoadPageCommand+0x30>)
 80237ee:	60fb      	str	r3, [r7, #12]
  *address = high_word;
 80237f0:	68fb      	ldr	r3, [r7, #12]
 80237f2:	683a      	ldr	r2, [r7, #0]
 80237f4:	601a      	str	r2, [r3, #0]
}
 80237f6:	bf00      	nop
 80237f8:	3714      	adds	r7, #20
 80237fa:	46bd      	mov	sp, r7
 80237fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023800:	4770      	bx	lr
 8023802:	bf00      	nop
 8023804:	0c0055f0 	.word	0x0c0055f0
 8023808:	0c0055f4 	.word	0x0c0055f4

0802380c <XMC_FLASH_lWritePageCommand>:

/*
 * Command to start the programming of one page with data from the assembly buffer
 */
void XMC_FLASH_lWritePageCommand(uint32_t *page_start_address)
{
 802380c:	b480      	push	{r7}
 802380e:	b085      	sub	sp, #20
 8023810:	af00      	add	r7, sp, #0
 8023812:	6078      	str	r0, [r7, #4]
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 8023814:	4b0c      	ldr	r3, [pc, #48]	; (8023848 <XMC_FLASH_lWritePageCommand+0x3c>)
 8023816:	60fb      	str	r3, [r7, #12]
  *address = 0xaaU;
 8023818:	68fb      	ldr	r3, [r7, #12]
 802381a:	22aa      	movs	r2, #170	; 0xaa
 802381c:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
 802381e:	4b0b      	ldr	r3, [pc, #44]	; (802384c <XMC_FLASH_lWritePageCommand+0x40>)
 8023820:	60fb      	str	r3, [r7, #12]
  *address = 0x55U;
 8023822:	68fb      	ldr	r3, [r7, #12]
 8023824:	2255      	movs	r2, #85	; 0x55
 8023826:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 8023828:	4b07      	ldr	r3, [pc, #28]	; (8023848 <XMC_FLASH_lWritePageCommand+0x3c>)
 802382a:	60fb      	str	r3, [r7, #12]
  *address = 0xa0U;
 802382c:	68fb      	ldr	r3, [r7, #12]
 802382e:	22a0      	movs	r2, #160	; 0xa0
 8023830:	601a      	str	r2, [r3, #0]
  address = page_start_address;
 8023832:	687b      	ldr	r3, [r7, #4]
 8023834:	60fb      	str	r3, [r7, #12]
  *address = 0xaaU;
 8023836:	68fb      	ldr	r3, [r7, #12]
 8023838:	22aa      	movs	r2, #170	; 0xaa
 802383a:	601a      	str	r2, [r3, #0]
}
 802383c:	bf00      	nop
 802383e:	3714      	adds	r7, #20
 8023840:	46bd      	mov	sp, r7
 8023842:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023846:	4770      	bx	lr
 8023848:	0c005554 	.word	0x0c005554
 802384c:	0c00aaa8 	.word	0x0c00aaa8

08023850 <XMC_FLASH_lEraseSectorCommand>:

/*
 * Command to erase sector which is starting with the specified address
 */
void XMC_FLASH_lEraseSectorCommand(uint32_t *sector_start_address)
{
 8023850:	b480      	push	{r7}
 8023852:	b085      	sub	sp, #20
 8023854:	af00      	add	r7, sp, #0
 8023856:	6078      	str	r0, [r7, #4]
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 8023858:	4b11      	ldr	r3, [pc, #68]	; (80238a0 <XMC_FLASH_lEraseSectorCommand+0x50>)
 802385a:	60fb      	str	r3, [r7, #12]
  *address = 0xaaU;
 802385c:	68fb      	ldr	r3, [r7, #12]
 802385e:	22aa      	movs	r2, #170	; 0xaa
 8023860:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
 8023862:	4b10      	ldr	r3, [pc, #64]	; (80238a4 <XMC_FLASH_lEraseSectorCommand+0x54>)
 8023864:	60fb      	str	r3, [r7, #12]
  *address = 0x55U;
 8023866:	68fb      	ldr	r3, [r7, #12]
 8023868:	2255      	movs	r2, #85	; 0x55
 802386a:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 802386c:	4b0c      	ldr	r3, [pc, #48]	; (80238a0 <XMC_FLASH_lEraseSectorCommand+0x50>)
 802386e:	60fb      	str	r3, [r7, #12]
  *address = 0x80U;
 8023870:	68fb      	ldr	r3, [r7, #12]
 8023872:	2280      	movs	r2, #128	; 0x80
 8023874:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 8023876:	4b0a      	ldr	r3, [pc, #40]	; (80238a0 <XMC_FLASH_lEraseSectorCommand+0x50>)
 8023878:	60fb      	str	r3, [r7, #12]
  *address = 0xaaU;
 802387a:	68fb      	ldr	r3, [r7, #12]
 802387c:	22aa      	movs	r2, #170	; 0xaa
 802387e:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
 8023880:	4b08      	ldr	r3, [pc, #32]	; (80238a4 <XMC_FLASH_lEraseSectorCommand+0x54>)
 8023882:	60fb      	str	r3, [r7, #12]
  *address = 0x55U;
 8023884:	68fb      	ldr	r3, [r7, #12]
 8023886:	2255      	movs	r2, #85	; 0x55
 8023888:	601a      	str	r2, [r3, #0]
  address = sector_start_address;
 802388a:	687b      	ldr	r3, [r7, #4]
 802388c:	60fb      	str	r3, [r7, #12]
  *address = 0x30U;
 802388e:	68fb      	ldr	r3, [r7, #12]
 8023890:	2230      	movs	r2, #48	; 0x30
 8023892:	601a      	str	r2, [r3, #0]
}
 8023894:	bf00      	nop
 8023896:	3714      	adds	r7, #20
 8023898:	46bd      	mov	sp, r7
 802389a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802389e:	4770      	bx	lr
 80238a0:	0c005554 	.word	0x0c005554
 80238a4:	0c00aaa8 	.word	0x0c00aaa8

080238a8 <XMC_FLASH_lClearStatusCommand>:

/*
 * Command to clear FSR.PROG and FSR.ERASE and the error flags in FSR such as PFOPER, SQER, PROER, PFDBER, ORIER, VER
 */
void XMC_FLASH_lClearStatusCommand(void)
{
 80238a8:	b480      	push	{r7}
 80238aa:	b083      	sub	sp, #12
 80238ac:	af00      	add	r7, sp, #0
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 80238ae:	4b05      	ldr	r3, [pc, #20]	; (80238c4 <XMC_FLASH_lClearStatusCommand+0x1c>)
 80238b0:	607b      	str	r3, [r7, #4]
  *address = 0xf5U;
 80238b2:	687b      	ldr	r3, [r7, #4]
 80238b4:	22f5      	movs	r2, #245	; 0xf5
 80238b6:	601a      	str	r2, [r3, #0]
}
 80238b8:	bf00      	nop
 80238ba:	370c      	adds	r7, #12
 80238bc:	46bd      	mov	sp, r7
 80238be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80238c2:	4770      	bx	lr
 80238c4:	0c005554 	.word	0x0c005554

080238c8 <XMC_FLASH_ClearStatus>:

/*
* This API shall clear Program, erase and error flags(PFOPER, SQER, PROER, PFDBER, ORIER, VER) of FSR register.
*/
void XMC_FLASH_ClearStatus(void)
{
 80238c8:	b580      	push	{r7, lr}
 80238ca:	af00      	add	r7, sp, #0
  XMC_FLASH_lClearStatusCommand();
 80238cc:	f7ff ffec 	bl	80238a8 <XMC_FLASH_lClearStatusCommand>
}
 80238d0:	bf00      	nop
 80238d2:	bd80      	pop	{r7, pc}

080238d4 <XMC_FLASH_GetStatus>:

/*
 * This API returns the FSR register value
 */
uint32_t XMC_FLASH_GetStatus(void)
{
 80238d4:	b480      	push	{r7}
 80238d6:	af00      	add	r7, sp, #0
  return FLASH0->FSR;
 80238d8:	4b04      	ldr	r3, [pc, #16]	; (80238ec <XMC_FLASH_GetStatus+0x18>)
 80238da:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80238de:	691b      	ldr	r3, [r3, #16]
}
 80238e0:	4618      	mov	r0, r3
 80238e2:	46bd      	mov	sp, r7
 80238e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80238e8:	4770      	bx	lr
 80238ea:	bf00      	nop
 80238ec:	58001000 	.word	0x58001000

080238f0 <XMC_FLASH_ProgramPage>:

/*
 * This API write the PFLASH page
 */
void XMC_FLASH_ProgramPage(uint32_t *address, const uint32_t *data)
{
 80238f0:	b580      	push	{r7, lr}
 80238f2:	b084      	sub	sp, #16
 80238f4:	af00      	add	r7, sp, #0
 80238f6:	6078      	str	r0, [r7, #4]
 80238f8:	6039      	str	r1, [r7, #0]
  uint32_t idx;

  XMC_FLASH_lClearStatusCommand();
 80238fa:	f7ff ffd5 	bl	80238a8 <XMC_FLASH_lClearStatusCommand>
  XMC_FLASH_lEnterPageModeCommand();
 80238fe:	f7ff ff5b 	bl	80237b8 <XMC_FLASH_lEnterPageModeCommand>

  for (idx = 0U; idx < XMC_FLASH_WORDS_PER_PAGE; idx += 2U)
 8023902:	2300      	movs	r3, #0
 8023904:	60fb      	str	r3, [r7, #12]
 8023906:	e010      	b.n	802392a <XMC_FLASH_ProgramPage+0x3a>
  {
    XMC_FLASH_lLoadPageCommand(data[idx], data[idx + 1U]);
 8023908:	68fb      	ldr	r3, [r7, #12]
 802390a:	009b      	lsls	r3, r3, #2
 802390c:	683a      	ldr	r2, [r7, #0]
 802390e:	4413      	add	r3, r2
 8023910:	6818      	ldr	r0, [r3, #0]
 8023912:	68fb      	ldr	r3, [r7, #12]
 8023914:	3301      	adds	r3, #1
 8023916:	009b      	lsls	r3, r3, #2
 8023918:	683a      	ldr	r2, [r7, #0]
 802391a:	4413      	add	r3, r2
 802391c:	681b      	ldr	r3, [r3, #0]
 802391e:	4619      	mov	r1, r3
 8023920:	f7ff ff5a 	bl	80237d8 <XMC_FLASH_lLoadPageCommand>
  for (idx = 0U; idx < XMC_FLASH_WORDS_PER_PAGE; idx += 2U)
 8023924:	68fb      	ldr	r3, [r7, #12]
 8023926:	3302      	adds	r3, #2
 8023928:	60fb      	str	r3, [r7, #12]
 802392a:	68fb      	ldr	r3, [r7, #12]
 802392c:	2b3f      	cmp	r3, #63	; 0x3f
 802392e:	d9eb      	bls.n	8023908 <XMC_FLASH_ProgramPage+0x18>
  }

  XMC_FLASH_lWritePageCommand(address);
 8023930:	6878      	ldr	r0, [r7, #4]
 8023932:	f7ff ff6b 	bl	802380c <XMC_FLASH_lWritePageCommand>

  /* wait until the operation is completed */
  while ((FLASH0->FSR & (uint32_t)FLASH_FSR_PBUSY_Msk) != 0U) {}
 8023936:	bf00      	nop
 8023938:	4b06      	ldr	r3, [pc, #24]	; (8023954 <XMC_FLASH_ProgramPage+0x64>)
 802393a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 802393e:	691b      	ldr	r3, [r3, #16]
 8023940:	f003 0301 	and.w	r3, r3, #1
 8023944:	2b00      	cmp	r3, #0
 8023946:	d1f7      	bne.n	8023938 <XMC_FLASH_ProgramPage+0x48>
}
 8023948:	bf00      	nop
 802394a:	bf00      	nop
 802394c:	3710      	adds	r7, #16
 802394e:	46bd      	mov	sp, r7
 8023950:	bd80      	pop	{r7, pc}
 8023952:	bf00      	nop
 8023954:	58001000 	.word	0x58001000

08023958 <XMC_FLASH_EraseSector>:

/*
 * This API erase the logical sector
 */
void XMC_FLASH_EraseSector(uint32_t *address)
{
 8023958:	b580      	push	{r7, lr}
 802395a:	b082      	sub	sp, #8
 802395c:	af00      	add	r7, sp, #0
 802395e:	6078      	str	r0, [r7, #4]
  XMC_FLASH_lClearStatusCommand();
 8023960:	f7ff ffa2 	bl	80238a8 <XMC_FLASH_lClearStatusCommand>
  XMC_FLASH_lEraseSectorCommand(address);
 8023964:	6878      	ldr	r0, [r7, #4]
 8023966:	f7ff ff73 	bl	8023850 <XMC_FLASH_lEraseSectorCommand>

  /* wait until the operation is completed */
  while ((FLASH0->FSR & (uint32_t)FLASH_FSR_PBUSY_Msk) != 0U) {}
 802396a:	bf00      	nop
 802396c:	4b06      	ldr	r3, [pc, #24]	; (8023988 <XMC_FLASH_EraseSector+0x30>)
 802396e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8023972:	691b      	ldr	r3, [r3, #16]
 8023974:	f003 0301 	and.w	r3, r3, #1
 8023978:	2b00      	cmp	r3, #0
 802397a:	d1f7      	bne.n	802396c <XMC_FLASH_EraseSector+0x14>
}
 802397c:	bf00      	nop
 802397e:	bf00      	nop
 8023980:	3708      	adds	r7, #8
 8023982:	46bd      	mov	sp, r7
 8023984:	bd80      	pop	{r7, pc}
 8023986:	bf00      	nop
 8023988:	58001000 	.word	0x58001000

0802398c <XMC_GPIO_Init>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const config)
{
 802398c:	b480      	push	{r7}
 802398e:	b085      	sub	sp, #20
 8023990:	af00      	add	r7, sp, #0
 8023992:	60f8      	str	r0, [r7, #12]
 8023994:	460b      	mov	r3, r1
 8023996:	607a      	str	r2, [r7, #4]
 8023998:	72fb      	strb	r3, [r7, #11]
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));

  /* Switch to input */
  port->IOCR[pin >> 2U] &= (uint32_t)~(PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
 802399a:	7afb      	ldrb	r3, [r7, #11]
 802399c:	089b      	lsrs	r3, r3, #2
 802399e:	b2db      	uxtb	r3, r3
 80239a0:	461a      	mov	r2, r3
 80239a2:	68fb      	ldr	r3, [r7, #12]
 80239a4:	3204      	adds	r2, #4
 80239a6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80239aa:	7afb      	ldrb	r3, [r7, #11]
 80239ac:	f003 0303 	and.w	r3, r3, #3
 80239b0:	00db      	lsls	r3, r3, #3
 80239b2:	21f8      	movs	r1, #248	; 0xf8
 80239b4:	fa01 f303 	lsl.w	r3, r1, r3
 80239b8:	43db      	mvns	r3, r3
 80239ba:	7af9      	ldrb	r1, [r7, #11]
 80239bc:	0889      	lsrs	r1, r1, #2
 80239be:	b2c9      	uxtb	r1, r1
 80239c0:	4608      	mov	r0, r1
 80239c2:	ea02 0103 	and.w	r1, r2, r3
 80239c6:	68fb      	ldr	r3, [r7, #12]
 80239c8:	1d02      	adds	r2, r0, #4
 80239ca:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
 80239ce:	68fb      	ldr	r3, [r7, #12]
 80239d0:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80239d2:	7afb      	ldrb	r3, [r7, #11]
 80239d4:	005b      	lsls	r3, r3, #1
 80239d6:	2103      	movs	r1, #3
 80239d8:	fa01 f303 	lsl.w	r3, r1, r3
 80239dc:	43db      	mvns	r3, r3
 80239de:	401a      	ands	r2, r3
 80239e0:	68fb      	ldr	r3, [r7, #12]
 80239e2:	675a      	str	r2, [r3, #116]	; 0x74


  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
 80239e4:	68fb      	ldr	r3, [r7, #12]
 80239e6:	4a3a      	ldr	r2, [pc, #232]	; (8023ad0 <XMC_GPIO_Init+0x144>)
 80239e8:	4293      	cmp	r3, r2
 80239ea:	d003      	beq.n	80239f4 <XMC_GPIO_Init+0x68>
 80239ec:	68fb      	ldr	r3, [r7, #12]
 80239ee:	4a39      	ldr	r2, [pc, #228]	; (8023ad4 <XMC_GPIO_Init+0x148>)
 80239f0:	4293      	cmp	r3, r2
 80239f2:	d10a      	bne.n	8023a0a <XMC_GPIO_Init+0x7e>
  {
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
 80239f4:	68fb      	ldr	r3, [r7, #12]
 80239f6:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80239f8:	7afb      	ldrb	r3, [r7, #11]
 80239fa:	2101      	movs	r1, #1
 80239fc:	fa01 f303 	lsl.w	r3, r1, r3
 8023a00:	43db      	mvns	r3, r3
 8023a02:	401a      	ands	r2, r3
 8023a04:	68fb      	ldr	r3, [r7, #12]
 8023a06:	661a      	str	r2, [r3, #96]	; 0x60
 8023a08:	e041      	b.n	8023a8e <XMC_GPIO_Init+0x102>
  }
  else
  {
    if ((config->mode & XMC_GPIO_MODE_OE) != 0)
 8023a0a:	687b      	ldr	r3, [r7, #4]
 8023a0c:	781b      	ldrb	r3, [r3, #0]
 8023a0e:	b25b      	sxtb	r3, r3
 8023a10:	2b00      	cmp	r3, #0
 8023a12:	da3c      	bge.n	8023a8e <XMC_GPIO_Init+0x102>
    {
      /* If output is enabled */

      /* Set output level */
      port->OMR = (uint32_t)config->output_level << pin;
 8023a14:	687b      	ldr	r3, [r7, #4]
 8023a16:	685a      	ldr	r2, [r3, #4]
 8023a18:	7afb      	ldrb	r3, [r7, #11]
 8023a1a:	409a      	lsls	r2, r3
 8023a1c:	68fb      	ldr	r3, [r7, #12]
 8023a1e:	605a      	str	r2, [r3, #4]

      /* Set output driver strength */
      port->PDR[pin >> 3U] &= (uint32_t)~(PORT_PDR_Msk << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U)));
 8023a20:	7afb      	ldrb	r3, [r7, #11]
 8023a22:	08db      	lsrs	r3, r3, #3
 8023a24:	b2db      	uxtb	r3, r3
 8023a26:	461a      	mov	r2, r3
 8023a28:	68fb      	ldr	r3, [r7, #12]
 8023a2a:	3210      	adds	r2, #16
 8023a2c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8023a30:	7afb      	ldrb	r3, [r7, #11]
 8023a32:	f003 0307 	and.w	r3, r3, #7
 8023a36:	009b      	lsls	r3, r3, #2
 8023a38:	2107      	movs	r1, #7
 8023a3a:	fa01 f303 	lsl.w	r3, r1, r3
 8023a3e:	43db      	mvns	r3, r3
 8023a40:	7af9      	ldrb	r1, [r7, #11]
 8023a42:	08c9      	lsrs	r1, r1, #3
 8023a44:	b2c9      	uxtb	r1, r1
 8023a46:	4608      	mov	r0, r1
 8023a48:	ea02 0103 	and.w	r1, r2, r3
 8023a4c:	68fb      	ldr	r3, [r7, #12]
 8023a4e:	f100 0210 	add.w	r2, r0, #16
 8023a52:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      port->PDR[pin >> 3U] |= (uint32_t)config->output_strength << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U));
 8023a56:	7afb      	ldrb	r3, [r7, #11]
 8023a58:	08db      	lsrs	r3, r3, #3
 8023a5a:	b2db      	uxtb	r3, r3
 8023a5c:	461a      	mov	r2, r3
 8023a5e:	68fb      	ldr	r3, [r7, #12]
 8023a60:	3210      	adds	r2, #16
 8023a62:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8023a66:	687b      	ldr	r3, [r7, #4]
 8023a68:	7a1b      	ldrb	r3, [r3, #8]
 8023a6a:	4619      	mov	r1, r3
 8023a6c:	7afb      	ldrb	r3, [r7, #11]
 8023a6e:	f003 0307 	and.w	r3, r3, #7
 8023a72:	009b      	lsls	r3, r3, #2
 8023a74:	fa01 f303 	lsl.w	r3, r1, r3
 8023a78:	7af9      	ldrb	r1, [r7, #11]
 8023a7a:	08c9      	lsrs	r1, r1, #3
 8023a7c:	b2c9      	uxtb	r1, r1
 8023a7e:	4608      	mov	r0, r1
 8023a80:	ea42 0103 	orr.w	r1, r2, r3
 8023a84:	68fb      	ldr	r3, [r7, #12]
 8023a86:	f100 0210 	add.w	r2, r0, #16
 8023a8a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }
  }

  /* Set mode */
  port->IOCR[pin >> 2U] |= (uint32_t)config->mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
 8023a8e:	7afb      	ldrb	r3, [r7, #11]
 8023a90:	089b      	lsrs	r3, r3, #2
 8023a92:	b2db      	uxtb	r3, r3
 8023a94:	461a      	mov	r2, r3
 8023a96:	68fb      	ldr	r3, [r7, #12]
 8023a98:	3204      	adds	r2, #4
 8023a9a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8023a9e:	687b      	ldr	r3, [r7, #4]
 8023aa0:	781b      	ldrb	r3, [r3, #0]
 8023aa2:	4619      	mov	r1, r3
 8023aa4:	7afb      	ldrb	r3, [r7, #11]
 8023aa6:	f003 0303 	and.w	r3, r3, #3
 8023aaa:	00db      	lsls	r3, r3, #3
 8023aac:	fa01 f303 	lsl.w	r3, r1, r3
 8023ab0:	7af9      	ldrb	r1, [r7, #11]
 8023ab2:	0889      	lsrs	r1, r1, #2
 8023ab4:	b2c9      	uxtb	r1, r1
 8023ab6:	4608      	mov	r0, r1
 8023ab8:	ea42 0103 	orr.w	r1, r2, r3
 8023abc:	68fb      	ldr	r3, [r7, #12]
 8023abe:	1d02      	adds	r2, r0, #4
 8023ac0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8023ac4:	bf00      	nop
 8023ac6:	3714      	adds	r7, #20
 8023ac8:	46bd      	mov	sp, r7
 8023aca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023ace:	4770      	bx	lr
 8023ad0:	48028e00 	.word	0x48028e00
 8023ad4:	48028f00 	.word	0x48028f00

08023ad8 <XMC_SCU_CLOCK_GetCpuClockFrequency>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_SCU_CLOCK_GetPeripheralClockFrequency(), XMC_SCU_CLOCK_GatePeripheralClock() \n\n\n
 */
__STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetCpuClockFrequency(void)
{
 8023ad8:	b480      	push	{r7}
 8023ada:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 8023adc:	4b03      	ldr	r3, [pc, #12]	; (8023aec <XMC_SCU_CLOCK_GetCpuClockFrequency+0x14>)
 8023ade:	681b      	ldr	r3, [r3, #0]
}
 8023ae0:	4618      	mov	r0, r3
 8023ae2:	46bd      	mov	sp, r7
 8023ae4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023ae8:	4770      	bx	lr
 8023aea:	bf00      	nop
 8023aec:	2003ffc0 	.word	0x2003ffc0

08023af0 <XMC_SCU_lDelay>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 ********************************************************************************************************************/
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
 8023af0:	b580      	push	{r7, lr}
 8023af2:	b084      	sub	sp, #16
 8023af4:	af00      	add	r7, sp, #0
 8023af6:	6078      	str	r0, [r7, #4]
  uint32_t i;

  SystemCoreClockUpdate();
 8023af8:	f7fc fde2 	bl	80206c0 <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 8023afc:	4b0c      	ldr	r3, [pc, #48]	; (8023b30 <XMC_SCU_lDelay+0x40>)
 8023afe:	681b      	ldr	r3, [r3, #0]
 8023b00:	4a0c      	ldr	r2, [pc, #48]	; (8023b34 <XMC_SCU_lDelay+0x44>)
 8023b02:	fba2 2303 	umull	r2, r3, r2, r3
 8023b06:	0c9a      	lsrs	r2, r3, #18
 8023b08:	687b      	ldr	r3, [r7, #4]
 8023b0a:	fb02 f303 	mul.w	r3, r2, r3
 8023b0e:	607b      	str	r3, [r7, #4]

  for (i = 0U; i < delay; ++i)
 8023b10:	2300      	movs	r3, #0
 8023b12:	60fb      	str	r3, [r7, #12]
 8023b14:	e003      	b.n	8023b1e <XMC_SCU_lDelay+0x2e>
  {
    __NOP();
 8023b16:	bf00      	nop
  for (i = 0U; i < delay; ++i)
 8023b18:	68fb      	ldr	r3, [r7, #12]
 8023b1a:	3301      	adds	r3, #1
 8023b1c:	60fb      	str	r3, [r7, #12]
 8023b1e:	68fa      	ldr	r2, [r7, #12]
 8023b20:	687b      	ldr	r3, [r7, #4]
 8023b22:	429a      	cmp	r2, r3
 8023b24:	d3f7      	bcc.n	8023b16 <XMC_SCU_lDelay+0x26>
  }
}
 8023b26:	bf00      	nop
 8023b28:	bf00      	nop
 8023b2a:	3710      	adds	r7, #16
 8023b2c:	46bd      	mov	sp, r7
 8023b2e:	bd80      	pop	{r7, pc}
 8023b30:	2003ffc0 	.word	0x2003ffc0
 8023b34:	431bde83 	.word	0x431bde83

08023b38 <XMC_SCU_INTERUPT_GetEventStatus>:
  SCU_INTERRUPT->SRSET |= (uint32_t)event;
}

/* API to retrieve the SCU event status */
XMC_SCU_INTERRUPT_EVENT_t XMC_SCU_INTERUPT_GetEventStatus(void)
{
 8023b38:	b480      	push	{r7}
 8023b3a:	af00      	add	r7, sp, #0
  return (SCU_INTERRUPT->SRRAW);
 8023b3c:	4b03      	ldr	r3, [pc, #12]	; (8023b4c <XMC_SCU_INTERUPT_GetEventStatus+0x14>)
 8023b3e:	685b      	ldr	r3, [r3, #4]
}
 8023b40:	4618      	mov	r0, r3
 8023b42:	46bd      	mov	sp, r7
 8023b44:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023b48:	4770      	bx	lr
 8023b4a:	bf00      	nop
 8023b4c:	50004074 	.word	0x50004074

08023b50 <XMC_SCU_INTERRUPT_ClearEventStatus>:

/* API to clear the SCU event status */
void XMC_SCU_INTERRUPT_ClearEventStatus(const XMC_SCU_INTERRUPT_EVENT_t event)
{
 8023b50:	b480      	push	{r7}
 8023b52:	b083      	sub	sp, #12
 8023b54:	af00      	add	r7, sp, #0
 8023b56:	6078      	str	r0, [r7, #4]
  SCU_INTERRUPT->SRCLR = (uint32_t)event;
 8023b58:	4a04      	ldr	r2, [pc, #16]	; (8023b6c <XMC_SCU_INTERRUPT_ClearEventStatus+0x1c>)
 8023b5a:	687b      	ldr	r3, [r7, #4]
 8023b5c:	60d3      	str	r3, [r2, #12]
}
 8023b5e:	bf00      	nop
 8023b60:	370c      	adds	r7, #12
 8023b62:	46bd      	mov	sp, r7
 8023b64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023b68:	4770      	bx	lr
 8023b6a:	bf00      	nop
 8023b6c:	50004074 	.word	0x50004074

08023b70 <XMC_SCU_SetBootMode>:
  return (uint32_t)(SCU_GENERAL->STCON & SCU_GENERAL_STCON_SWCON_Msk);
}

/* API to program a new device bootmode */
void XMC_SCU_SetBootMode(const XMC_SCU_BOOTMODE_t bootmode)
{
 8023b70:	b480      	push	{r7}
 8023b72:	b083      	sub	sp, #12
 8023b74:	af00      	add	r7, sp, #0
 8023b76:	4603      	mov	r3, r0
 8023b78:	80fb      	strh	r3, [r7, #6]
  SCU_GENERAL->STCON = (uint32_t)bootmode;
 8023b7a:	4a04      	ldr	r2, [pc, #16]	; (8023b8c <XMC_SCU_SetBootMode+0x1c>)
 8023b7c:	88fb      	ldrh	r3, [r7, #6]
 8023b7e:	6113      	str	r3, [r2, #16]
}
 8023b80:	bf00      	nop
 8023b82:	370c      	adds	r7, #12
 8023b84:	46bd      	mov	sp, r7
 8023b86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023b8a:	4770      	bx	lr
 8023b8c:	50004000 	.word	0x50004000

08023b90 <XMC_SCU_CLOCK_Init>:
  return (SCU_GENERAL->RMDATA);
}

/* API to initialize the clock tree */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
 8023b90:	b590      	push	{r4, r7, lr}
 8023b92:	b085      	sub	sp, #20
 8023b94:	af02      	add	r7, sp, #8
 8023b96:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("", ((config->fstdby_clksrc == XMC_SCU_HIB_STDBYCLKSRC_OSCULP) && (config->enable_osculp == true)) ||
             (config->fstdby_clksrc != XMC_SCU_HIB_STDBYCLKSRC_OSCULP));
  XMC_ASSERT("", ((config->syspll_config.clksrc == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) &&
                  (config->enable_oschp == true)) || (config->syspll_config.clksrc != XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP));

  XMC_SCU_CLOCK_SetSystemClockSource(XMC_SCU_CLOCK_SYSCLKSRC_OFI);
 8023b98:	2000      	movs	r0, #0
 8023b9a:	f000 f897 	bl	8023ccc <XMC_SCU_CLOCK_SetSystemClockSource>

  XMC_SCU_HIB_EnableHibernateDomain();
 8023b9e:	f000 fa6d 	bl	802407c <XMC_SCU_HIB_EnableHibernateDomain>

  if (config->enable_osculp == true)
 8023ba2:	687b      	ldr	r3, [r7, #4]
 8023ba4:	79db      	ldrb	r3, [r3, #7]
 8023ba6:	2b00      	cmp	r3, #0
 8023ba8:	d00a      	beq.n	8023bc0 <XMC_SCU_CLOCK_Init+0x30>
  {
    XMC_SCU_CLOCK_EnableLowPowerOscillator();
 8023baa:	f000 faa5 	bl	80240f8 <XMC_SCU_CLOCK_EnableLowPowerOscillator>
    while (XMC_SCU_CLOCK_IsLowPowerOscillatorStable() == false);
 8023bae:	bf00      	nop
 8023bb0:	f000 fa90 	bl	80240d4 <XMC_SCU_CLOCK_IsLowPowerOscillatorStable>
 8023bb4:	4603      	mov	r3, r0
 8023bb6:	f083 0301 	eor.w	r3, r3, #1
 8023bba:	b2db      	uxtb	r3, r3
 8023bbc:	2b00      	cmp	r3, #0
 8023bbe:	d1f7      	bne.n	8023bb0 <XMC_SCU_CLOCK_Init+0x20>
//  while (XMC_SCU_GetMirrorStatus() != 0)
//  {
//    /* Wait until update of the stanby clock source is done in the HIB domain */
//  }

  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);
 8023bc0:	687b      	ldr	r3, [r7, #4]
 8023bc2:	7a1b      	ldrb	r3, [r3, #8]
 8023bc4:	4618      	mov	r0, r3
 8023bc6:	f000 fa33 	bl	8024030 <XMC_SCU_CLOCK_SetBackupClockCalibrationMode>

  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
 8023bca:	687b      	ldr	r3, [r7, #4]
 8023bcc:	7c1b      	ldrb	r3, [r3, #16]
 8023bce:	4618      	mov	r0, r3
 8023bd0:	f000 f8fa 	bl	8023dc8 <XMC_SCU_CLOCK_SetSystemClockDivider>
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
 8023bd4:	687b      	ldr	r3, [r7, #4]
 8023bd6:	7c5b      	ldrb	r3, [r3, #17]
 8023bd8:	4618      	mov	r0, r3
 8023bda:	f000 f921 	bl	8023e20 <XMC_SCU_CLOCK_SetCpuClockDivider>
  XMC_SCU_CLOCK_SetCcuClockDivider((uint32_t)config->fccu_clkdiv);
 8023bde:	687b      	ldr	r3, [r7, #4]
 8023be0:	7c9b      	ldrb	r3, [r3, #18]
 8023be2:	4618      	mov	r0, r3
 8023be4:	f000 f906 	bl	8023df4 <XMC_SCU_CLOCK_SetCcuClockDivider>
  XMC_SCU_CLOCK_SetPeripheralClockDivider((uint32_t)config->fperipheral_clkdiv);
 8023be8:	687b      	ldr	r3, [r7, #4]
 8023bea:	7cdb      	ldrb	r3, [r3, #19]
 8023bec:	4618      	mov	r0, r3
 8023bee:	f000 f92d 	bl	8023e4c <XMC_SCU_CLOCK_SetPeripheralClockDivider>

  if (config->enable_oschp == true)
 8023bf2:	687b      	ldr	r3, [r7, #4]
 8023bf4:	799b      	ldrb	r3, [r3, #6]
 8023bf6:	2b00      	cmp	r3, #0
 8023bf8:	d00a      	beq.n	8023c10 <XMC_SCU_CLOCK_Init+0x80>
  {
    XMC_SCU_CLOCK_EnableHighPerformanceOscillator();
 8023bfa:	f000 fab7 	bl	802416c <XMC_SCU_CLOCK_EnableHighPerformanceOscillator>
    while (XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable() == false);
 8023bfe:	bf00      	nop
 8023c00:	f000 fadc 	bl	80241bc <XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable>
 8023c04:	4603      	mov	r3, r0
 8023c06:	f083 0301 	eor.w	r3, r3, #1
 8023c0a:	b2db      	uxtb	r3, r3
 8023c0c:	2b00      	cmp	r3, #0
 8023c0e:	d1f7      	bne.n	8023c00 <XMC_SCU_CLOCK_Init+0x70>
  }

  if (config->syspll_config.mode == XMC_SCU_CLOCK_SYSPLL_MODE_DISABLED)
 8023c10:	687b      	ldr	r3, [r7, #4]
 8023c12:	78db      	ldrb	r3, [r3, #3]
 8023c14:	2b00      	cmp	r3, #0
 8023c16:	d109      	bne.n	8023c2c <XMC_SCU_CLOCK_Init+0x9c>
  {
    /* Do not enable PLL Power Down Mode when the OSC Watchdog is enabled */
    if (config->enable_oschp == false)
 8023c18:	687b      	ldr	r3, [r7, #4]
 8023c1a:	799b      	ldrb	r3, [r3, #6]
 8023c1c:	f083 0301 	eor.w	r3, r3, #1
 8023c20:	b2db      	uxtb	r3, r3
 8023c22:	2b00      	cmp	r3, #0
 8023c24:	d014      	beq.n	8023c50 <XMC_SCU_CLOCK_Init+0xc0>
    {
      XMC_SCU_CLOCK_DisableSystemPll();
 8023c26:	f000 faef 	bl	8024208 <XMC_SCU_CLOCK_DisableSystemPll>
 8023c2a:	e011      	b.n	8023c50 <XMC_SCU_CLOCK_Init+0xc0>
    }
  }
  else
  {

    XMC_SCU_CLOCK_EnableSystemPll();
 8023c2c:	f000 fada 	bl	80241e4 <XMC_SCU_CLOCK_EnableSystemPll>
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 8023c30:	687b      	ldr	r3, [r7, #4]
 8023c32:	8898      	ldrh	r0, [r3, #4]
 8023c34:	687b      	ldr	r3, [r7, #4]
 8023c36:	78d9      	ldrb	r1, [r3, #3]
                                 config->syspll_config.mode,
                                 (uint32_t)config->syspll_config.p_div,
 8023c38:	687b      	ldr	r3, [r7, #4]
 8023c3a:	785b      	ldrb	r3, [r3, #1]
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 8023c3c:	461a      	mov	r2, r3
                                 (uint32_t)config->syspll_config.n_div,
 8023c3e:	687b      	ldr	r3, [r7, #4]
 8023c40:	781b      	ldrb	r3, [r3, #0]
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 8023c42:	461c      	mov	r4, r3
                                 (uint32_t)config->syspll_config.k_div);
 8023c44:	687b      	ldr	r3, [r7, #4]
 8023c46:	789b      	ldrb	r3, [r3, #2]
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 8023c48:	9300      	str	r3, [sp, #0]
 8023c4a:	4623      	mov	r3, r4
 8023c4c:	f000 faee 	bl	802422c <XMC_SCU_CLOCK_StartSystemPll>
  }

  /* use SYSPLL? */
  if (config->fsys_clksrc == XMC_SCU_CLOCK_SYSCLKSRC_PLL)
 8023c50:	687b      	ldr	r3, [r7, #4]
 8023c52:	68db      	ldr	r3, [r3, #12]
 8023c54:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8023c58:	d103      	bne.n	8023c62 <XMC_SCU_CLOCK_Init+0xd2>
  {
    XMC_SCU_CLOCK_SetSystemClockSource(XMC_SCU_CLOCK_SYSCLKSRC_PLL);
 8023c5a:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8023c5e:	f000 f835 	bl	8023ccc <XMC_SCU_CLOCK_SetSystemClockSource>
  }
  SystemCoreClockUpdate();
 8023c62:	f7fc fd2d 	bl	80206c0 <SystemCoreClockUpdate>
}
 8023c66:	bf00      	nop
 8023c68:	370c      	adds	r7, #12
 8023c6a:	46bd      	mov	sp, r7
 8023c6c:	bd90      	pop	{r4, r7, pc}
	...

08023c70 <XMC_SCU_RESET_DeassertPeripheralReset>:
  *(volatile uint32_t *)(&(SCU_RESET->PRSET0) + (index * 3U)) = (uint32_t)mask;
}

/* API to manually de-assert a reset request */
void XMC_SCU_RESET_DeassertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
 8023c70:	b480      	push	{r7}
 8023c72:	b085      	sub	sp, #20
 8023c74:	af00      	add	r7, sp, #0
 8023c76:	6078      	str	r0, [r7, #4]
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 8023c78:	687b      	ldr	r3, [r7, #4]
 8023c7a:	0f1b      	lsrs	r3, r3, #28
 8023c7c:	60fb      	str	r3, [r7, #12]
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 8023c7e:	687b      	ldr	r3, [r7, #4]
 8023c80:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8023c84:	60bb      	str	r3, [r7, #8]

  *(volatile uint32_t *)(&(SCU_RESET->PRCLR0) + (index * 3U)) = (uint32_t)mask;
 8023c86:	68fa      	ldr	r2, [r7, #12]
 8023c88:	4613      	mov	r3, r2
 8023c8a:	005b      	lsls	r3, r3, #1
 8023c8c:	4413      	add	r3, r2
 8023c8e:	009b      	lsls	r3, r3, #2
 8023c90:	461a      	mov	r2, r3
 8023c92:	4b05      	ldr	r3, [pc, #20]	; (8023ca8 <XMC_SCU_RESET_DeassertPeripheralReset+0x38>)
 8023c94:	4413      	add	r3, r2
 8023c96:	68ba      	ldr	r2, [r7, #8]
 8023c98:	601a      	str	r2, [r3, #0]
}
 8023c9a:	bf00      	nop
 8023c9c:	3714      	adds	r7, #20
 8023c9e:	46bd      	mov	sp, r7
 8023ca0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023ca4:	4770      	bx	lr
 8023ca6:	bf00      	nop
 8023ca8:	50004414 	.word	0x50004414

08023cac <XMC_SCU_CLOCK_GetPeripheralClockFrequency>:

/*
 * API to retrieve clock frequency of peripherals on the peripheral bus using a shared functional clock
 */
uint32_t XMC_SCU_CLOCK_GetPeripheralClockFrequency(void)
{
 8023cac:	b580      	push	{r7, lr}
 8023cae:	af00      	add	r7, sp, #0
  return (uint32_t)(XMC_SCU_CLOCK_GetCpuClockFrequency() >>
 8023cb0:	f7ff ff12 	bl	8023ad8 <XMC_SCU_CLOCK_GetCpuClockFrequency>
 8023cb4:	4602      	mov	r2, r0
                    ((SCU_CLK->PBCLKCR & SCU_CLK_PBCLKCR_PBDIV_Msk) >> SCU_CLK_PBCLKCR_PBDIV_Pos));
 8023cb6:	4b04      	ldr	r3, [pc, #16]	; (8023cc8 <XMC_SCU_CLOCK_GetPeripheralClockFrequency+0x1c>)
 8023cb8:	695b      	ldr	r3, [r3, #20]
 8023cba:	f003 0301 	and.w	r3, r3, #1
  return (uint32_t)(XMC_SCU_CLOCK_GetCpuClockFrequency() >>
 8023cbe:	fa22 f303 	lsr.w	r3, r2, r3
}
 8023cc2:	4618      	mov	r0, r3
 8023cc4:	bd80      	pop	{r7, pc}
 8023cc6:	bf00      	nop
 8023cc8:	50004600 	.word	0x50004600

08023ccc <XMC_SCU_CLOCK_SetSystemClockSource>:

/* API to select fSYS */
void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source)
{
 8023ccc:	b480      	push	{r7}
 8023cce:	b083      	sub	sp, #12
 8023cd0:	af00      	add	r7, sp, #0
 8023cd2:	6078      	str	r0, [r7, #4]
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSSEL_Msk)) |
 8023cd4:	4b06      	ldr	r3, [pc, #24]	; (8023cf0 <XMC_SCU_CLOCK_SetSystemClockSource+0x24>)
 8023cd6:	68db      	ldr	r3, [r3, #12]
 8023cd8:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 8023cdc:	4904      	ldr	r1, [pc, #16]	; (8023cf0 <XMC_SCU_CLOCK_SetSystemClockSource+0x24>)
 8023cde:	687b      	ldr	r3, [r7, #4]
 8023ce0:	4313      	orrs	r3, r2
 8023ce2:	60cb      	str	r3, [r1, #12]
                      ((uint32_t)source);
}
 8023ce4:	bf00      	nop
 8023ce6:	370c      	adds	r7, #12
 8023ce8:	46bd      	mov	sp, r7
 8023cea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023cee:	4770      	bx	lr
 8023cf0:	50004600 	.word	0x50004600

08023cf4 <XMC_SCU_CLOCK_SetUsbClockSource>:

/* API to select fUSB */
void XMC_SCU_CLOCK_SetUsbClockSource(const XMC_SCU_CLOCK_USBCLKSRC_t source)
{
 8023cf4:	b480      	push	{r7}
 8023cf6:	b083      	sub	sp, #12
 8023cf8:	af00      	add	r7, sp, #0
 8023cfa:	6078      	str	r0, [r7, #4]
  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBSEL_Msk)) |
 8023cfc:	4b06      	ldr	r3, [pc, #24]	; (8023d18 <XMC_SCU_CLOCK_SetUsbClockSource+0x24>)
 8023cfe:	699b      	ldr	r3, [r3, #24]
 8023d00:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 8023d04:	4904      	ldr	r1, [pc, #16]	; (8023d18 <XMC_SCU_CLOCK_SetUsbClockSource+0x24>)
 8023d06:	687b      	ldr	r3, [r7, #4]
 8023d08:	4313      	orrs	r3, r2
 8023d0a:	618b      	str	r3, [r1, #24]
                      ((uint32_t)source);
}
 8023d0c:	bf00      	nop
 8023d0e:	370c      	adds	r7, #12
 8023d10:	46bd      	mov	sp, r7
 8023d12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023d16:	4770      	bx	lr
 8023d18:	50004600 	.word	0x50004600

08023d1c <XMC_SCU_CLOCK_SetWdtClockSource>:

/* API to select fWDT */
void XMC_SCU_CLOCK_SetWdtClockSource(const XMC_SCU_CLOCK_WDTCLKSRC_t source)
{
 8023d1c:	b480      	push	{r7}
 8023d1e:	b083      	sub	sp, #12
 8023d20:	af00      	add	r7, sp, #0
 8023d22:	6078      	str	r0, [r7, #4]
  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTSEL_Msk)) |
 8023d24:	4b06      	ldr	r3, [pc, #24]	; (8023d40 <XMC_SCU_CLOCK_SetWdtClockSource+0x24>)
 8023d26:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8023d28:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 8023d2c:	4904      	ldr	r1, [pc, #16]	; (8023d40 <XMC_SCU_CLOCK_SetWdtClockSource+0x24>)
 8023d2e:	687b      	ldr	r3, [r7, #4]
 8023d30:	4313      	orrs	r3, r2
 8023d32:	624b      	str	r3, [r1, #36]	; 0x24
                      ((uint32_t)source);
}
 8023d34:	bf00      	nop
 8023d36:	370c      	adds	r7, #12
 8023d38:	46bd      	mov	sp, r7
 8023d3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023d3e:	4770      	bx	lr
 8023d40:	50004600 	.word	0x50004600

08023d44 <XMC_SCU_CLOCK_SetSystemPllClockSource>:
                      ((uint32_t)source);
}

/* API to select fPLL */
void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source)
{
 8023d44:	b480      	push	{r7}
 8023d46:	b083      	sub	sp, #12
 8023d48:	af00      	add	r7, sp, #0
 8023d4a:	4603      	mov	r3, r0
 8023d4c:	80fb      	strh	r3, [r7, #6]
  /* Check input clock */
  if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) /* Select PLLClockSource */
 8023d4e:	88fb      	ldrh	r3, [r7, #6]
 8023d50:	2b00      	cmp	r3, #0
 8023d52:	d108      	bne.n	8023d66 <XMC_SCU_CLOCK_SetSystemPllClockSource+0x22>
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 8023d54:	4b0b      	ldr	r3, [pc, #44]	; (8023d84 <XMC_SCU_CLOCK_SetSystemPllClockSource+0x40>)
 8023d56:	68db      	ldr	r3, [r3, #12]
 8023d58:	4a0a      	ldr	r2, [pc, #40]	; (8023d84 <XMC_SCU_CLOCK_SetSystemPllClockSource+0x40>)
 8023d5a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8023d5e:	f023 0301 	bic.w	r3, r3, #1
 8023d62:	60d3      	str	r3, [r2, #12]
  }
  else
  {
    SCU_PLL->PLLCON2 |= (uint32_t)(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
  }
}
 8023d64:	e007      	b.n	8023d76 <XMC_SCU_CLOCK_SetSystemPllClockSource+0x32>
    SCU_PLL->PLLCON2 |= (uint32_t)(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 8023d66:	4b07      	ldr	r3, [pc, #28]	; (8023d84 <XMC_SCU_CLOCK_SetSystemPllClockSource+0x40>)
 8023d68:	68db      	ldr	r3, [r3, #12]
 8023d6a:	4a06      	ldr	r2, [pc, #24]	; (8023d84 <XMC_SCU_CLOCK_SetSystemPllClockSource+0x40>)
 8023d6c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8023d70:	f043 0301 	orr.w	r3, r3, #1
 8023d74:	60d3      	str	r3, [r2, #12]
}
 8023d76:	bf00      	nop
 8023d78:	370c      	adds	r7, #12
 8023d7a:	46bd      	mov	sp, r7
 8023d7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023d80:	4770      	bx	lr
 8023d82:	bf00      	nop
 8023d84:	50004710 	.word	0x50004710

08023d88 <XMC_SCU_HIB_SetRtcClockSource>:

/* API to select fRTC */
void XMC_SCU_HIB_SetRtcClockSource(const XMC_SCU_HIB_RTCCLKSRC_t source)
{
 8023d88:	b480      	push	{r7}
 8023d8a:	b083      	sub	sp, #12
 8023d8c:	af00      	add	r7, sp, #0
 8023d8e:	4603      	mov	r3, r0
 8023d90:	71fb      	strb	r3, [r7, #7]
  /* Wait until the update of HDCR register in hibernate domain is completed */
  while ((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 8023d92:	bf00      	nop
 8023d94:	4b0a      	ldr	r3, [pc, #40]	; (8023dc0 <XMC_SCU_HIB_SetRtcClockSource+0x38>)
 8023d96:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 8023d9a:	f003 0308 	and.w	r3, r3, #8
 8023d9e:	2b00      	cmp	r3, #0
 8023da0:	d1f8      	bne.n	8023d94 <XMC_SCU_HIB_SetRtcClockSource+0xc>
  {
  }

  SCU_HIBERNATE->HDCR = (SCU_HIBERNATE->HDCR & ((uint32_t)~SCU_HIBERNATE_HDCR_RCS_Msk)) |
 8023da2:	4b08      	ldr	r3, [pc, #32]	; (8023dc4 <XMC_SCU_HIB_SetRtcClockSource+0x3c>)
 8023da4:	68db      	ldr	r3, [r3, #12]
 8023da6:	f023 0240 	bic.w	r2, r3, #64	; 0x40
                        ((uint32_t)source);
 8023daa:	79fb      	ldrb	r3, [r7, #7]
  SCU_HIBERNATE->HDCR = (SCU_HIBERNATE->HDCR & ((uint32_t)~SCU_HIBERNATE_HDCR_RCS_Msk)) |
 8023dac:	4905      	ldr	r1, [pc, #20]	; (8023dc4 <XMC_SCU_HIB_SetRtcClockSource+0x3c>)
 8023dae:	4313      	orrs	r3, r2
 8023db0:	60cb      	str	r3, [r1, #12]
}
 8023db2:	bf00      	nop
 8023db4:	370c      	adds	r7, #12
 8023db6:	46bd      	mov	sp, r7
 8023db8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023dbc:	4770      	bx	lr
 8023dbe:	bf00      	nop
 8023dc0:	50004000 	.word	0x50004000
 8023dc4:	50004300 	.word	0x50004300

08023dc8 <XMC_SCU_CLOCK_SetSystemClockDivider>:
                        ((uint32_t)source);
}

/* API to program the divider placed between fsys and its parent */
void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider)
{
 8023dc8:	b480      	push	{r7}
 8023dca:	b083      	sub	sp, #12
 8023dcc:	af00      	add	r7, sp, #0
 8023dce:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetSystemClockDivider:Wrong clock divider value",
             (divider <= (SCU_CLK_SYSCLKCR_SYSDIV_Msk + 1UL)) );

  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 8023dd0:	4b07      	ldr	r3, [pc, #28]	; (8023df0 <XMC_SCU_CLOCK_SetSystemClockDivider+0x28>)
 8023dd2:	68db      	ldr	r3, [r3, #12]
 8023dd4:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
                      ((uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_SYSCLKCR_SYSDIV_Pos));
 8023dd8:	687b      	ldr	r3, [r7, #4]
 8023dda:	3b01      	subs	r3, #1
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 8023ddc:	4904      	ldr	r1, [pc, #16]	; (8023df0 <XMC_SCU_CLOCK_SetSystemClockDivider+0x28>)
 8023dde:	4313      	orrs	r3, r2
 8023de0:	60cb      	str	r3, [r1, #12]
}
 8023de2:	bf00      	nop
 8023de4:	370c      	adds	r7, #12
 8023de6:	46bd      	mov	sp, r7
 8023de8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023dec:	4770      	bx	lr
 8023dee:	bf00      	nop
 8023df0:	50004600 	.word	0x50004600

08023df4 <XMC_SCU_CLOCK_SetCcuClockDivider>:

/* API to program the divider placed between fccu and its parent */
void XMC_SCU_CLOCK_SetCcuClockDivider(const uint32_t divider)
{
 8023df4:	b480      	push	{r7}
 8023df6:	b083      	sub	sp, #12
 8023df8:	af00      	add	r7, sp, #0
 8023dfa:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetCapcomClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CCUCLKCR = (SCU_CLK->CCUCLKCR & ((uint32_t)~SCU_CLK_CCUCLKCR_CCUDIV_Msk)) |
 8023dfc:	4b07      	ldr	r3, [pc, #28]	; (8023e1c <XMC_SCU_CLOCK_SetCcuClockDivider+0x28>)
 8023dfe:	6a1b      	ldr	r3, [r3, #32]
 8023e00:	f023 0201 	bic.w	r2, r3, #1
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_CCUCLKCR_CCUDIV_Pos);
 8023e04:	687b      	ldr	r3, [r7, #4]
 8023e06:	3b01      	subs	r3, #1
  SCU_CLK->CCUCLKCR = (SCU_CLK->CCUCLKCR & ((uint32_t)~SCU_CLK_CCUCLKCR_CCUDIV_Msk)) |
 8023e08:	4904      	ldr	r1, [pc, #16]	; (8023e1c <XMC_SCU_CLOCK_SetCcuClockDivider+0x28>)
 8023e0a:	4313      	orrs	r3, r2
 8023e0c:	620b      	str	r3, [r1, #32]
}
 8023e0e:	bf00      	nop
 8023e10:	370c      	adds	r7, #12
 8023e12:	46bd      	mov	sp, r7
 8023e14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023e18:	4770      	bx	lr
 8023e1a:	bf00      	nop
 8023e1c:	50004600 	.word	0x50004600

08023e20 <XMC_SCU_CLOCK_SetCpuClockDivider>:

/* API to program the divider placed between fcpu and its parent */
void XMC_SCU_CLOCK_SetCpuClockDivider(const uint32_t divider)
{
 8023e20:	b480      	push	{r7}
 8023e22:	b083      	sub	sp, #12
 8023e24:	af00      	add	r7, sp, #0
 8023e26:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetCpuClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CPUCLKCR = (SCU_CLK->CPUCLKCR & ((uint32_t)~SCU_CLK_CPUCLKCR_CPUDIV_Msk)) |
 8023e28:	4b07      	ldr	r3, [pc, #28]	; (8023e48 <XMC_SCU_CLOCK_SetCpuClockDivider+0x28>)
 8023e2a:	691b      	ldr	r3, [r3, #16]
 8023e2c:	f023 0201 	bic.w	r2, r3, #1
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_CPUCLKCR_CPUDIV_Pos);
 8023e30:	687b      	ldr	r3, [r7, #4]
 8023e32:	3b01      	subs	r3, #1
  SCU_CLK->CPUCLKCR = (SCU_CLK->CPUCLKCR & ((uint32_t)~SCU_CLK_CPUCLKCR_CPUDIV_Msk)) |
 8023e34:	4904      	ldr	r1, [pc, #16]	; (8023e48 <XMC_SCU_CLOCK_SetCpuClockDivider+0x28>)
 8023e36:	4313      	orrs	r3, r2
 8023e38:	610b      	str	r3, [r1, #16]
}
 8023e3a:	bf00      	nop
 8023e3c:	370c      	adds	r7, #12
 8023e3e:	46bd      	mov	sp, r7
 8023e40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023e44:	4770      	bx	lr
 8023e46:	bf00      	nop
 8023e48:	50004600 	.word	0x50004600

08023e4c <XMC_SCU_CLOCK_SetPeripheralClockDivider>:

/* API to program the divider placed between fperiph and its parent */
void XMC_SCU_CLOCK_SetPeripheralClockDivider(const uint32_t divider)
{
 8023e4c:	b480      	push	{r7}
 8023e4e:	b083      	sub	sp, #12
 8023e50:	af00      	add	r7, sp, #0
 8023e52:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetPeripheralClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->PBCLKCR = (SCU_CLK->PBCLKCR & ((uint32_t)~SCU_CLK_PBCLKCR_PBDIV_Msk)) |
 8023e54:	4b07      	ldr	r3, [pc, #28]	; (8023e74 <XMC_SCU_CLOCK_SetPeripheralClockDivider+0x28>)
 8023e56:	695b      	ldr	r3, [r3, #20]
 8023e58:	f023 0201 	bic.w	r2, r3, #1
                     ((uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_PBCLKCR_PBDIV_Pos));
 8023e5c:	687b      	ldr	r3, [r7, #4]
 8023e5e:	3b01      	subs	r3, #1
  SCU_CLK->PBCLKCR = (SCU_CLK->PBCLKCR & ((uint32_t)~SCU_CLK_PBCLKCR_PBDIV_Msk)) |
 8023e60:	4904      	ldr	r1, [pc, #16]	; (8023e74 <XMC_SCU_CLOCK_SetPeripheralClockDivider+0x28>)
 8023e62:	4313      	orrs	r3, r2
 8023e64:	614b      	str	r3, [r1, #20]
}
 8023e66:	bf00      	nop
 8023e68:	370c      	adds	r7, #12
 8023e6a:	46bd      	mov	sp, r7
 8023e6c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023e70:	4770      	bx	lr
 8023e72:	bf00      	nop
 8023e74:	50004600 	.word	0x50004600

08023e78 <XMC_SCU_CLOCK_SetUsbClockDivider>:

/* API to program the divider placed between fsdmmc and its parent */
void XMC_SCU_CLOCK_SetUsbClockDivider(const uint32_t divider)
{
 8023e78:	b480      	push	{r7}
 8023e7a:	b083      	sub	sp, #12
 8023e7c:	af00      	add	r7, sp, #0
 8023e7e:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetSdmmcClockDivider:Wrong clock divider value",
             (divider <= (SCU_CLK_USBCLKCR_USBDIV_Msk + 1UL)) );

  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBDIV_Msk)) |
 8023e80:	4b07      	ldr	r3, [pc, #28]	; (8023ea0 <XMC_SCU_CLOCK_SetUsbClockDivider+0x28>)
 8023e82:	699b      	ldr	r3, [r3, #24]
 8023e84:	f023 0207 	bic.w	r2, r3, #7
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_USBCLKCR_USBDIV_Pos);
 8023e88:	687b      	ldr	r3, [r7, #4]
 8023e8a:	3b01      	subs	r3, #1
  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBDIV_Msk)) |
 8023e8c:	4904      	ldr	r1, [pc, #16]	; (8023ea0 <XMC_SCU_CLOCK_SetUsbClockDivider+0x28>)
 8023e8e:	4313      	orrs	r3, r2
 8023e90:	618b      	str	r3, [r1, #24]
}
 8023e92:	bf00      	nop
 8023e94:	370c      	adds	r7, #12
 8023e96:	46bd      	mov	sp, r7
 8023e98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023e9c:	4770      	bx	lr
 8023e9e:	bf00      	nop
 8023ea0:	50004600 	.word	0x50004600

08023ea4 <XMC_SCU_CLOCK_SetEbuClockDivider>:

#if defined(EBU)
/* API to program the divider placed between febu and its parent */
void XMC_SCU_CLOCK_SetEbuClockDivider(const uint32_t divider)
{
 8023ea4:	b480      	push	{r7}
 8023ea6:	b083      	sub	sp, #12
 8023ea8:	af00      	add	r7, sp, #0
 8023eaa:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetEbuClockDivider:Wrong clock divider value",
             (divider <= (SCU_CLK_EBUCLKCR_EBUDIV_Msk + 1UL) ) );

  SCU_CLK->EBUCLKCR = (SCU_CLK->EBUCLKCR & ((uint32_t)~SCU_CLK_EBUCLKCR_EBUDIV_Msk)) |
 8023eac:	4b07      	ldr	r3, [pc, #28]	; (8023ecc <XMC_SCU_CLOCK_SetEbuClockDivider+0x28>)
 8023eae:	69db      	ldr	r3, [r3, #28]
 8023eb0:	f023 023f 	bic.w	r2, r3, #63	; 0x3f
                      (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_EBUCLKCR_EBUDIV_Pos);
 8023eb4:	687b      	ldr	r3, [r7, #4]
 8023eb6:	3b01      	subs	r3, #1
  SCU_CLK->EBUCLKCR = (SCU_CLK->EBUCLKCR & ((uint32_t)~SCU_CLK_EBUCLKCR_EBUDIV_Msk)) |
 8023eb8:	4904      	ldr	r1, [pc, #16]	; (8023ecc <XMC_SCU_CLOCK_SetEbuClockDivider+0x28>)
 8023eba:	4313      	orrs	r3, r2
 8023ebc:	61cb      	str	r3, [r1, #28]
}
 8023ebe:	bf00      	nop
 8023ec0:	370c      	adds	r7, #12
 8023ec2:	46bd      	mov	sp, r7
 8023ec4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023ec8:	4770      	bx	lr
 8023eca:	bf00      	nop
 8023ecc:	50004600 	.word	0x50004600

08023ed0 <XMC_SCU_CLOCK_SetWdtClockDivider>:
#endif

/* API to program the divider placed between fwdt and its parent */
void XMC_SCU_CLOCK_SetWdtClockDivider(const uint32_t divider)
{
 8023ed0:	b480      	push	{r7}
 8023ed2:	b083      	sub	sp, #12
 8023ed4:	af00      	add	r7, sp, #0
 8023ed6:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetWdtClockDivider:Wrong clock divider value",
             (divider <= (SCU_CLK_WDTCLKCR_WDTDIV_Msk + 1UL) ) );

  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTDIV_Msk)) |
 8023ed8:	4b07      	ldr	r3, [pc, #28]	; (8023ef8 <XMC_SCU_CLOCK_SetWdtClockDivider+0x28>)
 8023eda:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8023edc:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
                      (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_WDTCLKCR_WDTDIV_Pos);
 8023ee0:	687b      	ldr	r3, [r7, #4]
 8023ee2:	3b01      	subs	r3, #1
  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTDIV_Msk)) |
 8023ee4:	4904      	ldr	r1, [pc, #16]	; (8023ef8 <XMC_SCU_CLOCK_SetWdtClockDivider+0x28>)
 8023ee6:	4313      	orrs	r3, r2
 8023ee8:	624b      	str	r3, [r1, #36]	; 0x24
}
 8023eea:	bf00      	nop
 8023eec:	370c      	adds	r7, #12
 8023eee:	46bd      	mov	sp, r7
 8023ef0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023ef4:	4770      	bx	lr
 8023ef6:	bf00      	nop
 8023ef8:	50004600 	.word	0x50004600

08023efc <XMC_SCU_CLOCK_EnableClock>:
}
#endif

/* API to enable a given module clock */
void XMC_SCU_CLOCK_EnableClock(const XMC_SCU_CLOCK_t clock)
{
 8023efc:	b480      	push	{r7}
 8023efe:	b083      	sub	sp, #12
 8023f00:	af00      	add	r7, sp, #0
 8023f02:	4603      	mov	r3, r0
 8023f04:	71fb      	strb	r3, [r7, #7]
  SCU_CLK->CLKSET = ((uint32_t)clock);
 8023f06:	4a04      	ldr	r2, [pc, #16]	; (8023f18 <XMC_SCU_CLOCK_EnableClock+0x1c>)
 8023f08:	79fb      	ldrb	r3, [r7, #7]
 8023f0a:	6053      	str	r3, [r2, #4]
}
 8023f0c:	bf00      	nop
 8023f0e:	370c      	adds	r7, #12
 8023f10:	46bd      	mov	sp, r7
 8023f12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023f16:	4770      	bx	lr
 8023f18:	50004600 	.word	0x50004600

08023f1c <XMC_SCU_CLOCK_UngatePeripheralClock>:
  *(volatile uint32_t *)((&(SCU_CLK->CGATSET0)) + (index * 3U)) = (uint32_t)mask;
}

/* API to ungate a given module clock */
void XMC_SCU_CLOCK_UngatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
 8023f1c:	b480      	push	{r7}
 8023f1e:	b085      	sub	sp, #20
 8023f20:	af00      	add	r7, sp, #0
 8023f22:	6078      	str	r0, [r7, #4]
  uint32_t index = (uint32_t)((peripheral & 0xf0000000UL) >> 28UL);
 8023f24:	687b      	ldr	r3, [r7, #4]
 8023f26:	0f1b      	lsrs	r3, r3, #28
 8023f28:	60fb      	str	r3, [r7, #12]
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);
 8023f2a:	687b      	ldr	r3, [r7, #4]
 8023f2c:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8023f30:	60bb      	str	r3, [r7, #8]

  *(volatile uint32_t *)(&(SCU_CLK->CGATCLR0) + (index * 3U)) = (uint32_t)mask;
 8023f32:	68fa      	ldr	r2, [r7, #12]
 8023f34:	4613      	mov	r3, r2
 8023f36:	005b      	lsls	r3, r3, #1
 8023f38:	4413      	add	r3, r2
 8023f3a:	009b      	lsls	r3, r3, #2
 8023f3c:	461a      	mov	r2, r3
 8023f3e:	4b05      	ldr	r3, [pc, #20]	; (8023f54 <XMC_SCU_CLOCK_UngatePeripheralClock+0x38>)
 8023f40:	4413      	add	r3, r2
 8023f42:	68ba      	ldr	r2, [r7, #8]
 8023f44:	601a      	str	r2, [r3, #0]
}
 8023f46:	bf00      	nop
 8023f48:	3714      	adds	r7, #20
 8023f4a:	46bd      	mov	sp, r7
 8023f4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023f50:	4770      	bx	lr
 8023f52:	bf00      	nop
 8023f54:	50004648 	.word	0x50004648

08023f58 <XMC_SCU_CLOCK_EnableUsbPll>:
  return ((SCU_POWER->EVRVADCSTAT & SCU_POWER_EVRVADCSTAT_VADC33V_Msk) >> SCU_POWER_EVRVADCSTAT_VADC33V_Pos) * XMC_SCU_POWER_LSB33V;
}

/* API to enable USB PLL for USB clock */
void XMC_SCU_CLOCK_EnableUsbPll(void)
{
 8023f58:	b480      	push	{r7}
 8023f5a:	af00      	add	r7, sp, #0
  SCU_PLL->USBPLLCON &= (uint32_t)~(SCU_PLL_USBPLLCON_VCOPWD_Msk | SCU_PLL_USBPLLCON_PLLPWD_Msk);
 8023f5c:	4b06      	ldr	r3, [pc, #24]	; (8023f78 <XMC_SCU_CLOCK_EnableUsbPll+0x20>)
 8023f5e:	695b      	ldr	r3, [r3, #20]
 8023f60:	4a05      	ldr	r2, [pc, #20]	; (8023f78 <XMC_SCU_CLOCK_EnableUsbPll+0x20>)
 8023f62:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8023f66:	f023 0302 	bic.w	r3, r3, #2
 8023f6a:	6153      	str	r3, [r2, #20]
}
 8023f6c:	bf00      	nop
 8023f6e:	46bd      	mov	sp, r7
 8023f70:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023f74:	4770      	bx	lr
 8023f76:	bf00      	nop
 8023f78:	50004710 	.word	0x50004710

08023f7c <XMC_SCU_CLOCK_StartUsbPll>:
  SCU_PLL->USBPLLCON |= (uint32_t)(SCU_PLL_USBPLLCON_VCOPWD_Msk | SCU_PLL_USBPLLCON_PLLPWD_Msk);
}

/* API to configure USB PLL */
void XMC_SCU_CLOCK_StartUsbPll(uint32_t pdiv, uint32_t ndiv)
{
 8023f7c:	b480      	push	{r7}
 8023f7e:	b083      	sub	sp, #12
 8023f80:	af00      	add	r7, sp, #0
 8023f82:	6078      	str	r0, [r7, #4]
 8023f84:	6039      	str	r1, [r7, #0]
  /* Go to bypass the USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_VCOBYP_Msk;
 8023f86:	4b28      	ldr	r3, [pc, #160]	; (8024028 <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8023f88:	695b      	ldr	r3, [r3, #20]
 8023f8a:	4a27      	ldr	r2, [pc, #156]	; (8024028 <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8023f8c:	f043 0301 	orr.w	r3, r3, #1
 8023f90:	6153      	str	r3, [r2, #20]
  while ((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOBYST_Msk) == 0U)
 8023f92:	bf00      	nop
 8023f94:	4b24      	ldr	r3, [pc, #144]	; (8024028 <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8023f96:	691b      	ldr	r3, [r3, #16]
 8023f98:	f003 0301 	and.w	r3, r3, #1
 8023f9c:	2b00      	cmp	r3, #0
 8023f9e:	d0f9      	beq.n	8023f94 <XMC_SCU_CLOCK_StartUsbPll+0x18>
  {
    /* wait for prescaler mode */
  }

  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;
 8023fa0:	4b21      	ldr	r3, [pc, #132]	; (8024028 <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8023fa2:	695b      	ldr	r3, [r3, #20]
 8023fa4:	4a20      	ldr	r2, [pc, #128]	; (8024028 <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8023fa6:	f043 0310 	orr.w	r3, r3, #16
 8023faa:	6153      	str	r3, [r2, #20]

  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv - 1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
 8023fac:	683b      	ldr	r3, [r7, #0]
 8023fae:	3b01      	subs	r3, #1
 8023fb0:	021a      	lsls	r2, r3, #8
                                  (uint32_t)((pdiv - 1U) << SCU_PLL_USBPLLCON_PDIV_Pos));
 8023fb2:	687b      	ldr	r3, [r7, #4]
 8023fb4:	3b01      	subs	r3, #1
 8023fb6:	061b      	lsls	r3, r3, #24
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv - 1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
 8023fb8:	491b      	ldr	r1, [pc, #108]	; (8024028 <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8023fba:	4313      	orrs	r3, r2
 8023fbc:	614b      	str	r3, [r1, #20]

  /* Set OSCDISCDIS */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_OSCDISCDIS_Msk;
 8023fbe:	4b1a      	ldr	r3, [pc, #104]	; (8024028 <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8023fc0:	695b      	ldr	r3, [r3, #20]
 8023fc2:	4a19      	ldr	r2, [pc, #100]	; (8024028 <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8023fc4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8023fc8:	6153      	str	r3, [r2, #20]

  /* connect Oscillator to USB PLL */
  SCU_PLL->USBPLLCON &= (uint32_t)~SCU_PLL_USBPLLCON_FINDIS_Msk;
 8023fca:	4b17      	ldr	r3, [pc, #92]	; (8024028 <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8023fcc:	695b      	ldr	r3, [r3, #20]
 8023fce:	4a16      	ldr	r2, [pc, #88]	; (8024028 <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8023fd0:	f023 0310 	bic.w	r3, r3, #16
 8023fd4:	6153      	str	r3, [r2, #20]

  /* restart PLL Lock detection */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_RESLD_Msk;
 8023fd6:	4b14      	ldr	r3, [pc, #80]	; (8024028 <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8023fd8:	695b      	ldr	r3, [r3, #20]
 8023fda:	4a13      	ldr	r2, [pc, #76]	; (8024028 <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8023fdc:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8023fe0:	6153      	str	r3, [r2, #20]

  while ((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOLOCK_Msk) == 0U)
 8023fe2:	bf00      	nop
 8023fe4:	4b10      	ldr	r3, [pc, #64]	; (8024028 <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8023fe6:	691b      	ldr	r3, [r3, #16]
 8023fe8:	f003 0304 	and.w	r3, r3, #4
 8023fec:	2b00      	cmp	r3, #0
 8023fee:	d0f9      	beq.n	8023fe4 <XMC_SCU_CLOCK_StartUsbPll+0x68>
  {
    /* wait for PLL Lock */
  }

  /* Disable bypass- put PLL clock back */
  SCU_PLL->USBPLLCON &= ~SCU_PLL_USBPLLCON_VCOBYP_Msk;
 8023ff0:	4b0d      	ldr	r3, [pc, #52]	; (8024028 <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8023ff2:	695b      	ldr	r3, [r3, #20]
 8023ff4:	4a0c      	ldr	r2, [pc, #48]	; (8024028 <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8023ff6:	f023 0301 	bic.w	r3, r3, #1
 8023ffa:	6153      	str	r3, [r2, #20]
  while ((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOBYST_Msk) != 0U)
 8023ffc:	bf00      	nop
 8023ffe:	4b0a      	ldr	r3, [pc, #40]	; (8024028 <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8024000:	691b      	ldr	r3, [r3, #16]
 8024002:	f003 0301 	and.w	r3, r3, #1
 8024006:	2b00      	cmp	r3, #0
 8024008:	d1f9      	bne.n	8023ffe <XMC_SCU_CLOCK_StartUsbPll+0x82>
  {
    /* wait for normal mode */
  }

  /* Reset OSCDISCDIS */
  SCU_PLL->USBPLLCON &= ~SCU_PLL_USBPLLCON_OSCDISCDIS_Msk;
 802400a:	4b07      	ldr	r3, [pc, #28]	; (8024028 <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 802400c:	695b      	ldr	r3, [r3, #20]
 802400e:	4a06      	ldr	r2, [pc, #24]	; (8024028 <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8024010:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8024014:	6153      	str	r3, [r2, #20]

  SCU_TRAP->TRAPCLR = SCU_TRAP_TRAPCLR_UVCOLCKT_Msk;
 8024016:	4b05      	ldr	r3, [pc, #20]	; (802402c <XMC_SCU_CLOCK_StartUsbPll+0xb0>)
 8024018:	2208      	movs	r2, #8
 802401a:	60da      	str	r2, [r3, #12]
}
 802401c:	bf00      	nop
 802401e:	370c      	adds	r7, #12
 8024020:	46bd      	mov	sp, r7
 8024022:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024026:	4770      	bx	lr
 8024028:	50004710 	.word	0x50004710
 802402c:	50004160 	.word	0x50004160

08024030 <XMC_SCU_CLOCK_SetBackupClockCalibrationMode>:
                                  SCU_PLL_USBPLLCON_VCOBYP_Msk);
}

/* API to onfigure the calibration mode for internal oscillator */
void XMC_SCU_CLOCK_SetBackupClockCalibrationMode(XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t mode)
{
 8024030:	b580      	push	{r7, lr}
 8024032:	b082      	sub	sp, #8
 8024034:	af00      	add	r7, sp, #0
 8024036:	4603      	mov	r3, r0
 8024038:	71fb      	strb	r3, [r7, #7]
  /* Enable factory calibration based trimming */
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;
 802403a:	4b0f      	ldr	r3, [pc, #60]	; (8024078 <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 802403c:	685b      	ldr	r3, [r3, #4]
 802403e:	4a0e      	ldr	r2, [pc, #56]	; (8024078 <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 8024040:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8024044:	6053      	str	r3, [r2, #4]

  if (mode == XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC)
 8024046:	79fb      	ldrb	r3, [r7, #7]
 8024048:	2b01      	cmp	r3, #1
 802404a:	d10e      	bne.n	802406a <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x3a>
  {
    /* Disable factory calibration based trimming */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FOTR_Msk;
 802404c:	4b0a      	ldr	r3, [pc, #40]	; (8024078 <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 802404e:	685b      	ldr	r3, [r3, #4]
 8024050:	4a09      	ldr	r2, [pc, #36]	; (8024078 <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 8024052:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8024056:	6053      	str	r3, [r2, #4]
    XMC_SCU_lDelay(100UL);
 8024058:	2064      	movs	r0, #100	; 0x64
 802405a:	f7ff fd49 	bl	8023af0 <XMC_SCU_lDelay>

    /* Enable automatic calibration */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_AOTREN_Msk;
 802405e:	4b06      	ldr	r3, [pc, #24]	; (8024078 <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 8024060:	685b      	ldr	r3, [r3, #4]
 8024062:	4a05      	ldr	r2, [pc, #20]	; (8024078 <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 8024064:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8024068:	6053      	str	r3, [r2, #4]
  }

  XMC_SCU_lDelay(100UL);
 802406a:	2064      	movs	r0, #100	; 0x64
 802406c:	f7ff fd40 	bl	8023af0 <XMC_SCU_lDelay>
}
 8024070:	bf00      	nop
 8024072:	3708      	adds	r7, #8
 8024074:	46bd      	mov	sp, r7
 8024076:	bd80      	pop	{r7, pc}
 8024078:	50004710 	.word	0x50004710

0802407c <XMC_SCU_HIB_EnableHibernateDomain>:
  return (bool)((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOLOCK_Msk) != 0UL);
}

/* API to power up the hibernation domain */
void XMC_SCU_HIB_EnableHibernateDomain(void)
{
 802407c:	b480      	push	{r7}
 802407e:	af00      	add	r7, sp, #0
  /* Power up HIB domain if and only if it is currently powered down */
  if ((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 8024080:	4b12      	ldr	r3, [pc, #72]	; (80240cc <XMC_SCU_HIB_EnableHibernateDomain+0x50>)
 8024082:	681b      	ldr	r3, [r3, #0]
 8024084:	f003 0301 	and.w	r3, r3, #1
 8024088:	2b00      	cmp	r3, #0
 802408a:	d109      	bne.n	80240a0 <XMC_SCU_HIB_EnableHibernateDomain+0x24>
  {
    SCU_POWER->PWRSET = (uint32_t)SCU_POWER_PWRSET_HIB_Msk;
 802408c:	4b0f      	ldr	r3, [pc, #60]	; (80240cc <XMC_SCU_HIB_EnableHibernateDomain+0x50>)
 802408e:	2201      	movs	r2, #1
 8024090:	605a      	str	r2, [r3, #4]

    while ((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 8024092:	bf00      	nop
 8024094:	4b0d      	ldr	r3, [pc, #52]	; (80240cc <XMC_SCU_HIB_EnableHibernateDomain+0x50>)
 8024096:	681b      	ldr	r3, [r3, #0]
 8024098:	f003 0301 	and.w	r3, r3, #1
 802409c:	2b00      	cmp	r3, #0
 802409e:	d0f9      	beq.n	8024094 <XMC_SCU_HIB_EnableHibernateDomain+0x18>
      /* wait until HIB domain is enabled */
    }
  }

  /* Remove the reset only if HIB domain were in a state of reset */
  if ((SCU_RESET->RSTSTAT) & SCU_RESET_RSTSTAT_HIBRS_Msk)
 80240a0:	4b0b      	ldr	r3, [pc, #44]	; (80240d0 <XMC_SCU_HIB_EnableHibernateDomain+0x54>)
 80240a2:	681b      	ldr	r3, [r3, #0]
 80240a4:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80240a8:	2b00      	cmp	r3, #0
 80240aa:	d00a      	beq.n	80240c2 <XMC_SCU_HIB_EnableHibernateDomain+0x46>
  {
    SCU_RESET->RSTCLR = (uint32_t)SCU_RESET_RSTCLR_HIBRS_Msk;
 80240ac:	4b08      	ldr	r3, [pc, #32]	; (80240d0 <XMC_SCU_HIB_EnableHibernateDomain+0x54>)
 80240ae:	f44f 7200 	mov.w	r2, #512	; 0x200
 80240b2:	609a      	str	r2, [r3, #8]
    while ((SCU_RESET->RSTSTAT & SCU_RESET_RSTSTAT_HIBRS_Msk) != 0UL)
 80240b4:	bf00      	nop
 80240b6:	4b06      	ldr	r3, [pc, #24]	; (80240d0 <XMC_SCU_HIB_EnableHibernateDomain+0x54>)
 80240b8:	681b      	ldr	r3, [r3, #0]
 80240ba:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80240be:	2b00      	cmp	r3, #0
 80240c0:	d1f9      	bne.n	80240b6 <XMC_SCU_HIB_EnableHibernateDomain+0x3a>
    {
      /* wait until HIB domain is enabled */
    }
  }
}
 80240c2:	bf00      	nop
 80240c4:	46bd      	mov	sp, r7
 80240c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80240ca:	4770      	bx	lr
 80240cc:	50004200 	.word	0x50004200
 80240d0:	50004400 	.word	0x50004400

080240d4 <XMC_SCU_CLOCK_IsLowPowerOscillatorStable>:
}

#endif

bool XMC_SCU_CLOCK_IsLowPowerOscillatorStable(void)
{
 80240d4:	b480      	push	{r7}
 80240d6:	af00      	add	r7, sp, #0
  return ((SCU_HIBERNATE->HDSTAT & SCU_HIBERNATE_HDSTAT_ULPWDG_Msk) == 0UL);
 80240d8:	4b06      	ldr	r3, [pc, #24]	; (80240f4 <XMC_SCU_CLOCK_IsLowPowerOscillatorStable+0x20>)
 80240da:	681b      	ldr	r3, [r3, #0]
 80240dc:	f003 0308 	and.w	r3, r3, #8
 80240e0:	2b00      	cmp	r3, #0
 80240e2:	bf0c      	ite	eq
 80240e4:	2301      	moveq	r3, #1
 80240e6:	2300      	movne	r3, #0
 80240e8:	b2db      	uxtb	r3, r3
}
 80240ea:	4618      	mov	r0, r3
 80240ec:	46bd      	mov	sp, r7
 80240ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80240f2:	4770      	bx	lr
 80240f4:	50004300 	.word	0x50004300

080240f8 <XMC_SCU_CLOCK_EnableLowPowerOscillator>:

/* API to configure the 32khz Ultra Low Power oscillator */
void XMC_SCU_CLOCK_EnableLowPowerOscillator(void)
{
 80240f8:	b580      	push	{r7, lr}
 80240fa:	af00      	add	r7, sp, #0
  /* Enable OSC_ULP */
  XMC_SCU_INTERRUPT_ClearEventStatus(XMC_SCU_INTERRUPT_EVENT_OSCULCTRL_UPDATED);
 80240fc:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 8024100:	f7ff fd26 	bl	8023b50 <XMC_SCU_INTERRUPT_ClearEventStatus>
  SCU_HIBERNATE->OSCULCTRL &= ~SCU_HIBERNATE_OSCULCTRL_MODE_Msk;
 8024104:	4b18      	ldr	r3, [pc, #96]	; (8024168 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x70>)
 8024106:	69db      	ldr	r3, [r3, #28]
 8024108:	4a17      	ldr	r2, [pc, #92]	; (8024168 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x70>)
 802410a:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 802410e:	61d3      	str	r3, [r2, #28]
  while ((XMC_SCU_INTERUPT_GetEventStatus() & XMC_SCU_INTERRUPT_EVENT_OSCULCTRL_UPDATED) == 0);
 8024110:	bf00      	nop
 8024112:	f7ff fd11 	bl	8023b38 <XMC_SCU_INTERUPT_GetEventStatus>
 8024116:	4603      	mov	r3, r0
 8024118:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 802411c:	2b00      	cmp	r3, #0
 802411e:	d0f8      	beq.n	8024112 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x1a>

  /* Clear ULP WDG status */
  XMC_SCU_INTERRUPT_ClearEventStatus(XMC_SCU_INTERRUPT_EVENT_HDCLR_UPDATED);
 8024120:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8024124:	f7ff fd14 	bl	8023b50 <XMC_SCU_INTERRUPT_ClearEventStatus>
  SCU_HIBERNATE->HDCLR = (uint32_t)SCU_HIBERNATE_HDCLR_ULPWDG_Msk;
 8024128:	4b0f      	ldr	r3, [pc, #60]	; (8024168 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x70>)
 802412a:	2208      	movs	r2, #8
 802412c:	605a      	str	r2, [r3, #4]
  while ((XMC_SCU_INTERUPT_GetEventStatus() & XMC_SCU_INTERRUPT_EVENT_HDCLR_UPDATED) == 0);
 802412e:	bf00      	nop
 8024130:	f7ff fd02 	bl	8023b38 <XMC_SCU_INTERUPT_GetEventStatus>
 8024134:	4603      	mov	r3, r0
 8024136:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 802413a:	2b00      	cmp	r3, #0
 802413c:	d0f8      	beq.n	8024130 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x38>

  /* Enable ULP WDG */
  XMC_SCU_INTERRUPT_ClearEventStatus(XMC_SCU_INTERRUPT_EVENT_HDCR_UPDATED);
 802413e:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8024142:	f7ff fd05 	bl	8023b50 <XMC_SCU_INTERRUPT_ClearEventStatus>
  SCU_HIBERNATE->HDCR |= (uint32_t)SCU_HIBERNATE_HDCR_ULPWDGEN_Msk;
 8024146:	4b08      	ldr	r3, [pc, #32]	; (8024168 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x70>)
 8024148:	68db      	ldr	r3, [r3, #12]
 802414a:	4a07      	ldr	r2, [pc, #28]	; (8024168 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x70>)
 802414c:	f043 0308 	orr.w	r3, r3, #8
 8024150:	60d3      	str	r3, [r2, #12]
  while ((XMC_SCU_INTERUPT_GetEventStatus() & XMC_SCU_INTERRUPT_EVENT_HDCR_UPDATED) == 0);
 8024152:	bf00      	nop
 8024154:	f7ff fcf0 	bl	8023b38 <XMC_SCU_INTERUPT_GetEventStatus>
 8024158:	4603      	mov	r3, r0
 802415a:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 802415e:	2b00      	cmp	r3, #0
 8024160:	d0f8      	beq.n	8024154 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x5c>
}
 8024162:	bf00      	nop
 8024164:	bf00      	nop
 8024166:	bd80      	pop	{r7, pc}
 8024168:	50004300 	.word	0x50004300

0802416c <XMC_SCU_CLOCK_EnableHighPerformanceOscillator>:
  return (SCU_HIBERNATE->OSCULSTAT & SCU_HIBERNATE_OSCULSTAT_X1D_Msk);
}

/* API to enable High Precision High Speed oscillator */
void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void)
{
 802416c:	b598      	push	{r3, r4, r7, lr}
 802416e:	af00      	add	r7, sp, #0
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_PLLPWD_Msk;
 8024170:	4b0f      	ldr	r3, [pc, #60]	; (80241b0 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x44>)
 8024172:	685b      	ldr	r3, [r3, #4]
 8024174:	4a0e      	ldr	r2, [pc, #56]	; (80241b0 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x44>)
 8024176:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 802417a:	6053      	str	r3, [r2, #4]

  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 802417c:	4b0d      	ldr	r3, [pc, #52]	; (80241b4 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x48>)
 802417e:	685b      	ldr	r3, [r3, #4]
 8024180:	f423 2470 	bic.w	r4, r3, #983040	; 0xf0000
 8024184:	f024 0430 	bic.w	r4, r4, #48	; 0x30
                                  (((OSCHP_GetFrequency() / FOSCREF) - 1UL) << SCU_OSC_OSCHPCTRL_OSCVAL_Pos));
 8024188:	f003 f888 	bl	802729c <OSCHP_GetFrequency>
 802418c:	4603      	mov	r3, r0
 802418e:	4a0a      	ldr	r2, [pc, #40]	; (80241b8 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x4c>)
 8024190:	fba2 2303 	umull	r2, r3, r2, r3
 8024194:	0d1b      	lsrs	r3, r3, #20
 8024196:	3b01      	subs	r3, #1
 8024198:	041b      	lsls	r3, r3, #16
  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 802419a:	4a06      	ldr	r2, [pc, #24]	; (80241b4 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x48>)
 802419c:	4323      	orrs	r3, r4
 802419e:	6053      	str	r3, [r2, #4]

  /* restart OSC Watchdog */
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_OSCRES_Msk;
 80241a0:	4b03      	ldr	r3, [pc, #12]	; (80241b0 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x44>)
 80241a2:	685b      	ldr	r3, [r3, #4]
 80241a4:	4a02      	ldr	r2, [pc, #8]	; (80241b0 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x44>)
 80241a6:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 80241aa:	6053      	str	r3, [r2, #4]
}
 80241ac:	bf00      	nop
 80241ae:	bd98      	pop	{r3, r4, r7, pc}
 80241b0:	50004710 	.word	0x50004710
 80241b4:	50004700 	.word	0x50004700
 80241b8:	6b5fca6b 	.word	0x6b5fca6b

080241bc <XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable>:

bool XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable(void)
{
 80241bc:	b480      	push	{r7}
 80241be:	af00      	add	r7, sp, #0
  return ((SCU_PLL->PLLSTAT & XMC_SCU_PLL_PLLSTAT_OSC_USABLE) == XMC_SCU_PLL_PLLSTAT_OSC_USABLE);
 80241c0:	4b07      	ldr	r3, [pc, #28]	; (80241e0 <XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable+0x24>)
 80241c2:	681b      	ldr	r3, [r3, #0]
 80241c4:	f403 7360 	and.w	r3, r3, #896	; 0x380
 80241c8:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
 80241cc:	bf0c      	ite	eq
 80241ce:	2301      	moveq	r3, #1
 80241d0:	2300      	movne	r3, #0
 80241d2:	b2db      	uxtb	r3, r3
}
 80241d4:	4618      	mov	r0, r3
 80241d6:	46bd      	mov	sp, r7
 80241d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80241dc:	4770      	bx	lr
 80241de:	bf00      	nop
 80241e0:	50004710 	.word	0x50004710

080241e4 <XMC_SCU_CLOCK_EnableSystemPll>:
  return (SCU_OSC->OSCHPSTAT & SCU_OSC_OSCHPSTAT_X1D_Msk);
}

/* API to enable main PLL */
void XMC_SCU_CLOCK_EnableSystemPll(void)
{
 80241e4:	b480      	push	{r7}
 80241e6:	af00      	add	r7, sp, #0
  SCU_PLL->PLLCON0 &= (uint32_t)~(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 80241e8:	4b06      	ldr	r3, [pc, #24]	; (8024204 <XMC_SCU_CLOCK_EnableSystemPll+0x20>)
 80241ea:	685b      	ldr	r3, [r3, #4]
 80241ec:	4a05      	ldr	r2, [pc, #20]	; (8024204 <XMC_SCU_CLOCK_EnableSystemPll+0x20>)
 80241ee:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80241f2:	f023 0302 	bic.w	r3, r3, #2
 80241f6:	6053      	str	r3, [r2, #4]
}
 80241f8:	bf00      	nop
 80241fa:	46bd      	mov	sp, r7
 80241fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024200:	4770      	bx	lr
 8024202:	bf00      	nop
 8024204:	50004710 	.word	0x50004710

08024208 <XMC_SCU_CLOCK_DisableSystemPll>:

/* API to disable main PLL */
void XMC_SCU_CLOCK_DisableSystemPll(void)
{
 8024208:	b480      	push	{r7}
 802420a:	af00      	add	r7, sp, #0
  SCU_PLL->PLLCON0 |= (uint32_t)(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 802420c:	4b06      	ldr	r3, [pc, #24]	; (8024228 <XMC_SCU_CLOCK_DisableSystemPll+0x20>)
 802420e:	685b      	ldr	r3, [r3, #4]
 8024210:	4a05      	ldr	r2, [pc, #20]	; (8024228 <XMC_SCU_CLOCK_DisableSystemPll+0x20>)
 8024212:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8024216:	f043 0302 	orr.w	r3, r3, #2
 802421a:	6053      	str	r3, [r2, #4]
}
 802421c:	bf00      	nop
 802421e:	46bd      	mov	sp, r7
 8024220:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024224:	4770      	bx	lr
 8024226:	bf00      	nop
 8024228:	50004710 	.word	0x50004710

0802422c <XMC_SCU_CLOCK_StartSystemPll>:
void XMC_SCU_CLOCK_StartSystemPll(XMC_SCU_CLOCK_SYSPLLCLKSRC_t source,
                                  XMC_SCU_CLOCK_SYSPLL_MODE_t mode,
                                  uint32_t pdiv,
                                  uint32_t ndiv,
                                  uint32_t kdiv)
{
 802422c:	b580      	push	{r7, lr}
 802422e:	b086      	sub	sp, #24
 8024230:	af00      	add	r7, sp, #0
 8024232:	60ba      	str	r2, [r7, #8]
 8024234:	607b      	str	r3, [r7, #4]
 8024236:	4603      	mov	r3, r0
 8024238:	81fb      	strh	r3, [r7, #14]
 802423a:	460b      	mov	r3, r1
 802423c:	737b      	strb	r3, [r7, #13]

  uint32_t vco_frequency; /* Q10.22, max VCO frequency = 520MHz */
  uint32_t kdiv_temp;

  XMC_SCU_CLOCK_SetSystemPllClockSource(source);
 802423e:	89fb      	ldrh	r3, [r7, #14]
 8024240:	4618      	mov	r0, r3
 8024242:	f7ff fd7f 	bl	8023d44 <XMC_SCU_CLOCK_SetSystemPllClockSource>

  if (mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)
 8024246:	7b7b      	ldrb	r3, [r7, #13]
 8024248:	2b01      	cmp	r3, #1
 802424a:	f040 808b 	bne.w	8024364 <XMC_SCU_CLOCK_StartSystemPll+0x138>
  {
    /* Calculate initial step to be close to fOFI */
    if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP)
 802424e:	89fb      	ldrh	r3, [r7, #14]
 8024250:	2b00      	cmp	r3, #0
 8024252:	d109      	bne.n	8024268 <XMC_SCU_CLOCK_StartSystemPll+0x3c>
    {
      vco_frequency = (OSCHP_GetFrequency() / 1000000U) << 22;
 8024254:	f003 f822 	bl	802729c <OSCHP_GetFrequency>
 8024258:	4603      	mov	r3, r0
 802425a:	4a54      	ldr	r2, [pc, #336]	; (80243ac <XMC_SCU_CLOCK_StartSystemPll+0x180>)
 802425c:	fba2 2303 	umull	r2, r3, r2, r3
 8024260:	0c9b      	lsrs	r3, r3, #18
 8024262:	059b      	lsls	r3, r3, #22
 8024264:	617b      	str	r3, [r7, #20]
 8024266:	e002      	b.n	802426e <XMC_SCU_CLOCK_StartSystemPll+0x42>
    }
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
 8024268:	f04f 63c0 	mov.w	r3, #100663296	; 0x6000000
 802426c:	617b      	str	r3, [r7, #20]
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
 802426e:	697b      	ldr	r3, [r7, #20]
 8024270:	687a      	ldr	r2, [r7, #4]
 8024272:	fb03 f202 	mul.w	r2, r3, r2
 8024276:	68bb      	ldr	r3, [r7, #8]
 8024278:	fbb2 f3f3 	udiv	r3, r2, r3
 802427c:	617b      	str	r3, [r7, #20]
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;
 802427e:	697b      	ldr	r3, [r7, #20]
 8024280:	4a4b      	ldr	r2, [pc, #300]	; (80243b0 <XMC_SCU_CLOCK_StartSystemPll+0x184>)
 8024282:	fba2 2303 	umull	r2, r3, r2, r3
 8024286:	091b      	lsrs	r3, r3, #4
 8024288:	0d9b      	lsrs	r3, r3, #22
 802428a:	613b      	str	r3, [r7, #16]

    /* Switch to prescaler mode */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 802428c:	4b49      	ldr	r3, [pc, #292]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 802428e:	685b      	ldr	r3, [r3, #4]
 8024290:	4a48      	ldr	r2, [pc, #288]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8024292:	f043 0301 	orr.w	r3, r3, #1
 8024296:	6053      	str	r3, [r2, #4]
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) == 0U)
 8024298:	bf00      	nop
 802429a:	4b46      	ldr	r3, [pc, #280]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 802429c:	681b      	ldr	r3, [r3, #0]
 802429e:	f003 0301 	and.w	r3, r3, #1
 80242a2:	2b00      	cmp	r3, #0
 80242a4:	d0f9      	beq.n	802429a <XMC_SCU_CLOCK_StartSystemPll+0x6e>
    {
      /* wait for prescaler mode */
    }

    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;
 80242a6:	4b43      	ldr	r3, [pc, #268]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 80242a8:	685b      	ldr	r3, [r3, #4]
 80242aa:	4a42      	ldr	r2, [pc, #264]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 80242ac:	f043 0310 	orr.w	r3, r3, #16
 80242b0:	6053      	str	r3, [r2, #4]

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 80242b2:	4b40      	ldr	r3, [pc, #256]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 80242b4:	689a      	ldr	r2, [r3, #8]
 80242b6:	4b40      	ldr	r3, [pc, #256]	; (80243b8 <XMC_SCU_CLOCK_StartSystemPll+0x18c>)
 80242b8:	4013      	ands	r3, r2
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
 80242ba:	687a      	ldr	r2, [r7, #4]
 80242bc:	3a01      	subs	r2, #1
 80242be:	0212      	lsls	r2, r2, #8
 80242c0:	431a      	orrs	r2, r3
                                  ((kdiv_temp - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos) |
 80242c2:	693b      	ldr	r3, [r7, #16]
 80242c4:	3b01      	subs	r3, #1
 80242c6:	041b      	lsls	r3, r3, #16
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
 80242c8:	431a      	orrs	r2, r3
                                  ((pdiv - 1UL) << SCU_PLL_PLLCON1_PDIV_Pos));
 80242ca:	68bb      	ldr	r3, [r7, #8]
 80242cc:	3b01      	subs	r3, #1
 80242ce:	061b      	lsls	r3, r3, #24
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 80242d0:	4938      	ldr	r1, [pc, #224]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 80242d2:	4313      	orrs	r3, r2
 80242d4:	608b      	str	r3, [r1, #8]

    /* Set OSCDISCDIS, OSC clock remains connected to the VCO in case of loss of lock */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_OSCDISCDIS_Msk;
 80242d6:	4b37      	ldr	r3, [pc, #220]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 80242d8:	685b      	ldr	r3, [r3, #4]
 80242da:	4a36      	ldr	r2, [pc, #216]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 80242dc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80242e0:	6053      	str	r3, [r2, #4]

    /* connect Oscillator to PLL */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FINDIS_Msk;
 80242e2:	4b34      	ldr	r3, [pc, #208]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 80242e4:	685b      	ldr	r3, [r3, #4]
 80242e6:	4a33      	ldr	r2, [pc, #204]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 80242e8:	f023 0310 	bic.w	r3, r3, #16
 80242ec:	6053      	str	r3, [r2, #4]

    /* restart PLL Lock detection */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_RESLD_Msk;
 80242ee:	4b31      	ldr	r3, [pc, #196]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 80242f0:	685b      	ldr	r3, [r3, #4]
 80242f2:	4a30      	ldr	r2, [pc, #192]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 80242f4:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80242f8:	6053      	str	r3, [r2, #4]
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk) == 0U)
 80242fa:	bf00      	nop
 80242fc:	4b2d      	ldr	r3, [pc, #180]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 80242fe:	681b      	ldr	r3, [r3, #0]
 8024300:	f003 0304 	and.w	r3, r3, #4
 8024304:	2b00      	cmp	r3, #0
 8024306:	d0f9      	beq.n	80242fc <XMC_SCU_CLOCK_StartSystemPll+0xd0>
    {
      /* wait for PLL Lock */
    }

    /* Switch to normal mode */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_VCOBYP_Msk;
 8024308:	4b2a      	ldr	r3, [pc, #168]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 802430a:	685b      	ldr	r3, [r3, #4]
 802430c:	4a29      	ldr	r2, [pc, #164]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 802430e:	f023 0301 	bic.w	r3, r3, #1
 8024312:	6053      	str	r3, [r2, #4]
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) != 0U)
 8024314:	bf00      	nop
 8024316:	4b27      	ldr	r3, [pc, #156]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8024318:	681b      	ldr	r3, [r3, #0]
 802431a:	f003 0301 	and.w	r3, r3, #1
 802431e:	2b00      	cmp	r3, #0
 8024320:	d1f9      	bne.n	8024316 <XMC_SCU_CLOCK_StartSystemPll+0xea>
    {
      /* wait for normal mode */
    }

    /* Ramp up PLL frequency in steps */
    kdiv_temp = (vco_frequency / 60UL) >> 22;
 8024322:	697b      	ldr	r3, [r7, #20]
 8024324:	4a25      	ldr	r2, [pc, #148]	; (80243bc <XMC_SCU_CLOCK_StartSystemPll+0x190>)
 8024326:	fba2 2303 	umull	r2, r3, r2, r3
 802432a:	095b      	lsrs	r3, r3, #5
 802432c:	0d9b      	lsrs	r3, r3, #22
 802432e:	613b      	str	r3, [r7, #16]
    if (kdiv < kdiv_temp)
 8024330:	6a3a      	ldr	r2, [r7, #32]
 8024332:	693b      	ldr	r3, [r7, #16]
 8024334:	429a      	cmp	r2, r3
 8024336:	d202      	bcs.n	802433e <XMC_SCU_CLOCK_StartSystemPll+0x112>
    {
      XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv_temp);
 8024338:	6938      	ldr	r0, [r7, #16]
 802433a:	f000 f845 	bl	80243c8 <XMC_SCU_CLOCK_StepSystemPllFrequency>
    }

    kdiv_temp = (vco_frequency / 90UL) >> 22;
 802433e:	697b      	ldr	r3, [r7, #20]
 8024340:	085b      	lsrs	r3, r3, #1
 8024342:	4a1f      	ldr	r2, [pc, #124]	; (80243c0 <XMC_SCU_CLOCK_StartSystemPll+0x194>)
 8024344:	fba2 2303 	umull	r2, r3, r2, r3
 8024348:	095b      	lsrs	r3, r3, #5
 802434a:	0d9b      	lsrs	r3, r3, #22
 802434c:	613b      	str	r3, [r7, #16]
    if (kdiv < kdiv_temp)
 802434e:	6a3a      	ldr	r2, [r7, #32]
 8024350:	693b      	ldr	r3, [r7, #16]
 8024352:	429a      	cmp	r2, r3
 8024354:	d202      	bcs.n	802435c <XMC_SCU_CLOCK_StartSystemPll+0x130>
    {
      XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv_temp);
 8024356:	6938      	ldr	r0, [r7, #16]
 8024358:	f000 f836 	bl	80243c8 <XMC_SCU_CLOCK_StepSystemPllFrequency>
    }

    XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv);
 802435c:	6a38      	ldr	r0, [r7, #32]
 802435e:	f000 f833 	bl	80243c8 <XMC_SCU_CLOCK_StepSystemPllFrequency>
 8024362:	e01c      	b.n	802439e <XMC_SCU_CLOCK_StartSystemPll+0x172>
  }
  else
  {
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K1DIV_Msk) |
 8024364:	4b13      	ldr	r3, [pc, #76]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8024366:	689b      	ldr	r3, [r3, #8]
 8024368:	f023 027f 	bic.w	r2, r3, #127	; 0x7f
                                  ((kdiv - 1UL) << SCU_PLL_PLLCON1_K1DIV_Pos));
 802436c:	6a3b      	ldr	r3, [r7, #32]
 802436e:	3b01      	subs	r3, #1
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K1DIV_Msk) |
 8024370:	4910      	ldr	r1, [pc, #64]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8024372:	4313      	orrs	r3, r2
 8024374:	608b      	str	r3, [r1, #8]

    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_K1RDY_Msk) == 0U)
 8024376:	bf00      	nop
 8024378:	4b0e      	ldr	r3, [pc, #56]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 802437a:	681b      	ldr	r3, [r3, #0]
 802437c:	f003 0310 	and.w	r3, r3, #16
 8024380:	2b00      	cmp	r3, #0
 8024382:	d0f9      	beq.n	8024378 <XMC_SCU_CLOCK_StartSystemPll+0x14c>
    {
      /* wait until K1-divider operates on the configured value  */
    }

    /* Switch to prescaler mode */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 8024384:	4b0b      	ldr	r3, [pc, #44]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8024386:	685b      	ldr	r3, [r3, #4]
 8024388:	4a0a      	ldr	r2, [pc, #40]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 802438a:	f043 0301 	orr.w	r3, r3, #1
 802438e:	6053      	str	r3, [r2, #4]

    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) == 0U)
 8024390:	bf00      	nop
 8024392:	4b08      	ldr	r3, [pc, #32]	; (80243b4 <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8024394:	681b      	ldr	r3, [r3, #0]
 8024396:	f003 0301 	and.w	r3, r3, #1
 802439a:	2b00      	cmp	r3, #0
 802439c:	d0f9      	beq.n	8024392 <XMC_SCU_CLOCK_StartSystemPll+0x166>
    {
      /* wait for prescaler mode */
    }
  }

  SCU_TRAP->TRAPCLR = SCU_TRAP_TRAPCLR_SOSCWDGT_Msk | SCU_TRAP_TRAPCLR_SVCOLCKT_Msk;
 802439e:	4b09      	ldr	r3, [pc, #36]	; (80243c4 <XMC_SCU_CLOCK_StartSystemPll+0x198>)
 80243a0:	2205      	movs	r2, #5
 80243a2:	60da      	str	r2, [r3, #12]
}
 80243a4:	bf00      	nop
 80243a6:	3718      	adds	r7, #24
 80243a8:	46bd      	mov	sp, r7
 80243aa:	bd80      	pop	{r7, pc}
 80243ac:	431bde83 	.word	0x431bde83
 80243b0:	aaaaaaab 	.word	0xaaaaaaab
 80243b4:	50004710 	.word	0x50004710
 80243b8:	f08080ff 	.word	0xf08080ff
 80243bc:	88888889 	.word	0x88888889
 80243c0:	b60b60b7 	.word	0xb60b60b7
 80243c4:	50004160 	.word	0x50004160

080243c8 <XMC_SCU_CLOCK_StepSystemPllFrequency>:
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_PLLPWD_Msk;
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
 80243c8:	b580      	push	{r7, lr}
 80243ca:	b082      	sub	sp, #8
 80243cc:	af00      	add	r7, sp, #0
 80243ce:	6078      	str	r0, [r7, #4]
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 80243d0:	4b0b      	ldr	r3, [pc, #44]	; (8024400 <XMC_SCU_CLOCK_StepSystemPllFrequency+0x38>)
 80243d2:	689b      	ldr	r3, [r3, #8]
 80243d4:	f423 02fe 	bic.w	r2, r3, #8323072	; 0x7f0000
                                ((kdiv - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos));
 80243d8:	687b      	ldr	r3, [r7, #4]
 80243da:	3b01      	subs	r3, #1
 80243dc:	041b      	lsls	r3, r3, #16
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 80243de:	4908      	ldr	r1, [pc, #32]	; (8024400 <XMC_SCU_CLOCK_StepSystemPllFrequency+0x38>)
 80243e0:	4313      	orrs	r3, r2
 80243e2:	608b      	str	r3, [r1, #8]

  while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_K2RDY_Msk) == 0U)
 80243e4:	bf00      	nop
 80243e6:	4b06      	ldr	r3, [pc, #24]	; (8024400 <XMC_SCU_CLOCK_StepSystemPllFrequency+0x38>)
 80243e8:	681b      	ldr	r3, [r3, #0]
 80243ea:	f003 0320 	and.w	r3, r3, #32
 80243ee:	2b00      	cmp	r3, #0
 80243f0:	d0f9      	beq.n	80243e6 <XMC_SCU_CLOCK_StepSystemPllFrequency+0x1e>
  {
    /* wait until K2-divider operates on the configured value  */
  }

  XMC_SCU_lDelay(50U);
 80243f2:	2032      	movs	r0, #50	; 0x32
 80243f4:	f7ff fb7c 	bl	8023af0 <XMC_SCU_lDelay>
}
 80243f8:	bf00      	nop
 80243fa:	3708      	adds	r7, #8
 80243fc:	46bd      	mov	sp, r7
 80243fe:	bd80      	pop	{r7, pc}
 8024400:	50004710 	.word	0x50004710

08024404 <XMC_CAN_IsPanelControlReady>:
 * \par<b>Related APIs:</b><BR>
 *  XMC_CAN_PanelControl()
 *
 */
__STATIC_INLINE bool XMC_CAN_IsPanelControlReady(XMC_CAN_t *const obj)
{
 8024404:	b480      	push	{r7}
 8024406:	b083      	sub	sp, #12
 8024408:	af00      	add	r7, sp, #0
 802440a:	6078      	str	r0, [r7, #4]
  return (bool)((obj->PANCTR & (CAN_PANCTR_BUSY_Msk | CAN_PANCTR_RBUSY_Msk)) == 0);
 802440c:	687b      	ldr	r3, [r7, #4]
 802440e:	f8d3 31c4 	ldr.w	r3, [r3, #452]	; 0x1c4
 8024412:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8024416:	2b00      	cmp	r3, #0
 8024418:	bf0c      	ite	eq
 802441a:	2301      	moveq	r3, #1
 802441c:	2300      	movne	r3, #0
 802441e:	b2db      	uxtb	r3, r3
}
 8024420:	4618      	mov	r0, r3
 8024422:	370c      	adds	r7, #12
 8024424:	46bd      	mov	sp, r7
 8024426:	f85d 7b04 	ldr.w	r7, [sp], #4
 802442a:	4770      	bx	lr

0802442c <XMC_CAN_PanelControl>:

__STATIC_INLINE void XMC_CAN_PanelControl(XMC_CAN_t *const obj,
    const XMC_CAN_PANCMD_t pancmd,
    const uint8_t arg1,
    const uint8_t arg2)
{
 802442c:	b480      	push	{r7}
 802442e:	b083      	sub	sp, #12
 8024430:	af00      	add	r7, sp, #0
 8024432:	6078      	str	r0, [r7, #4]
 8024434:	4608      	mov	r0, r1
 8024436:	4611      	mov	r1, r2
 8024438:	461a      	mov	r2, r3
 802443a:	4603      	mov	r3, r0
 802443c:	70fb      	strb	r3, [r7, #3]
 802443e:	460b      	mov	r3, r1
 8024440:	70bb      	strb	r3, [r7, #2]
 8024442:	4613      	mov	r3, r2
 8024444:	707b      	strb	r3, [r7, #1]
  obj->PANCTR = (((uint32_t)pancmd << CAN_PANCTR_PANCMD_Pos) & (uint32_t)CAN_PANCTR_PANCMD_Msk) |
 8024446:	78fa      	ldrb	r2, [r7, #3]
                (((uint32_t)arg1 << CAN_PANCTR_PANAR1_Pos) & (uint32_t)CAN_PANCTR_PANAR1_Msk) |
 8024448:	78bb      	ldrb	r3, [r7, #2]
 802444a:	041b      	lsls	r3, r3, #16
 802444c:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  obj->PANCTR = (((uint32_t)pancmd << CAN_PANCTR_PANCMD_Pos) & (uint32_t)CAN_PANCTR_PANCMD_Msk) |
 8024450:	431a      	orrs	r2, r3
                (((uint32_t)arg2 << CAN_PANCTR_PANAR2_Pos) & (uint32_t)CAN_PANCTR_PANAR2_Msk);
 8024452:	787b      	ldrb	r3, [r7, #1]
 8024454:	061b      	lsls	r3, r3, #24
                (((uint32_t)arg1 << CAN_PANCTR_PANAR1_Pos) & (uint32_t)CAN_PANCTR_PANAR1_Msk) |
 8024456:	431a      	orrs	r2, r3
  obj->PANCTR = (((uint32_t)pancmd << CAN_PANCTR_PANCMD_Pos) & (uint32_t)CAN_PANCTR_PANCMD_Msk) |
 8024458:	687b      	ldr	r3, [r7, #4]
 802445a:	f8c3 21c4 	str.w	r2, [r3, #452]	; 0x1c4
}
 802445e:	bf00      	nop
 8024460:	370c      	adds	r7, #12
 8024462:	46bd      	mov	sp, r7
 8024464:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024468:	4770      	bx	lr

0802446a <XMC_CAN_NODE_EnableConfigurationChange>:
 * XMC_CAN_NODE_DisableConfigurationChange()
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_EnableConfigurationChange(XMC_CAN_NODE_t *const can_node)
{
 802446a:	b480      	push	{r7}
 802446c:	b083      	sub	sp, #12
 802446e:	af00      	add	r7, sp, #0
 8024470:	6078      	str	r0, [r7, #4]
  can_node->NCR |= (uint32_t)CAN_NODE_NCR_CCE_Msk;
 8024472:	687b      	ldr	r3, [r7, #4]
 8024474:	681b      	ldr	r3, [r3, #0]
 8024476:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 802447a:	687b      	ldr	r3, [r7, #4]
 802447c:	601a      	str	r2, [r3, #0]
}
 802447e:	bf00      	nop
 8024480:	370c      	adds	r7, #12
 8024482:	46bd      	mov	sp, r7
 8024484:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024488:	4770      	bx	lr

0802448a <XMC_CAN_NODE_DisableConfigurationChange>:
 * XMC_CAN_NODE_EnableConfigurationChange()
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_DisableConfigurationChange(XMC_CAN_NODE_t *const can_node)
{
 802448a:	b480      	push	{r7}
 802448c:	b083      	sub	sp, #12
 802448e:	af00      	add	r7, sp, #0
 8024490:	6078      	str	r0, [r7, #4]
  can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_CCE_Msk;
 8024492:	687b      	ldr	r3, [r7, #4]
 8024494:	681b      	ldr	r3, [r3, #0]
 8024496:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 802449a:	687b      	ldr	r3, [r7, #4]
 802449c:	601a      	str	r2, [r3, #0]
}
 802449e:	bf00      	nop
 80244a0:	370c      	adds	r7, #12
 80244a2:	46bd      	mov	sp, r7
 80244a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80244a8:	4770      	bx	lr

080244aa <max>:

#if defined(CAN)
#include "xmc_scu.h"

__STATIC_INLINE uint32_t max(uint32_t a, uint32_t b)
{
 80244aa:	b480      	push	{r7}
 80244ac:	b083      	sub	sp, #12
 80244ae:	af00      	add	r7, sp, #0
 80244b0:	6078      	str	r0, [r7, #4]
 80244b2:	6039      	str	r1, [r7, #0]
  return (a > b) ? a : b;
 80244b4:	683a      	ldr	r2, [r7, #0]
 80244b6:	687b      	ldr	r3, [r7, #4]
 80244b8:	4293      	cmp	r3, r2
 80244ba:	bf38      	it	cc
 80244bc:	4613      	movcc	r3, r2
}
 80244be:	4618      	mov	r0, r3
 80244c0:	370c      	adds	r7, #12
 80244c2:	46bd      	mov	sp, r7
 80244c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80244c8:	4770      	bx	lr

080244ca <min>:

__STATIC_INLINE uint32_t min(uint32_t a, uint32_t b)
{
 80244ca:	b480      	push	{r7}
 80244cc:	b083      	sub	sp, #12
 80244ce:	af00      	add	r7, sp, #0
 80244d0:	6078      	str	r0, [r7, #4]
 80244d2:	6039      	str	r1, [r7, #0]
  return (a < b) ? a : b;
 80244d4:	683a      	ldr	r2, [r7, #0]
 80244d6:	687b      	ldr	r3, [r7, #4]
 80244d8:	4293      	cmp	r3, r2
 80244da:	bf28      	it	cs
 80244dc:	4613      	movcs	r3, r2
}
 80244de:	4618      	mov	r0, r3
 80244e0:	370c      	adds	r7, #12
 80244e2:	46bd      	mov	sp, r7
 80244e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80244e8:	4770      	bx	lr
	...

080244ec <XMC_CAN_NODE_NominalBitTimeConfigureEx>:
#define XMC_CAN_NODE_MAX_TSEG2 7


int32_t XMC_CAN_NODE_NominalBitTimeConfigureEx(XMC_CAN_NODE_t *const can_node,
    const XMC_CAN_NODE_NOMINAL_BIT_TIME_CONFIG_t *const bit_time_config)
{
 80244ec:	b580      	push	{r7, lr}
 80244ee:	b088      	sub	sp, #32
 80244f0:	af00      	add	r7, sp, #0
 80244f2:	6078      	str	r0, [r7, #4]
 80244f4:	6039      	str	r1, [r7, #0]
  /* Check that the CAN frequency is a multiple of the required baudrate */
  if ((bit_time_config->can_frequency % bit_time_config->baudrate) == 0)
 80244f6:	683b      	ldr	r3, [r7, #0]
 80244f8:	681b      	ldr	r3, [r3, #0]
 80244fa:	683a      	ldr	r2, [r7, #0]
 80244fc:	6852      	ldr	r2, [r2, #4]
 80244fe:	fbb3 f1f2 	udiv	r1, r3, r2
 8024502:	fb01 f202 	mul.w	r2, r1, r2
 8024506:	1a9b      	subs	r3, r3, r2
 8024508:	2b00      	cmp	r3, #0
 802450a:	f040 8091 	bne.w	8024630 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x144>
  {
    uint32_t prescaler = 0;
 802450e:	2300      	movs	r3, #0
 8024510:	61fb      	str	r3, [r7, #28]
    uint32_t div8 = 0;
 8024512:	2300      	movs	r3, #0
 8024514:	61bb      	str	r3, [r7, #24]

    /* Calculate the factor between can frequency and required baudrate, this is equal to (prescaler x ntq) */
    uint32_t fcan_div = bit_time_config->can_frequency / bit_time_config->baudrate;
 8024516:	683b      	ldr	r3, [r7, #0]
 8024518:	681a      	ldr	r2, [r3, #0]
 802451a:	683b      	ldr	r3, [r7, #0]
 802451c:	685b      	ldr	r3, [r3, #4]
 802451e:	fbb2 f3f3 	udiv	r3, r2, r3
 8024522:	60bb      	str	r3, [r7, #8]

    /* start with highest ntq, i.e as much as possible time quanta should be used to construct a bit time */
    uint32_t ntq = XMC_CAN_NODE_MAX_NTQ;
 8024524:	2319      	movs	r3, #25
 8024526:	617b      	str	r3, [r7, #20]
    uint32_t tseg1 = 0;
 8024528:	2300      	movs	r3, #0
 802452a:	613b      	str	r3, [r7, #16]
    uint32_t tseg2 = 0;
 802452c:	2300      	movs	r3, #0
 802452e:	60fb      	str	r3, [r7, #12]
    while (ntq >= XMC_CAN_NODE_MIN_NTQ)
 8024530:	e04a      	b.n	80245c8 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xdc>
    {
      /* consider this ntq, only if fcan_div is multiple of ntq */
      if ((fcan_div % ntq) == 0)
 8024532:	68bb      	ldr	r3, [r7, #8]
 8024534:	697a      	ldr	r2, [r7, #20]
 8024536:	fbb3 f2f2 	udiv	r2, r3, r2
 802453a:	6979      	ldr	r1, [r7, #20]
 802453c:	fb01 f202 	mul.w	r2, r1, r2
 8024540:	1a9b      	subs	r3, r3, r2
 8024542:	2b00      	cmp	r3, #0
 8024544:	d13d      	bne.n	80245c2 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd6>
      {
        div8 = 0;
 8024546:	2300      	movs	r3, #0
 8024548:	61bb      	str	r3, [r7, #24]
        prescaler = fcan_div / ntq;
 802454a:	68ba      	ldr	r2, [r7, #8]
 802454c:	697b      	ldr	r3, [r7, #20]
 802454e:	fbb2 f3f3 	udiv	r3, r2, r3
 8024552:	61fb      	str	r3, [r7, #28]
        if ((prescaler > 0) && (prescaler <= XMC_CAN_NODE_MAX_PRESCALER))
 8024554:	69fb      	ldr	r3, [r7, #28]
 8024556:	2b00      	cmp	r3, #0
 8024558:	d033      	beq.n	80245c2 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd6>
 802455a:	69fb      	ldr	r3, [r7, #28]
 802455c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8024560:	d82f      	bhi.n	80245c2 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd6>
        {
          if (prescaler >= 64)
 8024562:	69fb      	ldr	r3, [r7, #28]
 8024564:	2b3f      	cmp	r3, #63	; 0x3f
 8024566:	d90a      	bls.n	802457e <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x92>
          {
            /* consider prescaler >=64, if it is integer divisible by 8*/
            if ((prescaler & 0x7U) != 0)
 8024568:	69fb      	ldr	r3, [r7, #28]
 802456a:	f003 0307 	and.w	r3, r3, #7
 802456e:	2b00      	cmp	r3, #0
 8024570:	d003      	beq.n	802457a <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x8e>
            {
              --ntq;
 8024572:	697b      	ldr	r3, [r7, #20]
 8024574:	3b01      	subs	r3, #1
 8024576:	617b      	str	r3, [r7, #20]
              continue;
 8024578:	e026      	b.n	80245c8 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xdc>
            }
            else
            {
              div8 = 1;
 802457a:	2301      	movs	r3, #1
 802457c:	61bb      	str	r3, [r7, #24]
            }
          }

          tseg1 = ((ntq - 1) * bit_time_config->sample_point) / 10000;
 802457e:	697b      	ldr	r3, [r7, #20]
 8024580:	3b01      	subs	r3, #1
 8024582:	683a      	ldr	r2, [r7, #0]
 8024584:	8912      	ldrh	r2, [r2, #8]
 8024586:	fb02 f303 	mul.w	r3, r2, r3
 802458a:	4a2c      	ldr	r2, [pc, #176]	; (802463c <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x150>)
 802458c:	fba2 2303 	umull	r2, r3, r2, r3
 8024590:	0b5b      	lsrs	r3, r3, #13
 8024592:	613b      	str	r3, [r7, #16]
          tseg2 = ntq - tseg1 - 1;
 8024594:	697a      	ldr	r2, [r7, #20]
 8024596:	693b      	ldr	r3, [r7, #16]
 8024598:	1ad3      	subs	r3, r2, r3
 802459a:	3b01      	subs	r3, #1
 802459c:	60fb      	str	r3, [r7, #12]

          if ((XMC_CAN_NODE_MIN_TSEG1 <= tseg1) && (tseg1 <= XMC_CAN_NODE_MAX_TSEG1) &&
 802459e:	693b      	ldr	r3, [r7, #16]
 80245a0:	2b02      	cmp	r3, #2
 80245a2:	d90e      	bls.n	80245c2 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd6>
 80245a4:	693b      	ldr	r3, [r7, #16]
 80245a6:	2b0f      	cmp	r3, #15
 80245a8:	d80b      	bhi.n	80245c2 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd6>
 80245aa:	68fb      	ldr	r3, [r7, #12]
 80245ac:	2b01      	cmp	r3, #1
 80245ae:	d908      	bls.n	80245c2 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd6>
              (XMC_CAN_NODE_MIN_TSEG2 <= tseg2) && (tseg2 < XMC_CAN_NODE_MAX_TSEG2) && (tseg2 >= bit_time_config->sjw))
 80245b0:	68fb      	ldr	r3, [r7, #12]
 80245b2:	2b06      	cmp	r3, #6
 80245b4:	d805      	bhi.n	80245c2 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xd6>
 80245b6:	683b      	ldr	r3, [r7, #0]
 80245b8:	895b      	ldrh	r3, [r3, #10]
 80245ba:	461a      	mov	r2, r3
 80245bc:	68fb      	ldr	r3, [r7, #12]
 80245be:	4293      	cmp	r3, r2
 80245c0:	d206      	bcs.n	80245d0 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xe4>
          }


        }
      }
      --ntq;
 80245c2:	697b      	ldr	r3, [r7, #20]
 80245c4:	3b01      	subs	r3, #1
 80245c6:	617b      	str	r3, [r7, #20]
    while (ntq >= XMC_CAN_NODE_MIN_NTQ)
 80245c8:	697b      	ldr	r3, [r7, #20]
 80245ca:	2b07      	cmp	r3, #7
 80245cc:	d8b1      	bhi.n	8024532 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x46>
 80245ce:	e000      	b.n	80245d2 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0xe6>
            break;
 80245d0:	bf00      	nop
    }

    if (ntq >= XMC_CAN_NODE_MIN_NTQ)
 80245d2:	697b      	ldr	r3, [r7, #20]
 80245d4:	2b07      	cmp	r3, #7
 80245d6:	d92b      	bls.n	8024630 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x144>

      XMC_ASSERT("XMC_CAN_NODE_NominalBitTimeConfigureEx: prescaler", (prescaler != 0));
      XMC_ASSERT("XMC_CAN_NODE_NominalBitTimeConfigureEx: tseg1", (tseg1 != 0));
      XMC_ASSERT("XMC_CAN_NODE_NominalBitTimeConfigureEx: tseg2", (tseg2 != 0));

      XMC_CAN_NODE_EnableConfigurationChange(can_node);
 80245d8:	6878      	ldr	r0, [r7, #4]
 80245da:	f7ff ff46 	bl	802446a <XMC_CAN_NODE_EnableConfigurationChange>

      /* Configure bit timing register */
      can_node->NBTR = (((tseg2 - 1u) << CAN_NODE_NBTR_TSEG2_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG2_Msk) |
 80245de:	68fb      	ldr	r3, [r7, #12]
 80245e0:	3b01      	subs	r3, #1
 80245e2:	031b      	lsls	r3, r3, #12
 80245e4:	f403 42e0 	and.w	r2, r3, #28672	; 0x7000
                       (((bit_time_config->sjw - 1U) << CAN_NODE_NBTR_SJW_Pos) & (uint32_t)CAN_NODE_NBTR_SJW_Msk) |
 80245e8:	683b      	ldr	r3, [r7, #0]
 80245ea:	895b      	ldrh	r3, [r3, #10]
 80245ec:	3b01      	subs	r3, #1
 80245ee:	019b      	lsls	r3, r3, #6
 80245f0:	b2db      	uxtb	r3, r3
      can_node->NBTR = (((tseg2 - 1u) << CAN_NODE_NBTR_TSEG2_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG2_Msk) |
 80245f2:	431a      	orrs	r2, r3
                       (((tseg1 - 1U) << CAN_NODE_NBTR_TSEG1_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG1_Msk) |
 80245f4:	693b      	ldr	r3, [r7, #16]
 80245f6:	3b01      	subs	r3, #1
 80245f8:	021b      	lsls	r3, r3, #8
 80245fa:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
                       (((bit_time_config->sjw - 1U) << CAN_NODE_NBTR_SJW_Pos) & (uint32_t)CAN_NODE_NBTR_SJW_Msk) |
 80245fe:	ea42 0103 	orr.w	r1, r2, r3
                       ((((prescaler >> (3 * div8)) - 1U) << CAN_NODE_NBTR_BRP_Pos) & (uint32_t)CAN_NODE_NBTR_BRP_Msk) |
 8024602:	69ba      	ldr	r2, [r7, #24]
 8024604:	4613      	mov	r3, r2
 8024606:	005b      	lsls	r3, r3, #1
 8024608:	4413      	add	r3, r2
 802460a:	69fa      	ldr	r2, [r7, #28]
 802460c:	fa22 f303 	lsr.w	r3, r2, r3
 8024610:	3b01      	subs	r3, #1
 8024612:	f003 033f 	and.w	r3, r3, #63	; 0x3f
                       (((tseg1 - 1U) << CAN_NODE_NBTR_TSEG1_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG1_Msk) |
 8024616:	ea41 0203 	orr.w	r2, r1, r3
                       ((div8 << CAN_NODE_NBTR_DIV8_Pos) & (uint32_t)CAN_NODE_NBTR_DIV8_Msk);
 802461a:	69bb      	ldr	r3, [r7, #24]
 802461c:	03db      	lsls	r3, r3, #15
 802461e:	b29b      	uxth	r3, r3
                       ((((prescaler >> (3 * div8)) - 1U) << CAN_NODE_NBTR_BRP_Pos) & (uint32_t)CAN_NODE_NBTR_BRP_Msk) |
 8024620:	431a      	orrs	r2, r3
      can_node->NBTR = (((tseg2 - 1u) << CAN_NODE_NBTR_TSEG2_Pos) & (uint32_t)CAN_NODE_NBTR_TSEG2_Msk) |
 8024622:	687b      	ldr	r3, [r7, #4]
 8024624:	611a      	str	r2, [r3, #16]

      XMC_CAN_NODE_DisableConfigurationChange(can_node);
 8024626:	6878      	ldr	r0, [r7, #4]
 8024628:	f7ff ff2f 	bl	802448a <XMC_CAN_NODE_DisableConfigurationChange>

      return XMC_CAN_STATUS_SUCCESS;
 802462c:	2300      	movs	r3, #0
 802462e:	e000      	b.n	8024632 <XMC_CAN_NODE_NominalBitTimeConfigureEx+0x146>
    }
  }

  return XMC_CAN_STATUS_ERROR;
 8024630:	2301      	movs	r3, #1
}
 8024632:	4618      	mov	r0, r3
 8024634:	3720      	adds	r7, #32
 8024636:	46bd      	mov	sp, r7
 8024638:	bd80      	pop	{r7, pc}
 802463a:	bf00      	nop
 802463c:	d1b71759 	.word	0xd1b71759

08024640 <XMC_CAN_AllocateMOtoNodeList>:
                   (((uint32_t)0U << CAN_NODE_NBTR_DIV8_Pos) & (uint32_t)CAN_NODE_NBTR_DIV8_Msk);
  XMC_CAN_NODE_DisableConfigurationChange(can_node);
}
/* Function to allocate message object from free list to node list */
void XMC_CAN_AllocateMOtoNodeList(XMC_CAN_t *const obj, const uint8_t node_num, const uint8_t mo_num)
{
 8024640:	b580      	push	{r7, lr}
 8024642:	b082      	sub	sp, #8
 8024644:	af00      	add	r7, sp, #0
 8024646:	6078      	str	r0, [r7, #4]
 8024648:	460b      	mov	r3, r1
 802464a:	70fb      	strb	r3, [r7, #3]
 802464c:	4613      	mov	r3, r2
 802464e:	70bb      	strb	r3, [r7, #2]
  /* wait while panel operation is in progress. */
  while (XMC_CAN_IsPanelControlReady(obj) == false)
 8024650:	bf00      	nop
 8024652:	6878      	ldr	r0, [r7, #4]
 8024654:	f7ff fed6 	bl	8024404 <XMC_CAN_IsPanelControlReady>
 8024658:	4603      	mov	r3, r0
 802465a:	f083 0301 	eor.w	r3, r3, #1
 802465e:	b2db      	uxtb	r3, r3
 8024660:	2b00      	cmp	r3, #0
 8024662:	d1f6      	bne.n	8024652 <XMC_CAN_AllocateMOtoNodeList+0x12>
  {
    /*Do nothing*/
  };

  /* Panel Command for  allocation of MO to node list */
  XMC_CAN_PanelControl(obj, XMC_CAN_PANCMD_STATIC_ALLOCATE, mo_num, (node_num + 1U));
 8024664:	78fb      	ldrb	r3, [r7, #3]
 8024666:	3301      	adds	r3, #1
 8024668:	b2db      	uxtb	r3, r3
 802466a:	78ba      	ldrb	r2, [r7, #2]
 802466c:	2102      	movs	r1, #2
 802466e:	6878      	ldr	r0, [r7, #4]
 8024670:	f7ff fedc 	bl	802442c <XMC_CAN_PanelControl>
}
 8024674:	bf00      	nop
 8024676:	3708      	adds	r7, #8
 8024678:	46bd      	mov	sp, r7
 802467a:	bd80      	pop	{r7, pc}

0802467c <XMC_CAN_Enable>:
#endif
}

/* Enable XMC_CAN Peripheral */
void XMC_CAN_Enable(XMC_CAN_t *const obj)
{
 802467c:	b580      	push	{r7, lr}
 802467e:	b082      	sub	sp, #8
 8024680:	af00      	add	r7, sp, #0
 8024682:	6078      	str	r0, [r7, #4]
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_MCAN);
 8024684:	480b      	ldr	r0, [pc, #44]	; (80246b4 <XMC_CAN_Enable+0x38>)
 8024686:	f7ff fc49 	bl	8023f1c <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
#if defined(PERIPHERAL_RESET_SUPPORTED)
  XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_MCAN);
 802468a:	480a      	ldr	r0, [pc, #40]	; (80246b4 <XMC_CAN_Enable+0x38>)
 802468c:	f7ff faf0 	bl	8023c70 <XMC_SCU_RESET_DeassertPeripheralReset>
#endif
  /* Enable CAN Module */
  obj->CLC &= ~(uint32_t)CAN_CLC_DISR_Msk;
 8024690:	687b      	ldr	r3, [r7, #4]
 8024692:	681b      	ldr	r3, [r3, #0]
 8024694:	f023 0201 	bic.w	r2, r3, #1
 8024698:	687b      	ldr	r3, [r7, #4]
 802469a:	601a      	str	r2, [r3, #0]
  while (obj->CLC & CAN_CLC_DISS_Msk)
 802469c:	bf00      	nop
 802469e:	687b      	ldr	r3, [r7, #4]
 80246a0:	681b      	ldr	r3, [r3, #0]
 80246a2:	f003 0302 	and.w	r3, r3, #2
 80246a6:	2b00      	cmp	r3, #0
 80246a8:	d1f9      	bne.n	802469e <XMC_CAN_Enable+0x22>
  {
    /*Do nothing*/
  };
}
 80246aa:	bf00      	nop
 80246ac:	bf00      	nop
 80246ae:	3708      	adds	r7, #8
 80246b0:	46bd      	mov	sp, r7
 80246b2:	bd80      	pop	{r7, pc}
 80246b4:	10000010 	.word	0x10000010

080246b8 <XMC_CAN_SetBaudrateClockSource>:
  obj->FDR |= ((uint32_t)can_divider_mode << CAN_FDR_DM_Pos) | ((uint32_t)step << CAN_FDR_STEP_Pos);
}
#endif

void XMC_CAN_SetBaudrateClockSource(XMC_CAN_t *const obj, const XMC_CAN_CANCLKSRC_t source)
{
 80246b8:	b480      	push	{r7}
 80246ba:	b083      	sub	sp, #12
 80246bc:	af00      	add	r7, sp, #0
 80246be:	6078      	str	r0, [r7, #4]
 80246c0:	460b      	mov	r3, r1
 80246c2:	70fb      	strb	r3, [r7, #3]
#if defined(MULTICAN_PLUS)
  obj->MCR = (obj->MCR & ~CAN_MCR_CLKSEL_Msk) | source ;
 80246c4:	687b      	ldr	r3, [r7, #4]
 80246c6:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 80246ca:	f023 020f 	bic.w	r2, r3, #15
 80246ce:	78fb      	ldrb	r3, [r7, #3]
 80246d0:	431a      	orrs	r2, r3
 80246d2:	687b      	ldr	r3, [r7, #4]
 80246d4:	f8c3 21c8 	str.w	r2, [r3, #456]	; 0x1c8
#else
  XMC_UNUSED_ARG(obj);
  XMC_UNUSED_ARG(source);
#endif
}
 80246d8:	bf00      	nop
 80246da:	370c      	adds	r7, #12
 80246dc:	46bd      	mov	sp, r7
 80246de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80246e2:	4770      	bx	lr

080246e4 <XMC_CAN_GetBaudrateClockSource>:

XMC_CAN_CANCLKSRC_t XMC_CAN_GetBaudrateClockSource(XMC_CAN_t *const obj)
{
 80246e4:	b480      	push	{r7}
 80246e6:	b083      	sub	sp, #12
 80246e8:	af00      	add	r7, sp, #0
 80246ea:	6078      	str	r0, [r7, #4]
#if defined(MULTICAN_PLUS)
  return ((XMC_CAN_CANCLKSRC_t)((obj->MCR & CAN_MCR_CLKSEL_Msk) >> CAN_MCR_CLKSEL_Pos));
 80246ec:	687b      	ldr	r3, [r7, #4]
 80246ee:	f8d3 31c8 	ldr.w	r3, [r3, #456]	; 0x1c8
 80246f2:	b2db      	uxtb	r3, r3
 80246f4:	f003 030f 	and.w	r3, r3, #15
 80246f8:	b2db      	uxtb	r3, r3
#elif (UC_FAMILY == XMC4)
  XMC_UNUSED_ARG(obj);
  return XMC_CAN_CANCLKSRC_FPERI;
#endif
}
 80246fa:	4618      	mov	r0, r3
 80246fc:	370c      	adds	r7, #12
 80246fe:	46bd      	mov	sp, r7
 8024700:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024704:	4770      	bx	lr

08024706 <XMC_CAN_GetBaudrateClockFrequency>:

uint32_t XMC_CAN_GetBaudrateClockFrequency(XMC_CAN_t *const obj)
{
 8024706:	b580      	push	{r7, lr}
 8024708:	b084      	sub	sp, #16
 802470a:	af00      	add	r7, sp, #0
 802470c:	6078      	str	r0, [r7, #4]
  uint32_t frequency = 0;
 802470e:	2300      	movs	r3, #0
 8024710:	60fb      	str	r3, [r7, #12]

#if defined(MULTICAN_PLUS)
  switch (XMC_CAN_GetBaudrateClockSource(obj))
 8024712:	6878      	ldr	r0, [r7, #4]
 8024714:	f7ff ffe6 	bl	80246e4 <XMC_CAN_GetBaudrateClockSource>
 8024718:	4603      	mov	r3, r0
 802471a:	2b01      	cmp	r3, #1
 802471c:	d002      	beq.n	8024724 <XMC_CAN_GetBaudrateClockFrequency+0x1e>
 802471e:	2b02      	cmp	r3, #2
 8024720:	d004      	beq.n	802472c <XMC_CAN_GetBaudrateClockFrequency+0x26>
 8024722:	e007      	b.n	8024734 <XMC_CAN_GetBaudrateClockFrequency+0x2e>
  {
#if UC_FAMILY == XMC4
    case XMC_CAN_CANCLKSRC_FPERI:
      frequency = XMC_SCU_CLOCK_GetPeripheralClockFrequency();
 8024724:	f7ff fac2 	bl	8023cac <XMC_SCU_CLOCK_GetPeripheralClockFrequency>
 8024728:	60f8      	str	r0, [r7, #12]
      break;
 802472a:	e003      	b.n	8024734 <XMC_CAN_GetBaudrateClockFrequency+0x2e>
    case XMC_CAN_CANCLKSRC_MCLK:
      frequency = XMC_SCU_CLOCK_GetPeripheralClockFrequency();
      break;
#endif
    case XMC_CAN_CANCLKSRC_FOHP:
      frequency = OSCHP_GetFrequency();
 802472c:	f002 fdb6 	bl	802729c <OSCHP_GetFrequency>
 8024730:	60f8      	str	r0, [r7, #12]
      break;
 8024732:	bf00      	nop
#else
  XMC_UNUSED_ARG(obj);
  frequency = XMC_SCU_CLOCK_GetPeripheralClockFrequency();
#endif

  return frequency;
 8024734:	68fb      	ldr	r3, [r7, #12]
}
 8024736:	4618      	mov	r0, r3
 8024738:	3710      	adds	r7, #16
 802473a:	46bd      	mov	sp, r7
 802473c:	bd80      	pop	{r7, pc}

0802473e <XMC_CAN_InitEx>:

uint32_t XMC_CAN_InitEx(XMC_CAN_t *const obj, XMC_CAN_CANCLKSRC_t clksrc, uint32_t can_frequency)
{
 802473e:	b580      	push	{r7, lr}
 8024740:	b088      	sub	sp, #32
 8024742:	af00      	add	r7, sp, #0
 8024744:	60f8      	str	r0, [r7, #12]
 8024746:	460b      	mov	r3, r1
 8024748:	607a      	str	r2, [r7, #4]
 802474a:	72fb      	strb	r3, [r7, #11]
  uint32_t step_n;
  uint32_t freq_n;
  uint32_t peripheral_frequency;

  /*Enabling the module*/
  XMC_CAN_Enable(obj);
 802474c:	68f8      	ldr	r0, [r7, #12]
 802474e:	f7ff ff95 	bl	802467c <XMC_CAN_Enable>

  XMC_CAN_SetBaudrateClockSource(obj, clksrc);
 8024752:	7afb      	ldrb	r3, [r7, #11]
 8024754:	4619      	mov	r1, r3
 8024756:	68f8      	ldr	r0, [r7, #12]
 8024758:	f7ff ffae 	bl	80246b8 <XMC_CAN_SetBaudrateClockSource>
  peripheral_frequency = XMC_CAN_GetBaudrateClockFrequency(obj);
 802475c:	68f8      	ldr	r0, [r7, #12]
 802475e:	f7ff ffd2 	bl	8024706 <XMC_CAN_GetBaudrateClockFrequency>
 8024762:	61f8      	str	r0, [r7, #28]
  XMC_ASSERT("XMC_CAN_Init: frequency not supported", can_frequency <= peripheral_frequency);

  /* Normal divider mode */
  step_n = (uint32_t)min(max(0U, (1024U - (peripheral_frequency / can_frequency))), 1023U);
 8024764:	69fa      	ldr	r2, [r7, #28]
 8024766:	687b      	ldr	r3, [r7, #4]
 8024768:	fbb2 f3f3 	udiv	r3, r2, r3
 802476c:	f5c3 6380 	rsb	r3, r3, #1024	; 0x400
 8024770:	4619      	mov	r1, r3
 8024772:	2000      	movs	r0, #0
 8024774:	f7ff fe99 	bl	80244aa <max>
 8024778:	4603      	mov	r3, r0
 802477a:	f240 31ff 	movw	r1, #1023	; 0x3ff
 802477e:	4618      	mov	r0, r3
 8024780:	f7ff fea3 	bl	80244ca <min>
 8024784:	61b8      	str	r0, [r7, #24]
  freq_n = (uint32_t)(peripheral_frequency / (1024U - step_n));
 8024786:	69bb      	ldr	r3, [r7, #24]
 8024788:	f5c3 6380 	rsb	r3, r3, #1024	; 0x400
 802478c:	69fa      	ldr	r2, [r7, #28]
 802478e:	fbb2 f3f3 	udiv	r3, r2, r3
 8024792:	617b      	str	r3, [r7, #20]

  obj->FDR &= (uint32_t) ~(CAN_FDR_DM_Msk | CAN_FDR_STEP_Msk);
 8024794:	68fb      	ldr	r3, [r7, #12]
 8024796:	68db      	ldr	r3, [r3, #12]
 8024798:	f423 4343 	bic.w	r3, r3, #49920	; 0xc300
 802479c:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 80247a0:	68fa      	ldr	r2, [r7, #12]
 80247a2:	60d3      	str	r3, [r2, #12]
  obj->FDR |= ((uint32_t)XMC_CAN_DM_NORMAL << CAN_FDR_DM_Pos) | ((uint32_t)step_n << CAN_FDR_STEP_Pos);
 80247a4:	68fb      	ldr	r3, [r7, #12]
 80247a6:	68da      	ldr	r2, [r3, #12]
 80247a8:	69bb      	ldr	r3, [r7, #24]
 80247aa:	4313      	orrs	r3, r2
 80247ac:	f443 4280 	orr.w	r2, r3, #16384	; 0x4000
 80247b0:	68fb      	ldr	r3, [r7, #12]
 80247b2:	60da      	str	r2, [r3, #12]

  return freq_n;
 80247b4:	697b      	ldr	r3, [r7, #20]
}
 80247b6:	4618      	mov	r0, r3
 80247b8:	3720      	adds	r7, #32
 80247ba:	46bd      	mov	sp, r7
 80247bc:	bd80      	pop	{r7, pc}
	...

080247c0 <XMC_CAN_MO_Config>:
  can_mo->can_id_mask = can_id_mask;
}

/* Initialization of XMC_CAN MO Object */
void XMC_CAN_MO_Config(const XMC_CAN_MO_t *const can_mo)
{
 80247c0:	b580      	push	{r7, lr}
 80247c2:	b086      	sub	sp, #24
 80247c4:	af00      	add	r7, sp, #0
 80247c6:	6078      	str	r0, [r7, #4]
  uint32_t reg;

  /* Configure MPN */
  uint32_t num = ((uint32_t)(can_mo->can_mo_ptr) - CAN_BASE - 0x1000U) / 0x0020U;
 80247c8:	687b      	ldr	r3, [r7, #4]
 80247ca:	681b      	ldr	r3, [r3, #0]
 80247cc:	f103 4338 	add.w	r3, r3, #3087007744	; 0xb8000000
 80247d0:	f5a3 33a8 	sub.w	r3, r3, #86016	; 0x15000
 80247d4:	095b      	lsrs	r3, r3, #5
 80247d6:	617b      	str	r3, [r7, #20]
  uint32_t set = (((uint32_t)(num / 32) << (CAN_MO_MOIPR_MPN_Pos + 5U)) | ((uint32_t)(num % 32) << CAN_MO_MOIPR_MPN_Pos));
 80247d8:	697b      	ldr	r3, [r7, #20]
 80247da:	095b      	lsrs	r3, r3, #5
 80247dc:	035a      	lsls	r2, r3, #13
 80247de:	697b      	ldr	r3, [r7, #20]
 80247e0:	021b      	lsls	r3, r3, #8
 80247e2:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
 80247e6:	4313      	orrs	r3, r2
 80247e8:	613b      	str	r3, [r7, #16]
  can_mo->can_mo_ptr->MOIPR &= ~(CAN_MO_MOIPR_MPN_Msk);
 80247ea:	687b      	ldr	r3, [r7, #4]
 80247ec:	681b      	ldr	r3, [r3, #0]
 80247ee:	689a      	ldr	r2, [r3, #8]
 80247f0:	687b      	ldr	r3, [r7, #4]
 80247f2:	681b      	ldr	r3, [r3, #0]
 80247f4:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 80247f8:	609a      	str	r2, [r3, #8]
  can_mo->can_mo_ptr->MOIPR |= set;
 80247fa:	687b      	ldr	r3, [r7, #4]
 80247fc:	681b      	ldr	r3, [r3, #0]
 80247fe:	6899      	ldr	r1, [r3, #8]
 8024800:	687b      	ldr	r3, [r7, #4]
 8024802:	681b      	ldr	r3, [r3, #0]
 8024804:	693a      	ldr	r2, [r7, #16]
 8024806:	430a      	orrs	r2, r1
 8024808:	609a      	str	r2, [r3, #8]

  if (((can_mo->can_id_mode != (uint32_t) XMC_CAN_FRAME_TYPE_STANDARD_11BITS) &&
 802480a:	687b      	ldr	r3, [r7, #4]
 802480c:	79db      	ldrb	r3, [r3, #7]
 802480e:	f003 0320 	and.w	r3, r3, #32
 8024812:	b2db      	uxtb	r3, r3
 8024814:	2b00      	cmp	r3, #0
 8024816:	d006      	beq.n	8024826 <XMC_CAN_MO_Config+0x66>
       (can_mo->can_id_mode != (uint32_t) XMC_CAN_FRAME_TYPE_EXTENDED_29BITS)) ||
 8024818:	687b      	ldr	r3, [r7, #4]
 802481a:	79db      	ldrb	r3, [r3, #7]
 802481c:	f003 0320 	and.w	r3, r3, #32
 8024820:	b2db      	uxtb	r3, r3
  if (((can_mo->can_id_mode != (uint32_t) XMC_CAN_FRAME_TYPE_STANDARD_11BITS) &&
 8024822:	2b00      	cmp	r3, #0
 8024824:	d060      	beq.n	80248e8 <XMC_CAN_MO_Config+0x128>
      ((can_mo->can_mo_type != XMC_CAN_MO_TYPE_RECMSGOBJ) &&
 8024826:	687b      	ldr	r3, [r7, #4]
 8024828:	7e1b      	ldrb	r3, [r3, #24]
       (can_mo->can_id_mode != (uint32_t) XMC_CAN_FRAME_TYPE_EXTENDED_29BITS)) ||
 802482a:	2b00      	cmp	r3, #0
 802482c:	d003      	beq.n	8024836 <XMC_CAN_MO_Config+0x76>
       (can_mo->can_mo_type != XMC_CAN_MO_TYPE_TRANSMSGOBJ)))
 802482e:	687b      	ldr	r3, [r7, #4]
 8024830:	7e1b      	ldrb	r3, [r3, #24]
      ((can_mo->can_mo_type != XMC_CAN_MO_TYPE_RECMSGOBJ) &&
 8024832:	2b01      	cmp	r3, #1
 8024834:	d158      	bne.n	80248e8 <XMC_CAN_MO_Config+0x128>
  }
  else
  {

    /* Disable Message object */
    can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_RESMSGVAL_Msk;
 8024836:	687b      	ldr	r3, [r7, #4]
 8024838:	681b      	ldr	r3, [r3, #0]
 802483a:	2220      	movs	r2, #32
 802483c:	61da      	str	r2, [r3, #28]
    if (can_mo->can_id_mode == (uint32_t)XMC_CAN_FRAME_TYPE_STANDARD_11BITS)
 802483e:	687b      	ldr	r3, [r7, #4]
 8024840:	79db      	ldrb	r3, [r3, #7]
 8024842:	f003 0320 	and.w	r3, r3, #32
 8024846:	b2db      	uxtb	r3, r3
 8024848:	2b00      	cmp	r3, #0
 802484a:	d128      	bne.n	802489e <XMC_CAN_MO_Config+0xde>
    {
      reg = can_mo->mo_ar;
 802484c:	687b      	ldr	r3, [r7, #4]
 802484e:	685b      	ldr	r3, [r3, #4]
 8024850:	60fb      	str	r3, [r7, #12]
      reg &= (uint32_t) ~(CAN_MO_MOAR_ID_Msk);
 8024852:	68fb      	ldr	r3, [r7, #12]
 8024854:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
 8024858:	60fb      	str	r3, [r7, #12]
      reg |= (can_mo->can_identifier << XMC_CAN_MO_MOAR_STDID_Pos);
 802485a:	687b      	ldr	r3, [r7, #4]
 802485c:	685b      	ldr	r3, [r3, #4]
 802485e:	f3c3 031c 	ubfx	r3, r3, #0, #29
 8024862:	049b      	lsls	r3, r3, #18
 8024864:	461a      	mov	r2, r3
 8024866:	68fb      	ldr	r3, [r7, #12]
 8024868:	4313      	orrs	r3, r2
 802486a:	60fb      	str	r3, [r7, #12]
      can_mo->can_mo_ptr->MOAR = reg;
 802486c:	687b      	ldr	r3, [r7, #4]
 802486e:	681b      	ldr	r3, [r3, #0]
 8024870:	68fa      	ldr	r2, [r7, #12]
 8024872:	619a      	str	r2, [r3, #24]

      reg = can_mo->mo_amr;
 8024874:	687b      	ldr	r3, [r7, #4]
 8024876:	689b      	ldr	r3, [r3, #8]
 8024878:	60fb      	str	r3, [r7, #12]
      reg &= (uint32_t) ~(CAN_MO_MOAMR_AM_Msk);
 802487a:	68fb      	ldr	r3, [r7, #12]
 802487c:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
 8024880:	60fb      	str	r3, [r7, #12]
      reg |= (can_mo->can_id_mask << XMC_CAN_MO_MOAR_STDID_Pos);
 8024882:	687b      	ldr	r3, [r7, #4]
 8024884:	689b      	ldr	r3, [r3, #8]
 8024886:	f3c3 031c 	ubfx	r3, r3, #0, #29
 802488a:	049b      	lsls	r3, r3, #18
 802488c:	461a      	mov	r2, r3
 802488e:	68fb      	ldr	r3, [r7, #12]
 8024890:	4313      	orrs	r3, r2
 8024892:	60fb      	str	r3, [r7, #12]
      can_mo->can_mo_ptr->MOAMR = reg;
 8024894:	687b      	ldr	r3, [r7, #4]
 8024896:	681b      	ldr	r3, [r3, #0]
 8024898:	68fa      	ldr	r2, [r7, #12]
 802489a:	60da      	str	r2, [r3, #12]
 802489c:	e009      	b.n	80248b2 <XMC_CAN_MO_Config+0xf2>
    }
    else
    {
      can_mo->can_mo_ptr->MOAR = can_mo->mo_ar;
 802489e:	687b      	ldr	r3, [r7, #4]
 80248a0:	681b      	ldr	r3, [r3, #0]
 80248a2:	687a      	ldr	r2, [r7, #4]
 80248a4:	6852      	ldr	r2, [r2, #4]
 80248a6:	619a      	str	r2, [r3, #24]
      can_mo->can_mo_ptr->MOAMR = can_mo->mo_amr;
 80248a8:	687b      	ldr	r3, [r7, #4]
 80248aa:	681b      	ldr	r3, [r3, #0]
 80248ac:	687a      	ldr	r2, [r7, #4]
 80248ae:	6892      	ldr	r2, [r2, #8]
 80248b0:	60da      	str	r2, [r3, #12]
    }
    /* Check whether message object is transmit message object */
    if (can_mo->can_mo_type == XMC_CAN_MO_TYPE_TRANSMSGOBJ)
 80248b2:	687b      	ldr	r3, [r7, #4]
 80248b4:	7e1b      	ldrb	r3, [r3, #24]
 80248b6:	2b01      	cmp	r3, #1
 80248b8:	d10c      	bne.n	80248d4 <XMC_CAN_MO_Config+0x114>
    {
      /* Set MO as Transmit message object  */
      XMC_CAN_MO_UpdateData(can_mo);
 80248ba:	6878      	ldr	r0, [r7, #4]
 80248bc:	f000 f81c 	bl	80248f8 <XMC_CAN_MO_UpdateData>
      can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_SETDIR_Msk;
 80248c0:	687b      	ldr	r3, [r7, #4]
 80248c2:	681b      	ldr	r3, [r3, #0]
 80248c4:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80248c8:	61da      	str	r2, [r3, #28]

      /* Reset RTSEL and Set MSGVAL, TXEN0 and TXEN1 bits */
      can_mo->can_mo_ptr->MOCTR = (CAN_MO_MOCTR_SETTXEN0_Msk | CAN_MO_MOCTR_SETTXEN1_Msk | CAN_MO_MOCTR_SETMSGVAL_Msk |
 80248ca:	687b      	ldr	r3, [r7, #4]
 80248cc:	681b      	ldr	r3, [r3, #0]
 80248ce:	4a08      	ldr	r2, [pc, #32]	; (80248f0 <XMC_CAN_MO_Config+0x130>)
 80248d0:	61da      	str	r2, [r3, #28]
      can_mo->can_mo_ptr->MOCTR = (CAN_MO_MOCTR_RESTXEN0_Msk | CAN_MO_MOCTR_RESTXEN1_Msk | CAN_MO_MOCTR_SETMSGVAL_Msk |
                                   CAN_MO_MOCTR_SETRXEN_Msk | CAN_MO_MOCTR_RESRTSEL_Msk);
    }

  }
}
 80248d2:	e009      	b.n	80248e8 <XMC_CAN_MO_Config+0x128>
      can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_RESDIR_Msk;
 80248d4:	687b      	ldr	r3, [r7, #4]
 80248d6:	681b      	ldr	r3, [r3, #0]
 80248d8:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80248dc:	61da      	str	r2, [r3, #28]
      can_mo->can_mo_ptr->MOCTR = (CAN_MO_MOCTR_RESTXEN0_Msk | CAN_MO_MOCTR_RESTXEN1_Msk | CAN_MO_MOCTR_SETMSGVAL_Msk |
 80248de:	687b      	ldr	r3, [r7, #4]
 80248e0:	681b      	ldr	r3, [r3, #0]
 80248e2:	4a04      	ldr	r2, [pc, #16]	; (80248f4 <XMC_CAN_MO_Config+0x134>)
 80248e4:	61da      	str	r2, [r3, #28]
}
 80248e6:	e7ff      	b.n	80248e8 <XMC_CAN_MO_Config+0x128>
 80248e8:	bf00      	nop
 80248ea:	3718      	adds	r7, #24
 80248ec:	46bd      	mov	sp, r7
 80248ee:	bd80      	pop	{r7, pc}
 80248f0:	062000c0 	.word	0x062000c0
 80248f4:	00a00640 	.word	0x00a00640

080248f8 <XMC_CAN_MO_UpdateData>:

/* Update of XMC_CAN Object */
XMC_CAN_STATUS_t XMC_CAN_MO_UpdateData(const XMC_CAN_MO_t *const can_mo)
{
 80248f8:	b480      	push	{r7}
 80248fa:	b085      	sub	sp, #20
 80248fc:	af00      	add	r7, sp, #0
 80248fe:	6078      	str	r0, [r7, #4]
  XMC_CAN_STATUS_t error = XMC_CAN_STATUS_MO_NOT_ACCEPTABLE;
 8024900:	2303      	movs	r3, #3
 8024902:	73fb      	strb	r3, [r7, #15]
  /* Check whether message object is transmit message object */
  if (can_mo->can_mo_type == XMC_CAN_MO_TYPE_TRANSMSGOBJ)
 8024904:	687b      	ldr	r3, [r7, #4]
 8024906:	7e1b      	ldrb	r3, [r3, #24]
 8024908:	2b01      	cmp	r3, #1
 802490a:	d122      	bne.n	8024952 <XMC_CAN_MO_UpdateData+0x5a>
  {
    can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_RESMSGVAL_Msk;
 802490c:	687b      	ldr	r3, [r7, #4]
 802490e:	681b      	ldr	r3, [r3, #0]
 8024910:	2220      	movs	r2, #32
 8024912:	61da      	str	r2, [r3, #28]
    /* Configure data length */
    can_mo->can_mo_ptr->MOFCR = ((can_mo->can_mo_ptr->MOFCR) & ~(uint32_t)(CAN_MO_MOFCR_DLC_Msk)) |
 8024914:	687b      	ldr	r3, [r7, #4]
 8024916:	681b      	ldr	r3, [r3, #0]
 8024918:	681b      	ldr	r3, [r3, #0]
 802491a:	f023 6170 	bic.w	r1, r3, #251658240	; 0xf000000
                                (((uint32_t) can_mo->can_data_length << CAN_MO_MOFCR_DLC_Pos) & (uint32_t)CAN_MO_MOFCR_DLC_Msk);
 802491e:	687b      	ldr	r3, [r7, #4]
 8024920:	7b1b      	ldrb	r3, [r3, #12]
 8024922:	061b      	lsls	r3, r3, #24
 8024924:	f003 6270 	and.w	r2, r3, #251658240	; 0xf000000
    can_mo->can_mo_ptr->MOFCR = ((can_mo->can_mo_ptr->MOFCR) & ~(uint32_t)(CAN_MO_MOFCR_DLC_Msk)) |
 8024928:	687b      	ldr	r3, [r7, #4]
 802492a:	681b      	ldr	r3, [r3, #0]
 802492c:	430a      	orrs	r2, r1
 802492e:	601a      	str	r2, [r3, #0]
    /* Configure Data registers*/
    can_mo->can_mo_ptr->MODATAL = can_mo->can_data[0];
 8024930:	687b      	ldr	r3, [r7, #4]
 8024932:	681b      	ldr	r3, [r3, #0]
 8024934:	687a      	ldr	r2, [r7, #4]
 8024936:	6912      	ldr	r2, [r2, #16]
 8024938:	611a      	str	r2, [r3, #16]
    can_mo->can_mo_ptr->MODATAH = can_mo->can_data[1];
 802493a:	687b      	ldr	r3, [r7, #4]
 802493c:	681b      	ldr	r3, [r3, #0]
 802493e:	687a      	ldr	r2, [r7, #4]
 8024940:	6952      	ldr	r2, [r2, #20]
 8024942:	615a      	str	r2, [r3, #20]
    /* Reset RTSEL and Set MSGVAL ,TXEN0 and TXEN1 bits */
    can_mo->can_mo_ptr->MOCTR = (CAN_MO_MOCTR_SETNEWDAT_Msk | CAN_MO_MOCTR_SETMSGVAL_Msk | CAN_MO_MOCTR_RESRTSEL_Msk);
 8024944:	687b      	ldr	r3, [r7, #4]
 8024946:	681b      	ldr	r3, [r3, #0]
 8024948:	4a06      	ldr	r2, [pc, #24]	; (8024964 <XMC_CAN_MO_UpdateData+0x6c>)
 802494a:	61da      	str	r2, [r3, #28]
    error = XMC_CAN_STATUS_SUCCESS;
 802494c:	2300      	movs	r3, #0
 802494e:	73fb      	strb	r3, [r7, #15]
 8024950:	e001      	b.n	8024956 <XMC_CAN_MO_UpdateData+0x5e>
  }
  else
  {
    error = XMC_CAN_STATUS_MO_NOT_ACCEPTABLE;
 8024952:	2303      	movs	r3, #3
 8024954:	73fb      	strb	r3, [r7, #15]
  }
  return error;
 8024956:	7bfb      	ldrb	r3, [r7, #15]
}
 8024958:	4618      	mov	r0, r3
 802495a:	3714      	adds	r7, #20
 802495c:	46bd      	mov	sp, r7
 802495e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024962:	4770      	bx	lr
 8024964:	00280040 	.word	0x00280040

08024968 <XMC_CAN_MO_Receive>:
}


/* This function is will read the message object data bytes */
XMC_CAN_STATUS_t XMC_CAN_MO_Receive (XMC_CAN_MO_t *can_mo)
{
 8024968:	b480      	push	{r7}
 802496a:	b087      	sub	sp, #28
 802496c:	af00      	add	r7, sp, #0
 802496e:	6078      	str	r0, [r7, #4]
  XMC_CAN_STATUS_t error = XMC_CAN_STATUS_ERROR;
 8024970:	2301      	movs	r3, #1
 8024972:	75fb      	strb	r3, [r7, #23]
  uint8_t rx_pnd = 0U;
 8024974:	2300      	movs	r3, #0
 8024976:	75bb      	strb	r3, [r7, #22]
  uint8_t new_data = 0U;
 8024978:	2300      	movs	r3, #0
 802497a:	757b      	strb	r3, [r7, #21]
  uint32_t mo_type = (uint32_t)((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_DIR_Msk) >> CAN_MO_MOSTAT_DIR_Pos;
 802497c:	687b      	ldr	r3, [r7, #4]
 802497e:	681b      	ldr	r3, [r3, #0]
 8024980:	69db      	ldr	r3, [r3, #28]
 8024982:	0adb      	lsrs	r3, r3, #11
 8024984:	f003 0301 	and.w	r3, r3, #1
 8024988:	613b      	str	r3, [r7, #16]
  uint32_t mo_recepcion_ongoing = (uint32_t)((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_RXUPD_Msk) >> CAN_MO_MOSTAT_RXUPD_Pos;
 802498a:	687b      	ldr	r3, [r7, #4]
 802498c:	681b      	ldr	r3, [r3, #0]
 802498e:	69db      	ldr	r3, [r3, #28]
 8024990:	089b      	lsrs	r3, r3, #2
 8024992:	f003 0301 	and.w	r3, r3, #1
 8024996:	60fb      	str	r3, [r7, #12]
  /* check if message object is a receive message object */
  if (mo_type != (uint32_t)XMC_CAN_MO_TYPE_RECMSGOBJ)
 8024998:	693b      	ldr	r3, [r7, #16]
 802499a:	2b00      	cmp	r3, #0
 802499c:	d002      	beq.n	80249a4 <XMC_CAN_MO_Receive+0x3c>
  {
    error = XMC_CAN_STATUS_MO_NOT_ACCEPTABLE;
 802499e:	2303      	movs	r3, #3
 80249a0:	75fb      	strb	r3, [r7, #23]
 80249a2:	e0a3      	b.n	8024aec <XMC_CAN_MO_Receive+0x184>
  }
  /* check if reception is ongoing on message object */
  else if (mo_recepcion_ongoing == 1U)
 80249a4:	68fb      	ldr	r3, [r7, #12]
 80249a6:	2b01      	cmp	r3, #1
 80249a8:	d102      	bne.n	80249b0 <XMC_CAN_MO_Receive+0x48>
  {
    error = XMC_CAN_STATUS_BUSY;
 80249aa:	2302      	movs	r3, #2
 80249ac:	75fb      	strb	r3, [r7, #23]
 80249ae:	e09d      	b.n	8024aec <XMC_CAN_MO_Receive+0x184>
  else
  {
    /* read message parameters */
    do
    {
      can_mo->can_mo_ptr->MOCTR = CAN_MO_MOCTR_RESNEWDAT_Msk;
 80249b0:	687b      	ldr	r3, [r7, #4]
 80249b2:	681b      	ldr	r3, [r3, #0]
 80249b4:	2208      	movs	r2, #8
 80249b6:	61da      	str	r2, [r3, #28]
      if ((((can_mo->can_mo_ptr->MOAR) & CAN_MO_MOAR_IDE_Msk) >> CAN_MO_MOAR_IDE_Pos) == 0U)
 80249b8:	687b      	ldr	r3, [r7, #4]
 80249ba:	681b      	ldr	r3, [r3, #0]
 80249bc:	699b      	ldr	r3, [r3, #24]
 80249be:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 80249c2:	2b00      	cmp	r3, #0
 80249c4:	d13d      	bne.n	8024a42 <XMC_CAN_MO_Receive+0xda>
      {
        can_mo->can_id_mode = (uint32_t)XMC_CAN_FRAME_TYPE_STANDARD_11BITS;
 80249c6:	687a      	ldr	r2, [r7, #4]
 80249c8:	79d3      	ldrb	r3, [r2, #7]
 80249ca:	f36f 1345 	bfc	r3, #5, #1
 80249ce:	71d3      	strb	r3, [r2, #7]
        can_mo->can_identifier = (can_mo->can_mo_ptr->MOAR & XMC_CAN_MO_MOAR_STDID_Msk) >> XMC_CAN_MO_MOAR_STDID_Pos;
 80249d0:	687b      	ldr	r3, [r7, #4]
 80249d2:	681b      	ldr	r3, [r3, #0]
 80249d4:	699b      	ldr	r3, [r3, #24]
 80249d6:	0c9b      	lsrs	r3, r3, #18
 80249d8:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 80249dc:	f3c3 010a 	ubfx	r1, r3, #0, #11
 80249e0:	687a      	ldr	r2, [r7, #4]
 80249e2:	6853      	ldr	r3, [r2, #4]
 80249e4:	f361 031c 	bfi	r3, r1, #0, #29
 80249e8:	6053      	str	r3, [r2, #4]
        can_mo->can_ide_mask = (uint32_t)(can_mo->can_mo_ptr->MOAMR & CAN_MO_MOAMR_MIDE_Msk) >> CAN_MO_MOAMR_MIDE_Pos;
 80249ea:	687b      	ldr	r3, [r7, #4]
 80249ec:	681b      	ldr	r3, [r3, #0]
 80249ee:	68db      	ldr	r3, [r3, #12]
 80249f0:	0f5b      	lsrs	r3, r3, #29
 80249f2:	f003 0301 	and.w	r3, r3, #1
 80249f6:	b2d9      	uxtb	r1, r3
 80249f8:	687a      	ldr	r2, [r7, #4]
 80249fa:	7ad3      	ldrb	r3, [r2, #11]
 80249fc:	f361 1345 	bfi	r3, r1, #5, #1
 8024a00:	72d3      	strb	r3, [r2, #11]
        if (can_mo->can_ide_mask == 1U)
 8024a02:	687b      	ldr	r3, [r7, #4]
 8024a04:	7adb      	ldrb	r3, [r3, #11]
 8024a06:	f003 0320 	and.w	r3, r3, #32
 8024a0a:	b2db      	uxtb	r3, r3
 8024a0c:	2b00      	cmp	r3, #0
 8024a0e:	d00d      	beq.n	8024a2c <XMC_CAN_MO_Receive+0xc4>
        {
          can_mo->can_id_mask = (uint32_t)(can_mo->can_mo_ptr->MOAMR & XMC_CAN_MO_MOAR_STDID_Msk) >> XMC_CAN_MO_MOAR_STDID_Pos;
 8024a10:	687b      	ldr	r3, [r7, #4]
 8024a12:	681b      	ldr	r3, [r3, #0]
 8024a14:	68db      	ldr	r3, [r3, #12]
 8024a16:	0c9b      	lsrs	r3, r3, #18
 8024a18:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 8024a1c:	f3c3 010a 	ubfx	r1, r3, #0, #11
 8024a20:	687a      	ldr	r2, [r7, #4]
 8024a22:	6893      	ldr	r3, [r2, #8]
 8024a24:	f361 031c 	bfi	r3, r1, #0, #29
 8024a28:	6093      	str	r3, [r2, #8]
 8024a2a:	e02f      	b.n	8024a8c <XMC_CAN_MO_Receive+0x124>
        }
        else
        {
          can_mo->can_id_mask = (uint32_t)(can_mo->can_mo_ptr->MOAMR & CAN_MO_MOAMR_AM_Msk);
 8024a2c:	687b      	ldr	r3, [r7, #4]
 8024a2e:	681b      	ldr	r3, [r3, #0]
 8024a30:	68db      	ldr	r3, [r3, #12]
 8024a32:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 8024a36:	687a      	ldr	r2, [r7, #4]
 8024a38:	6893      	ldr	r3, [r2, #8]
 8024a3a:	f361 031c 	bfi	r3, r1, #0, #29
 8024a3e:	6093      	str	r3, [r2, #8]
 8024a40:	e024      	b.n	8024a8c <XMC_CAN_MO_Receive+0x124>
        }
      }
      else
      {
        can_mo->can_id_mode = (uint32_t)XMC_CAN_FRAME_TYPE_EXTENDED_29BITS;
 8024a42:	687a      	ldr	r2, [r7, #4]
 8024a44:	79d3      	ldrb	r3, [r2, #7]
 8024a46:	f043 0320 	orr.w	r3, r3, #32
 8024a4a:	71d3      	strb	r3, [r2, #7]
        can_mo->can_identifier = (can_mo->can_mo_ptr->MOAR & CAN_MO_MOAR_ID_Msk);
 8024a4c:	687b      	ldr	r3, [r7, #4]
 8024a4e:	681b      	ldr	r3, [r3, #0]
 8024a50:	699b      	ldr	r3, [r3, #24]
 8024a52:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 8024a56:	687a      	ldr	r2, [r7, #4]
 8024a58:	6853      	ldr	r3, [r2, #4]
 8024a5a:	f361 031c 	bfi	r3, r1, #0, #29
 8024a5e:	6053      	str	r3, [r2, #4]
        can_mo->can_id_mask = (uint32_t)(can_mo->can_mo_ptr->MOAMR & CAN_MO_MOAMR_AM_Msk);
 8024a60:	687b      	ldr	r3, [r7, #4]
 8024a62:	681b      	ldr	r3, [r3, #0]
 8024a64:	68db      	ldr	r3, [r3, #12]
 8024a66:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 8024a6a:	687a      	ldr	r2, [r7, #4]
 8024a6c:	6893      	ldr	r3, [r2, #8]
 8024a6e:	f361 031c 	bfi	r3, r1, #0, #29
 8024a72:	6093      	str	r3, [r2, #8]
        can_mo->can_ide_mask = (uint32_t)(can_mo->can_mo_ptr->MOAMR & CAN_MO_MOAMR_MIDE_Msk) >> CAN_MO_MOAMR_MIDE_Pos;
 8024a74:	687b      	ldr	r3, [r7, #4]
 8024a76:	681b      	ldr	r3, [r3, #0]
 8024a78:	68db      	ldr	r3, [r3, #12]
 8024a7a:	0f5b      	lsrs	r3, r3, #29
 8024a7c:	f003 0301 	and.w	r3, r3, #1
 8024a80:	b2d9      	uxtb	r1, r3
 8024a82:	687a      	ldr	r2, [r7, #4]
 8024a84:	7ad3      	ldrb	r3, [r2, #11]
 8024a86:	f361 1345 	bfi	r3, r1, #5, #1
 8024a8a:	72d3      	strb	r3, [r2, #11]
      }
      can_mo->can_data_length = (uint8_t)((uint32_t)((can_mo->can_mo_ptr->MOFCR) & CAN_MO_MOFCR_DLC_Msk) >> CAN_MO_MOFCR_DLC_Pos);
 8024a8c:	687b      	ldr	r3, [r7, #4]
 8024a8e:	681b      	ldr	r3, [r3, #0]
 8024a90:	681b      	ldr	r3, [r3, #0]
 8024a92:	0e1b      	lsrs	r3, r3, #24
 8024a94:	b2db      	uxtb	r3, r3
 8024a96:	f003 030f 	and.w	r3, r3, #15
 8024a9a:	b2da      	uxtb	r2, r3
 8024a9c:	687b      	ldr	r3, [r7, #4]
 8024a9e:	731a      	strb	r2, [r3, #12]

      can_mo->can_data[0] = can_mo->can_mo_ptr->MODATAL;
 8024aa0:	687b      	ldr	r3, [r7, #4]
 8024aa2:	681b      	ldr	r3, [r3, #0]
 8024aa4:	691a      	ldr	r2, [r3, #16]
 8024aa6:	687b      	ldr	r3, [r7, #4]
 8024aa8:	611a      	str	r2, [r3, #16]
      can_mo->can_data[1] = can_mo->can_mo_ptr->MODATAH;
 8024aaa:	687b      	ldr	r3, [r7, #4]
 8024aac:	681b      	ldr	r3, [r3, #0]
 8024aae:	695a      	ldr	r2, [r3, #20]
 8024ab0:	687b      	ldr	r3, [r7, #4]
 8024ab2:	615a      	str	r2, [r3, #20]

      rx_pnd = (uint8_t)((uint32_t)((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_RXUPD_Msk) >> CAN_MO_MOSTAT_RXUPD_Pos);
 8024ab4:	687b      	ldr	r3, [r7, #4]
 8024ab6:	681b      	ldr	r3, [r3, #0]
 8024ab8:	69db      	ldr	r3, [r3, #28]
 8024aba:	089b      	lsrs	r3, r3, #2
 8024abc:	b2db      	uxtb	r3, r3
 8024abe:	f003 0301 	and.w	r3, r3, #1
 8024ac2:	75bb      	strb	r3, [r7, #22]
      new_data = (uint8_t)((uint32_t)((can_mo->can_mo_ptr->MOSTAT) & CAN_MO_MOSTAT_NEWDAT_Msk) >> CAN_MO_MOSTAT_NEWDAT_Pos);
 8024ac4:	687b      	ldr	r3, [r7, #4]
 8024ac6:	681b      	ldr	r3, [r3, #0]
 8024ac8:	69db      	ldr	r3, [r3, #28]
 8024aca:	08db      	lsrs	r3, r3, #3
 8024acc:	b2db      	uxtb	r3, r3
 8024ace:	f003 0301 	and.w	r3, r3, #1
 8024ad2:	757b      	strb	r3, [r7, #21]
    }
    while ((rx_pnd != 0U) && (new_data != 0U));
 8024ad4:	7dbb      	ldrb	r3, [r7, #22]
 8024ad6:	2b00      	cmp	r3, #0
 8024ad8:	d003      	beq.n	8024ae2 <XMC_CAN_MO_Receive+0x17a>
 8024ada:	7d7b      	ldrb	r3, [r7, #21]
 8024adc:	2b00      	cmp	r3, #0
 8024ade:	f47f af67 	bne.w	80249b0 <XMC_CAN_MO_Receive+0x48>

    can_mo->can_mo_type = XMC_CAN_MO_TYPE_RECMSGOBJ;
 8024ae2:	687b      	ldr	r3, [r7, #4]
 8024ae4:	2200      	movs	r2, #0
 8024ae6:	761a      	strb	r2, [r3, #24]
    error = XMC_CAN_STATUS_SUCCESS;
 8024ae8:	2300      	movs	r3, #0
 8024aea:	75fb      	strb	r3, [r7, #23]
  }
  return error;
 8024aec:	7dfb      	ldrb	r3, [r7, #23]
}
 8024aee:	4618      	mov	r0, r3
 8024af0:	371c      	adds	r7, #28
 8024af2:	46bd      	mov	sp, r7
 8024af4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024af8:	4770      	bx	lr

08024afa <XMC_CAN_NODE_EnableEvent>:

/* Function to enable node event */
void XMC_CAN_NODE_EnableEvent(XMC_CAN_NODE_t *const can_node, const XMC_CAN_NODE_EVENT_t event)
{
 8024afa:	b480      	push	{r7}
 8024afc:	b083      	sub	sp, #12
 8024afe:	af00      	add	r7, sp, #0
 8024b00:	6078      	str	r0, [r7, #4]
 8024b02:	6039      	str	r1, [r7, #0]
  if (event != XMC_CAN_NODE_EVENT_CFCIE)
 8024b04:	683b      	ldr	r3, [r7, #0]
 8024b06:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 8024b0a:	d006      	beq.n	8024b1a <XMC_CAN_NODE_EnableEvent+0x20>
  {
    can_node->NCR |= (uint32_t)event;
 8024b0c:	687b      	ldr	r3, [r7, #4]
 8024b0e:	681a      	ldr	r2, [r3, #0]
 8024b10:	683b      	ldr	r3, [r7, #0]
 8024b12:	431a      	orrs	r2, r3
 8024b14:	687b      	ldr	r3, [r7, #4]
 8024b16:	601a      	str	r2, [r3, #0]
  }
  else
  {
    can_node->NFCR |= (uint32_t)event;
  }
}
 8024b18:	e005      	b.n	8024b26 <XMC_CAN_NODE_EnableEvent+0x2c>
    can_node->NFCR |= (uint32_t)event;
 8024b1a:	687b      	ldr	r3, [r7, #4]
 8024b1c:	699a      	ldr	r2, [r3, #24]
 8024b1e:	683b      	ldr	r3, [r7, #0]
 8024b20:	431a      	orrs	r2, r3
 8024b22:	687b      	ldr	r3, [r7, #4]
 8024b24:	619a      	str	r2, [r3, #24]
}
 8024b26:	bf00      	nop
 8024b28:	370c      	adds	r7, #12
 8024b2a:	46bd      	mov	sp, r7
 8024b2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024b30:	4770      	bx	lr

08024b32 <XMC_CCU4_StartPrescaler>:
{
 8024b32:	b480      	push	{r7}
 8024b34:	b083      	sub	sp, #12
 8024b36:	af00      	add	r7, sp, #0
 8024b38:	6078      	str	r0, [r7, #4]
  module->GIDLC = (uint32_t) CCU4_GIDLC_SPRB_Msk;
 8024b3a:	687b      	ldr	r3, [r7, #4]
 8024b3c:	f44f 7280 	mov.w	r2, #256	; 0x100
 8024b40:	60da      	str	r2, [r3, #12]
}
 8024b42:	bf00      	nop
 8024b44:	370c      	adds	r7, #12
 8024b46:	46bd      	mov	sp, r7
 8024b48:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024b4c:	4770      	bx	lr
	...

08024b50 <XMC_CCU4_lDeassertReset>:
    XMC_ASSERT("XMC_CCU4_lAssertReset:Invalid Module Pointer", 0);
  }
}

__STATIC_INLINE void XMC_CCU4_lDeassertReset(const XMC_CCU4_MODULE_t *const module)
{
 8024b50:	b580      	push	{r7, lr}
 8024b52:	b082      	sub	sp, #8
 8024b54:	af00      	add	r7, sp, #0
 8024b56:	6078      	str	r0, [r7, #4]
  if (module == CCU40)
 8024b58:	687b      	ldr	r3, [r7, #4]
 8024b5a:	4a11      	ldr	r2, [pc, #68]	; (8024ba0 <XMC_CCU4_lDeassertReset+0x50>)
 8024b5c:	4293      	cmp	r3, r2
 8024b5e:	d103      	bne.n	8024b68 <XMC_CCU4_lDeassertReset+0x18>
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU40);
 8024b60:	2004      	movs	r0, #4
 8024b62:	f7ff f885 	bl	8023c70 <XMC_SCU_RESET_DeassertPeripheralReset>
#endif
  else
  {
    XMC_ASSERT("XMC_CCU4_lDeassertReset:Invalid Module Pointer", 0);
  }
}
 8024b66:	e016      	b.n	8024b96 <XMC_CCU4_lDeassertReset+0x46>
  else if (module == CCU41)
 8024b68:	687b      	ldr	r3, [r7, #4]
 8024b6a:	4a0e      	ldr	r2, [pc, #56]	; (8024ba4 <XMC_CCU4_lDeassertReset+0x54>)
 8024b6c:	4293      	cmp	r3, r2
 8024b6e:	d103      	bne.n	8024b78 <XMC_CCU4_lDeassertReset+0x28>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU41);
 8024b70:	2008      	movs	r0, #8
 8024b72:	f7ff f87d 	bl	8023c70 <XMC_SCU_RESET_DeassertPeripheralReset>
}
 8024b76:	e00e      	b.n	8024b96 <XMC_CCU4_lDeassertReset+0x46>
  else if (module == CCU42)
 8024b78:	687b      	ldr	r3, [r7, #4]
 8024b7a:	4a0b      	ldr	r2, [pc, #44]	; (8024ba8 <XMC_CCU4_lDeassertReset+0x58>)
 8024b7c:	4293      	cmp	r3, r2
 8024b7e:	d103      	bne.n	8024b88 <XMC_CCU4_lDeassertReset+0x38>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU42);
 8024b80:	2010      	movs	r0, #16
 8024b82:	f7ff f875 	bl	8023c70 <XMC_SCU_RESET_DeassertPeripheralReset>
}
 8024b86:	e006      	b.n	8024b96 <XMC_CCU4_lDeassertReset+0x46>
  else if (module == CCU43)
 8024b88:	687b      	ldr	r3, [r7, #4]
 8024b8a:	4a08      	ldr	r2, [pc, #32]	; (8024bac <XMC_CCU4_lDeassertReset+0x5c>)
 8024b8c:	4293      	cmp	r3, r2
 8024b8e:	d102      	bne.n	8024b96 <XMC_CCU4_lDeassertReset+0x46>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU43);
 8024b90:	4807      	ldr	r0, [pc, #28]	; (8024bb0 <XMC_CCU4_lDeassertReset+0x60>)
 8024b92:	f7ff f86d 	bl	8023c70 <XMC_SCU_RESET_DeassertPeripheralReset>
}
 8024b96:	bf00      	nop
 8024b98:	3708      	adds	r7, #8
 8024b9a:	46bd      	mov	sp, r7
 8024b9c:	bd80      	pop	{r7, pc}
 8024b9e:	bf00      	nop
 8024ba0:	4000c000 	.word	0x4000c000
 8024ba4:	40010000 	.word	0x40010000
 8024ba8:	40014000 	.word	0x40014000
 8024bac:	48004000 	.word	0x48004000
 8024bb0:	10000001 	.word	0x10000001

08024bb4 <XMC_CCU4_lUngateClock>:
    XMC_ASSERT("XMC_CCU4_lGateClock:Invalid Module Pointer", 0);
  }
}

__STATIC_INLINE void XMC_CCU4_lUngateClock(const XMC_CCU4_MODULE_t *const module)
{
 8024bb4:	b580      	push	{r7, lr}
 8024bb6:	b082      	sub	sp, #8
 8024bb8:	af00      	add	r7, sp, #0
 8024bba:	6078      	str	r0, [r7, #4]
  if (module == CCU40)
 8024bbc:	687b      	ldr	r3, [r7, #4]
 8024bbe:	4a11      	ldr	r2, [pc, #68]	; (8024c04 <XMC_CCU4_lUngateClock+0x50>)
 8024bc0:	4293      	cmp	r3, r2
 8024bc2:	d103      	bne.n	8024bcc <XMC_CCU4_lUngateClock+0x18>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU40);
 8024bc4:	2004      	movs	r0, #4
 8024bc6:	f7ff f9a9 	bl	8023f1c <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
  else
  {
    XMC_ASSERT("XMC_CCU4_lUngateClock:Invalid Module Pointer", 0);
  }
}
 8024bca:	e016      	b.n	8024bfa <XMC_CCU4_lUngateClock+0x46>
  else if (module == CCU41)
 8024bcc:	687b      	ldr	r3, [r7, #4]
 8024bce:	4a0e      	ldr	r2, [pc, #56]	; (8024c08 <XMC_CCU4_lUngateClock+0x54>)
 8024bd0:	4293      	cmp	r3, r2
 8024bd2:	d103      	bne.n	8024bdc <XMC_CCU4_lUngateClock+0x28>
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU41);
 8024bd4:	2008      	movs	r0, #8
 8024bd6:	f7ff f9a1 	bl	8023f1c <XMC_SCU_CLOCK_UngatePeripheralClock>
}
 8024bda:	e00e      	b.n	8024bfa <XMC_CCU4_lUngateClock+0x46>
  else if (module == CCU42)
 8024bdc:	687b      	ldr	r3, [r7, #4]
 8024bde:	4a0b      	ldr	r2, [pc, #44]	; (8024c0c <XMC_CCU4_lUngateClock+0x58>)
 8024be0:	4293      	cmp	r3, r2
 8024be2:	d103      	bne.n	8024bec <XMC_CCU4_lUngateClock+0x38>
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU42);
 8024be4:	2010      	movs	r0, #16
 8024be6:	f7ff f999 	bl	8023f1c <XMC_SCU_CLOCK_UngatePeripheralClock>
}
 8024bea:	e006      	b.n	8024bfa <XMC_CCU4_lUngateClock+0x46>
  else if (module == CCU43)
 8024bec:	687b      	ldr	r3, [r7, #4]
 8024bee:	4a08      	ldr	r2, [pc, #32]	; (8024c10 <XMC_CCU4_lUngateClock+0x5c>)
 8024bf0:	4293      	cmp	r3, r2
 8024bf2:	d102      	bne.n	8024bfa <XMC_CCU4_lUngateClock+0x46>
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU43);
 8024bf4:	4807      	ldr	r0, [pc, #28]	; (8024c14 <XMC_CCU4_lUngateClock+0x60>)
 8024bf6:	f7ff f991 	bl	8023f1c <XMC_SCU_CLOCK_UngatePeripheralClock>
}
 8024bfa:	bf00      	nop
 8024bfc:	3708      	adds	r7, #8
 8024bfe:	46bd      	mov	sp, r7
 8024c00:	bd80      	pop	{r7, pc}
 8024c02:	bf00      	nop
 8024c04:	4000c000 	.word	0x4000c000
 8024c08:	40010000 	.word	0x40010000
 8024c0c:	40014000 	.word	0x40014000
 8024c10:	48004000 	.word	0x48004000
 8024c14:	10000001 	.word	0x10000001

08024c18 <XMC_CCU4_EnableModule>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 ********************************************************************************************************************/

void XMC_CCU4_EnableModule(XMC_CCU4_MODULE_t *const module)
{
 8024c18:	b580      	push	{r7, lr}
 8024c1a:	b082      	sub	sp, #8
 8024c1c:	af00      	add	r7, sp, #0
 8024c1e:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_EnableModule:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));

#if UC_FAMILY == XMC4
  /* Enable CCU4 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 8024c20:	2010      	movs	r0, #16
 8024c22:	f7ff f96b 	bl	8023efc <XMC_SCU_CLOCK_EnableClock>
#endif

#if defined(CLOCK_GATING_SUPPORTED)
  XMC_CCU4_lUngateClock(module);
 8024c26:	6878      	ldr	r0, [r7, #4]
 8024c28:	f7ff ffc4 	bl	8024bb4 <XMC_CCU4_lUngateClock>
#endif

#if defined(PERIPHERAL_RESET_SUPPORTED)
  XMC_CCU4_lDeassertReset(module);
 8024c2c:	6878      	ldr	r0, [r7, #4]
 8024c2e:	f7ff ff8f 	bl	8024b50 <XMC_CCU4_lDeassertReset>
#endif
}
 8024c32:	bf00      	nop
 8024c34:	3708      	adds	r7, #8
 8024c36:	46bd      	mov	sp, r7
 8024c38:	bd80      	pop	{r7, pc}

08024c3a <XMC_CCU4_Init>:
#endif
}

/* API to initialize CCU4 global resources  */
void XMC_CCU4_Init(XMC_CCU4_MODULE_t *const module, const XMC_CCU4_SLICE_MCMS_ACTION_t mcs_action)
{
 8024c3a:	b580      	push	{r7, lr}
 8024c3c:	b084      	sub	sp, #16
 8024c3e:	af00      	add	r7, sp, #0
 8024c40:	6078      	str	r0, [r7, #4]
 8024c42:	460b      	mov	r3, r1
 8024c44:	70fb      	strb	r3, [r7, #3]

  XMC_ASSERT("XMC_CCU4_Init:Invalid module pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_Init:Invalid mcs action", XMC_CCU4_SLICE_CHECK_MCS_ACTION(mcs_action));

  /* Enable CCU4 module */
  XMC_CCU4_EnableModule(module);
 8024c46:	6878      	ldr	r0, [r7, #4]
 8024c48:	f7ff ffe6 	bl	8024c18 <XMC_CCU4_EnableModule>
  /* Start the prescaler */
  XMC_CCU4_StartPrescaler(module);
 8024c4c:	6878      	ldr	r0, [r7, #4]
 8024c4e:	f7ff ff70 	bl	8024b32 <XMC_CCU4_StartPrescaler>

  gctrl = module->GCTRL;
 8024c52:	687b      	ldr	r3, [r7, #4]
 8024c54:	681b      	ldr	r3, [r3, #0]
 8024c56:	60fb      	str	r3, [r7, #12]
  gctrl &= ~((uint32_t) CCU4_GCTRL_MSDE_Msk);
 8024c58:	68fb      	ldr	r3, [r7, #12]
 8024c5a:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8024c5e:	60fb      	str	r3, [r7, #12]
  gctrl |= ((uint32_t) mcs_action) << CCU4_GCTRL_MSDE_Pos;
 8024c60:	78fb      	ldrb	r3, [r7, #3]
 8024c62:	039b      	lsls	r3, r3, #14
 8024c64:	68fa      	ldr	r2, [r7, #12]
 8024c66:	4313      	orrs	r3, r2
 8024c68:	60fb      	str	r3, [r7, #12]

  module->GCTRL = gctrl;
 8024c6a:	687b      	ldr	r3, [r7, #4]
 8024c6c:	68fa      	ldr	r2, [r7, #12]
 8024c6e:	601a      	str	r2, [r3, #0]
}
 8024c70:	bf00      	nop
 8024c72:	3710      	adds	r7, #16
 8024c74:	46bd      	mov	sp, r7
 8024c76:	bd80      	pop	{r7, pc}

08024c78 <XMC_CCU4_SetMultiChannelShadowTransferMode>:
  module->GCTRL = gctrl;
}

/* API to configure the multichannel shadow transfer request via SW and via the CCU4x.MCSS input. */
void XMC_CCU4_SetMultiChannelShadowTransferMode(XMC_CCU4_MODULE_t *const module, const uint32_t slice_mode_msk)
{
 8024c78:	b480      	push	{r7}
 8024c7a:	b085      	sub	sp, #20
 8024c7c:	af00      	add	r7, sp, #0
 8024c7e:	6078      	str	r0, [r7, #4]
 8024c80:	6039      	str	r1, [r7, #0]
  uint32_t gctrl;

  XMC_ASSERT("XMC_CCU4_SetMultiChannelShadowTransferMode:Invalid module Pointer", XMC_CCU4_IsValidModule(module));

  gctrl = module->GCTRL;
 8024c82:	687b      	ldr	r3, [r7, #4]
 8024c84:	681b      	ldr	r3, [r3, #0]
 8024c86:	60fb      	str	r3, [r7, #12]
  gctrl &= ~((uint32_t)slice_mode_msk >> 16U);
 8024c88:	683b      	ldr	r3, [r7, #0]
 8024c8a:	0c1b      	lsrs	r3, r3, #16
 8024c8c:	43db      	mvns	r3, r3
 8024c8e:	68fa      	ldr	r2, [r7, #12]
 8024c90:	4013      	ands	r3, r2
 8024c92:	60fb      	str	r3, [r7, #12]
  gctrl |= ((uint32_t)slice_mode_msk & 0xFFFFU);
 8024c94:	683b      	ldr	r3, [r7, #0]
 8024c96:	b29b      	uxth	r3, r3
 8024c98:	68fa      	ldr	r2, [r7, #12]
 8024c9a:	4313      	orrs	r3, r2
 8024c9c:	60fb      	str	r3, [r7, #12]
  module->GCTRL = gctrl;
 8024c9e:	687b      	ldr	r3, [r7, #4]
 8024ca0:	68fa      	ldr	r2, [r7, #12]
 8024ca2:	601a      	str	r2, [r3, #0]
}
 8024ca4:	bf00      	nop
 8024ca6:	3714      	adds	r7, #20
 8024ca8:	46bd      	mov	sp, r7
 8024caa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024cae:	4770      	bx	lr

08024cb0 <XMC_CCU4_SLICE_CompareInit>:

/* API to configure CC4 Slice as Timer */
void XMC_CCU4_SLICE_CompareInit(XMC_CCU4_SLICE_t *const slice,
                                const XMC_CCU4_SLICE_COMPARE_CONFIG_t *const compare_init)
{
 8024cb0:	b480      	push	{r7}
 8024cb2:	b083      	sub	sp, #12
 8024cb4:	af00      	add	r7, sp, #0
 8024cb6:	6078      	str	r0, [r7, #4]
 8024cb8:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Compare Init Pointer is NULL",
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
 8024cba:	683b      	ldr	r3, [r7, #0]
 8024cbc:	681a      	ldr	r2, [r3, #0]
 8024cbe:	687b      	ldr	r3, [r7, #4]
 8024cc0:	615a      	str	r2, [r3, #20]
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 8024cc2:	683b      	ldr	r3, [r7, #0]
 8024cc4:	795b      	ldrb	r3, [r3, #5]
 8024cc6:	f3c3 1340 	ubfx	r3, r3, #5, #1
 8024cca:	b2db      	uxtb	r3, r3
 8024ccc:	051a      	lsls	r2, r3, #20
 8024cce:	687b      	ldr	r3, [r7, #4]
 8024cd0:	605a      	str	r2, [r3, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 8024cd2:	683b      	ldr	r3, [r7, #0]
 8024cd4:	791b      	ldrb	r3, [r3, #4]
 8024cd6:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8024cda:	b2db      	uxtb	r3, r3
 8024cdc:	461a      	mov	r2, r3
 8024cde:	687b      	ldr	r3, [r7, #4]
 8024ce0:	625a      	str	r2, [r3, #36]	; 0x24
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 8024ce2:	683b      	ldr	r3, [r7, #0]
 8024ce4:	795b      	ldrb	r3, [r3, #5]
 8024ce6:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8024cea:	b2db      	uxtb	r3, r3
 8024cec:	461a      	mov	r2, r3
 8024cee:	687b      	ldr	r3, [r7, #4]
 8024cf0:	621a      	str	r2, [r3, #32]
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
 8024cf2:	683b      	ldr	r3, [r7, #0]
 8024cf4:	795b      	ldrb	r3, [r3, #5]
 8024cf6:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8024cfa:	b2db      	uxtb	r3, r3
 8024cfc:	461a      	mov	r2, r3
 8024cfe:	687b      	ldr	r3, [r7, #4]
 8024d00:	619a      	str	r2, [r3, #24]
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 8024d02:	683b      	ldr	r3, [r7, #0]
 8024d04:	791b      	ldrb	r3, [r3, #4]
 8024d06:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8024d0a:	b2db      	uxtb	r3, r3
 8024d0c:	461a      	mov	r2, r3
 8024d0e:	687b      	ldr	r3, [r7, #4]
 8024d10:	62da      	str	r2, [r3, #44]	; 0x2c
}
 8024d12:	bf00      	nop
 8024d14:	370c      	adds	r7, #12
 8024d16:	46bd      	mov	sp, r7
 8024d18:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024d1c:	4770      	bx	lr

08024d1e <XMC_CCU4_SLICE_CaptureInit>:

/* API to configure CC4 Slice for Capture */
void XMC_CCU4_SLICE_CaptureInit(XMC_CCU4_SLICE_t *const slice,
                                const XMC_CCU4_SLICE_CAPTURE_CONFIG_t *const capture_init)
{
 8024d1e:	b480      	push	{r7}
 8024d20:	b083      	sub	sp, #12
 8024d22:	af00      	add	r7, sp, #0
 8024d24:	6078      	str	r0, [r7, #4]
 8024d26:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_CaptureInit:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_CaptureInit:Capture Init Pointer is NULL",
             (XMC_CCU4_SLICE_CAPTURE_CONFIG_t *) NULL != capture_init);

  /* Program the capture mode */
  slice->TC = capture_init->tc;
 8024d28:	683b      	ldr	r3, [r7, #0]
 8024d2a:	681a      	ldr	r2, [r3, #0]
 8024d2c:	687b      	ldr	r3, [r7, #4]
 8024d2e:	615a      	str	r2, [r3, #20]
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t)capture_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 8024d30:	683b      	ldr	r3, [r7, #0]
 8024d32:	795b      	ldrb	r3, [r3, #5]
 8024d34:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8024d38:	b2db      	uxtb	r3, r3
 8024d3a:	051a      	lsls	r2, r3, #20
 8024d3c:	687b      	ldr	r3, [r7, #4]
 8024d3e:	605a      	str	r2, [r3, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) capture_init->prescaler_initval;
 8024d40:	683b      	ldr	r3, [r7, #0]
 8024d42:	791b      	ldrb	r3, [r3, #4]
 8024d44:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8024d48:	b2db      	uxtb	r3, r3
 8024d4a:	461a      	mov	r2, r3
 8024d4c:	687b      	ldr	r3, [r7, #4]
 8024d4e:	625a      	str	r2, [r3, #36]	; 0x24
  /* Program initial floating prescaler compare value */
  slice->FPCS = (uint32_t) capture_init->float_limit;
 8024d50:	683b      	ldr	r3, [r7, #0]
 8024d52:	791b      	ldrb	r3, [r3, #4]
 8024d54:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8024d58:	b2db      	uxtb	r3, r3
 8024d5a:	461a      	mov	r2, r3
 8024d5c:	687b      	ldr	r3, [r7, #4]
 8024d5e:	62da      	str	r2, [r3, #44]	; 0x2c
}
 8024d60:	bf00      	nop
 8024d62:	370c      	adds	r7, #12
 8024d64:	46bd      	mov	sp, r7
 8024d66:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024d6a:	4770      	bx	lr

08024d6c <XMC_CCU4_SLICE_StartConfig>:

/* API to configure the Start trigger function of a slice */
void XMC_CCU4_SLICE_StartConfig(XMC_CCU4_SLICE_t *const slice,
                                const XMC_CCU4_SLICE_EVENT_t event,
                                const XMC_CCU4_SLICE_START_MODE_t start_mode)
{
 8024d6c:	b480      	push	{r7}
 8024d6e:	b085      	sub	sp, #20
 8024d70:	af00      	add	r7, sp, #0
 8024d72:	6078      	str	r0, [r7, #4]
 8024d74:	460b      	mov	r3, r1
 8024d76:	70fb      	strb	r3, [r7, #3]
 8024d78:	4613      	mov	r3, r2
 8024d7a:	70bb      	strb	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU4_SLICE_StartConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU4_SLICE_StartConfig:Invalid Start Mode",
             ((start_mode == XMC_CCU4_SLICE_START_MODE_TIMER_START_CLEAR) || \
              (start_mode == XMC_CCU4_SLICE_START_MODE_TIMER_START)));
  /* First, Bind the event with the stop function */
  cmc = slice->CMC;
 8024d7c:	687b      	ldr	r3, [r7, #4]
 8024d7e:	685b      	ldr	r3, [r3, #4]
 8024d80:	60bb      	str	r3, [r7, #8]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_STRTS_Msk);
 8024d82:	68bb      	ldr	r3, [r7, #8]
 8024d84:	f023 0303 	bic.w	r3, r3, #3
 8024d88:	60bb      	str	r3, [r7, #8]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_STRTS_Pos;
 8024d8a:	78fb      	ldrb	r3, [r7, #3]
 8024d8c:	68ba      	ldr	r2, [r7, #8]
 8024d8e:	4313      	orrs	r3, r2
 8024d90:	60bb      	str	r3, [r7, #8]

  slice->CMC = cmc;
 8024d92:	687b      	ldr	r3, [r7, #4]
 8024d94:	68ba      	ldr	r2, [r7, #8]
 8024d96:	605a      	str	r2, [r3, #4]

  tc  = slice->TC;
 8024d98:	687b      	ldr	r3, [r7, #4]
 8024d9a:	695b      	ldr	r3, [r3, #20]
 8024d9c:	60fb      	str	r3, [r7, #12]
  /* Next, Configure the start mode */
  if (start_mode == XMC_CCU4_SLICE_START_MODE_TIMER_START_CLEAR)
 8024d9e:	78bb      	ldrb	r3, [r7, #2]
 8024da0:	2b01      	cmp	r3, #1
 8024da2:	d104      	bne.n	8024dae <XMC_CCU4_SLICE_StartConfig+0x42>
  {
    tc |= (uint32_t)CCU4_CC4_TC_STRM_Msk;
 8024da4:	68fb      	ldr	r3, [r7, #12]
 8024da6:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8024daa:	60fb      	str	r3, [r7, #12]
 8024dac:	e003      	b.n	8024db6 <XMC_CCU4_SLICE_StartConfig+0x4a>
  }
  else
  {
    tc &= ~((uint32_t)CCU4_CC4_TC_STRM_Msk);
 8024dae:	68fb      	ldr	r3, [r7, #12]
 8024db0:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8024db4:	60fb      	str	r3, [r7, #12]
  }

  slice->TC = tc;
 8024db6:	687b      	ldr	r3, [r7, #4]
 8024db8:	68fa      	ldr	r2, [r7, #12]
 8024dba:	615a      	str	r2, [r3, #20]
}
 8024dbc:	bf00      	nop
 8024dbe:	3714      	adds	r7, #20
 8024dc0:	46bd      	mov	sp, r7
 8024dc2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024dc6:	4770      	bx	lr

08024dc8 <XMC_CCU4_SLICE_StopConfig>:

/* API to configure the Stop trigger function of a slice */
void XMC_CCU4_SLICE_StopConfig(XMC_CCU4_SLICE_t *const slice,
                               const XMC_CCU4_SLICE_EVENT_t event,
                               const XMC_CCU4_SLICE_END_MODE_t end_mode)
{
 8024dc8:	b480      	push	{r7}
 8024dca:	b085      	sub	sp, #20
 8024dcc:	af00      	add	r7, sp, #0
 8024dce:	6078      	str	r0, [r7, #4]
 8024dd0:	460b      	mov	r3, r1
 8024dd2:	70fb      	strb	r3, [r7, #3]
 8024dd4:	4613      	mov	r3, r2
 8024dd6:	70bb      	strb	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU4_SLICE_StopConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_StopConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU4_SLICE_StopConfig:Invalid Start Mode", XMC_CCU4_CHECK_END_MODE(end_mode));

  /* First, Bind the event with the stop function */
  cmc = slice->CMC;
 8024dd8:	687b      	ldr	r3, [r7, #4]
 8024dda:	685b      	ldr	r3, [r3, #4]
 8024ddc:	60fb      	str	r3, [r7, #12]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_ENDS_Msk);
 8024dde:	68fb      	ldr	r3, [r7, #12]
 8024de0:	f023 030c 	bic.w	r3, r3, #12
 8024de4:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_ENDS_Pos;
 8024de6:	78fb      	ldrb	r3, [r7, #3]
 8024de8:	009b      	lsls	r3, r3, #2
 8024dea:	68fa      	ldr	r2, [r7, #12]
 8024dec:	4313      	orrs	r3, r2
 8024dee:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 8024df0:	687b      	ldr	r3, [r7, #4]
 8024df2:	68fa      	ldr	r2, [r7, #12]
 8024df4:	605a      	str	r2, [r3, #4]

  /* Next, Configure the stop mode */
  tc = slice->TC;
 8024df6:	687b      	ldr	r3, [r7, #4]
 8024df8:	695b      	ldr	r3, [r3, #20]
 8024dfa:	60bb      	str	r3, [r7, #8]
  tc &= ~((uint32_t) CCU4_CC4_TC_ENDM_Msk);
 8024dfc:	68bb      	ldr	r3, [r7, #8]
 8024dfe:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8024e02:	60bb      	str	r3, [r7, #8]
  tc |= ((uint32_t) end_mode) << CCU4_CC4_TC_ENDM_Pos;
 8024e04:	78bb      	ldrb	r3, [r7, #2]
 8024e06:	021b      	lsls	r3, r3, #8
 8024e08:	68ba      	ldr	r2, [r7, #8]
 8024e0a:	4313      	orrs	r3, r2
 8024e0c:	60bb      	str	r3, [r7, #8]

  slice->TC = tc;
 8024e0e:	687b      	ldr	r3, [r7, #4]
 8024e10:	68ba      	ldr	r2, [r7, #8]
 8024e12:	615a      	str	r2, [r3, #20]
}
 8024e14:	bf00      	nop
 8024e16:	3714      	adds	r7, #20
 8024e18:	46bd      	mov	sp, r7
 8024e1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024e1e:	4770      	bx	lr

08024e20 <XMC_CCU4_SLICE_LoadConfig>:

/* API to configure the Load trigger function of a slice */
void XMC_CCU4_SLICE_LoadConfig(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_EVENT_t event)
{
 8024e20:	b480      	push	{r7}
 8024e22:	b085      	sub	sp, #20
 8024e24:	af00      	add	r7, sp, #0
 8024e26:	6078      	str	r0, [r7, #4]
 8024e28:	460b      	mov	r3, r1
 8024e2a:	70fb      	strb	r3, [r7, #3]

  XMC_ASSERT("XMC_CCU4_SLICE_LoadConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_LoadConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));

  /* Bind the event with the load function */
  cmc = slice->CMC;
 8024e2c:	687b      	ldr	r3, [r7, #4]
 8024e2e:	685b      	ldr	r3, [r3, #4]
 8024e30:	60fb      	str	r3, [r7, #12]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_LDS_Msk);
 8024e32:	68fb      	ldr	r3, [r7, #12]
 8024e34:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8024e38:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_LDS_Pos;
 8024e3a:	78fb      	ldrb	r3, [r7, #3]
 8024e3c:	031b      	lsls	r3, r3, #12
 8024e3e:	68fa      	ldr	r2, [r7, #12]
 8024e40:	4313      	orrs	r3, r2
 8024e42:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 8024e44:	687b      	ldr	r3, [r7, #4]
 8024e46:	68fa      	ldr	r2, [r7, #12]
 8024e48:	605a      	str	r2, [r3, #4]
}
 8024e4a:	bf00      	nop
 8024e4c:	3714      	adds	r7, #20
 8024e4e:	46bd      	mov	sp, r7
 8024e50:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024e54:	4770      	bx	lr

08024e56 <XMC_CCU4_SLICE_ModulationConfig>:
/* API to configure the slice modulation function */
void XMC_CCU4_SLICE_ModulationConfig(XMC_CCU4_SLICE_t *const slice,
                                     const XMC_CCU4_SLICE_EVENT_t event,
                                     const XMC_CCU4_SLICE_MODULATION_MODE_t mod_mode,
                                     const bool synch_with_pwm)
{
 8024e56:	b480      	push	{r7}
 8024e58:	b085      	sub	sp, #20
 8024e5a:	af00      	add	r7, sp, #0
 8024e5c:	6078      	str	r0, [r7, #4]
 8024e5e:	4608      	mov	r0, r1
 8024e60:	4611      	mov	r1, r2
 8024e62:	461a      	mov	r2, r3
 8024e64:	4603      	mov	r3, r0
 8024e66:	70fb      	strb	r3, [r7, #3]
 8024e68:	460b      	mov	r3, r1
 8024e6a:	70bb      	strb	r3, [r7, #2]
 8024e6c:	4613      	mov	r3, r2
 8024e6e:	707b      	strb	r3, [r7, #1]
  XMC_ASSERT("XMC_CCU4_SLICE_ModulationConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU4_SLICE_ModulationConfig:Invalid Modulation Mode",
             ((mod_mode == XMC_CCU4_SLICE_MODULATION_MODE_CLEAR_OUT) || \
              (mod_mode == XMC_CCU4_SLICE_MODULATION_MODE_CLEAR_ST_OUT)));

  tc  = slice->TC;
 8024e70:	687b      	ldr	r3, [r7, #4]
 8024e72:	695b      	ldr	r3, [r3, #20]
 8024e74:	60fb      	str	r3, [r7, #12]
  cmc = slice->CMC;
 8024e76:	687b      	ldr	r3, [r7, #4]
 8024e78:	685b      	ldr	r3, [r3, #4]
 8024e7a:	60bb      	str	r3, [r7, #8]

  /* First, Bind the event with the modulation function */
  cmc &= ~((uint32_t) CCU4_CC4_CMC_MOS_Msk);
 8024e7c:	68bb      	ldr	r3, [r7, #8]
 8024e7e:	f423 2340 	bic.w	r3, r3, #786432	; 0xc0000
 8024e82:	60bb      	str	r3, [r7, #8]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_MOS_Pos;
 8024e84:	78fb      	ldrb	r3, [r7, #3]
 8024e86:	049b      	lsls	r3, r3, #18
 8024e88:	68ba      	ldr	r2, [r7, #8]
 8024e8a:	4313      	orrs	r3, r2
 8024e8c:	60bb      	str	r3, [r7, #8]
  slice->CMC = cmc;
 8024e8e:	687b      	ldr	r3, [r7, #4]
 8024e90:	68ba      	ldr	r2, [r7, #8]
 8024e92:	605a      	str	r2, [r3, #4]

  /* Next, Modulation mode */
  if (mod_mode == XMC_CCU4_SLICE_MODULATION_MODE_CLEAR_OUT)
 8024e94:	78bb      	ldrb	r3, [r7, #2]
 8024e96:	2b01      	cmp	r3, #1
 8024e98:	d104      	bne.n	8024ea4 <XMC_CCU4_SLICE_ModulationConfig+0x4e>
  {
    tc |= (uint32_t) CCU4_CC4_TC_EMT_Msk;
 8024e9a:	68fb      	ldr	r3, [r7, #12]
 8024e9c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8024ea0:	60fb      	str	r3, [r7, #12]
 8024ea2:	e003      	b.n	8024eac <XMC_CCU4_SLICE_ModulationConfig+0x56>
  }
  else
  {
    tc &= ~((uint32_t) CCU4_CC4_TC_EMT_Msk);
 8024ea4:	68fb      	ldr	r3, [r7, #12]
 8024ea6:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8024eaa:	60fb      	str	r3, [r7, #12]
  }

  /* Synchronization of modulation effect with PWM cycle */
  if (synch_with_pwm == (bool) true)
 8024eac:	787b      	ldrb	r3, [r7, #1]
 8024eae:	2b00      	cmp	r3, #0
 8024eb0:	d004      	beq.n	8024ebc <XMC_CCU4_SLICE_ModulationConfig+0x66>
  {
    tc |= (uint32_t) CCU4_CC4_TC_EMS_Msk;
 8024eb2:	68fb      	ldr	r3, [r7, #12]
 8024eb4:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8024eb8:	60fb      	str	r3, [r7, #12]
 8024eba:	e003      	b.n	8024ec4 <XMC_CCU4_SLICE_ModulationConfig+0x6e>
  }
  else
  {
    tc &= ~((uint32_t) CCU4_CC4_TC_EMS_Msk);
 8024ebc:	68fb      	ldr	r3, [r7, #12]
 8024ebe:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8024ec2:	60fb      	str	r3, [r7, #12]
  }

  slice->TC = tc;
 8024ec4:	687b      	ldr	r3, [r7, #4]
 8024ec6:	68fa      	ldr	r2, [r7, #12]
 8024ec8:	615a      	str	r2, [r3, #20]
}
 8024eca:	bf00      	nop
 8024ecc:	3714      	adds	r7, #20
 8024ece:	46bd      	mov	sp, r7
 8024ed0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024ed4:	4770      	bx	lr

08024ed6 <XMC_CCU4_SLICE_CountConfig>:

/* API to configure the slice count function */
void XMC_CCU4_SLICE_CountConfig(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_EVENT_t event)
{
 8024ed6:	b480      	push	{r7}
 8024ed8:	b085      	sub	sp, #20
 8024eda:	af00      	add	r7, sp, #0
 8024edc:	6078      	str	r0, [r7, #4]
 8024ede:	460b      	mov	r3, r1
 8024ee0:	70fb      	strb	r3, [r7, #3]

  XMC_ASSERT("XMC_CCU4_SLICE_CountConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_CountConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));

  /* Bind the event with the count function */
  cmc = slice->CMC;
 8024ee2:	687b      	ldr	r3, [r7, #4]
 8024ee4:	685b      	ldr	r3, [r3, #4]
 8024ee6:	60fb      	str	r3, [r7, #12]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_CNTS_Msk);
 8024ee8:	68fb      	ldr	r3, [r7, #12]
 8024eea:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8024eee:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_CNTS_Pos;
 8024ef0:	78fb      	ldrb	r3, [r7, #3]
 8024ef2:	039b      	lsls	r3, r3, #14
 8024ef4:	68fa      	ldr	r2, [r7, #12]
 8024ef6:	4313      	orrs	r3, r2
 8024ef8:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 8024efa:	687b      	ldr	r3, [r7, #4]
 8024efc:	68fa      	ldr	r2, [r7, #12]
 8024efe:	605a      	str	r2, [r3, #4]
}
 8024f00:	bf00      	nop
 8024f02:	3714      	adds	r7, #20
 8024f04:	46bd      	mov	sp, r7
 8024f06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024f0a:	4770      	bx	lr

08024f0c <XMC_CCU4_SLICE_GateConfig>:

/* API to configure slice gate function */
void XMC_CCU4_SLICE_GateConfig(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_EVENT_t event)
{
 8024f0c:	b480      	push	{r7}
 8024f0e:	b085      	sub	sp, #20
 8024f10:	af00      	add	r7, sp, #0
 8024f12:	6078      	str	r0, [r7, #4]
 8024f14:	460b      	mov	r3, r1
 8024f16:	70fb      	strb	r3, [r7, #3]

  XMC_ASSERT("XMC_CCU4_SLICE_GateConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_GateConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));

  /* Bind the event with the gate function */
  cmc = slice->CMC;
 8024f18:	687b      	ldr	r3, [r7, #4]
 8024f1a:	685b      	ldr	r3, [r3, #4]
 8024f1c:	60fb      	str	r3, [r7, #12]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_GATES_Msk);
 8024f1e:	68fb      	ldr	r3, [r7, #12]
 8024f20:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8024f24:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_GATES_Pos;
 8024f26:	78fb      	ldrb	r3, [r7, #3]
 8024f28:	021b      	lsls	r3, r3, #8
 8024f2a:	68fa      	ldr	r2, [r7, #12]
 8024f2c:	4313      	orrs	r3, r2
 8024f2e:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 8024f30:	687b      	ldr	r3, [r7, #4]
 8024f32:	68fa      	ldr	r2, [r7, #12]
 8024f34:	605a      	str	r2, [r3, #4]
}
 8024f36:	bf00      	nop
 8024f38:	3714      	adds	r7, #20
 8024f3a:	46bd      	mov	sp, r7
 8024f3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024f40:	4770      	bx	lr

08024f42 <XMC_CCU4_SLICE_Capture1Config>:
  slice->CMC = cmc;
}

/* API to configure Capture-1 function */
void XMC_CCU4_SLICE_Capture1Config(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_EVENT_t event)
{
 8024f42:	b480      	push	{r7}
 8024f44:	b085      	sub	sp, #20
 8024f46:	af00      	add	r7, sp, #0
 8024f48:	6078      	str	r0, [r7, #4]
 8024f4a:	460b      	mov	r3, r1
 8024f4c:	70fb      	strb	r3, [r7, #3]

  XMC_ASSERT("XMC_CCU4_SLICE_Capture1Config:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_Capture1Config:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));

  /* Bind the event with the gate function */
  cmc = slice->CMC;
 8024f4e:	687b      	ldr	r3, [r7, #4]
 8024f50:	685b      	ldr	r3, [r3, #4]
 8024f52:	60fb      	str	r3, [r7, #12]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_CAP1S_Msk);
 8024f54:	68fb      	ldr	r3, [r7, #12]
 8024f56:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8024f5a:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_CAP1S_Pos;
 8024f5c:	78fb      	ldrb	r3, [r7, #3]
 8024f5e:	019b      	lsls	r3, r3, #6
 8024f60:	68fa      	ldr	r2, [r7, #12]
 8024f62:	4313      	orrs	r3, r2
 8024f64:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 8024f66:	687b      	ldr	r3, [r7, #4]
 8024f68:	68fa      	ldr	r2, [r7, #12]
 8024f6a:	605a      	str	r2, [r3, #4]
}
 8024f6c:	bf00      	nop
 8024f6e:	3714      	adds	r7, #20
 8024f70:	46bd      	mov	sp, r7
 8024f72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024f76:	4770      	bx	lr

08024f78 <XMC_CCU4_SLICE_DirectionConfig>:

/* API to configure direction function */
void XMC_CCU4_SLICE_DirectionConfig(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_EVENT_t event)
{
 8024f78:	b480      	push	{r7}
 8024f7a:	b085      	sub	sp, #20
 8024f7c:	af00      	add	r7, sp, #0
 8024f7e:	6078      	str	r0, [r7, #4]
 8024f80:	460b      	mov	r3, r1
 8024f82:	70fb      	strb	r3, [r7, #3]

  XMC_ASSERT("XMC_CCU4_SLICE_DirectionConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_DirectionConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));

  /* Bind the event with the direction function */
  cmc = slice->CMC;
 8024f84:	687b      	ldr	r3, [r7, #4]
 8024f86:	685b      	ldr	r3, [r3, #4]
 8024f88:	60fb      	str	r3, [r7, #12]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_UDS_Msk);
 8024f8a:	68fb      	ldr	r3, [r7, #12]
 8024f8c:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8024f90:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_UDS_Pos;
 8024f92:	78fb      	ldrb	r3, [r7, #3]
 8024f94:	029b      	lsls	r3, r3, #10
 8024f96:	68fa      	ldr	r2, [r7, #12]
 8024f98:	4313      	orrs	r3, r2
 8024f9a:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 8024f9c:	687b      	ldr	r3, [r7, #4]
 8024f9e:	68fa      	ldr	r2, [r7, #12]
 8024fa0:	605a      	str	r2, [r3, #4]
}
 8024fa2:	bf00      	nop
 8024fa4:	3714      	adds	r7, #20
 8024fa6:	46bd      	mov	sp, r7
 8024fa8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024fac:	4770      	bx	lr

08024fae <XMC_CCU4_SLICE_StatusBitOverrideConfig>:

/* API to configure slice status bit override function */
void XMC_CCU4_SLICE_StatusBitOverrideConfig(XMC_CCU4_SLICE_t *const slice)
{
 8024fae:	b480      	push	{r7}
 8024fb0:	b085      	sub	sp, #20
 8024fb2:	af00      	add	r7, sp, #0
 8024fb4:	6078      	str	r0, [r7, #4]
  uint32_t cmc;

  XMC_ASSERT("XMC_CCU4_SLICE_StatusBitOverrideConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));

  /* Bind the event with the override function */
  cmc = slice->CMC;
 8024fb6:	687b      	ldr	r3, [r7, #4]
 8024fb8:	685b      	ldr	r3, [r3, #4]
 8024fba:	60fb      	str	r3, [r7, #12]
  /* Map status bit trigger override to Event 1 &
         status bit value override to Event 2 */
  cmc &= ~((uint32_t) CCU4_CC4_CMC_OFS_Msk);
 8024fbc:	68fb      	ldr	r3, [r7, #12]
 8024fbe:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8024fc2:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) 1) << CCU4_CC4_CMC_OFS_Pos;
 8024fc4:	68fb      	ldr	r3, [r7, #12]
 8024fc6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8024fca:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 8024fcc:	687b      	ldr	r3, [r7, #4]
 8024fce:	68fa      	ldr	r2, [r7, #12]
 8024fd0:	605a      	str	r2, [r3, #4]
}
 8024fd2:	bf00      	nop
 8024fd4:	3714      	adds	r7, #20
 8024fd6:	46bd      	mov	sp, r7
 8024fd8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024fdc:	4770      	bx	lr

08024fde <XMC_CCU4_SLICE_TrapConfig>:

/* API to configure trap function */
void XMC_CCU4_SLICE_TrapConfig(XMC_CCU4_SLICE_t *const slice,
                               const XMC_CCU4_SLICE_TRAP_EXIT_MODE_t exit_mode,
                               const bool synch_with_pwm)
{
 8024fde:	b480      	push	{r7}
 8024fe0:	b085      	sub	sp, #20
 8024fe2:	af00      	add	r7, sp, #0
 8024fe4:	6078      	str	r0, [r7, #4]
 8024fe6:	460b      	mov	r3, r1
 8024fe8:	70fb      	strb	r3, [r7, #3]
 8024fea:	4613      	mov	r3, r2
 8024fec:	70bb      	strb	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU4_SLICE_TrapConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_TrapConfig:Invalid Exit Mode", ((exit_mode == XMC_CCU4_SLICE_TRAP_EXIT_MODE_AUTOMATIC) || \
             (exit_mode == XMC_CCU4_SLICE_TRAP_EXIT_MODE_SW)));

  /* First, Map trap function to Event 2 */
  cmc = slice->CMC;
 8024fee:	687b      	ldr	r3, [r7, #4]
 8024ff0:	685b      	ldr	r3, [r3, #4]
 8024ff2:	60bb      	str	r3, [r7, #8]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_TS_Msk);
 8024ff4:	68bb      	ldr	r3, [r7, #8]
 8024ff6:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8024ffa:	60bb      	str	r3, [r7, #8]
  cmc |= ((uint32_t) 1) << CCU4_CC4_CMC_TS_Pos;
 8024ffc:	68bb      	ldr	r3, [r7, #8]
 8024ffe:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8025002:	60bb      	str	r3, [r7, #8]
  slice->CMC = cmc;
 8025004:	687b      	ldr	r3, [r7, #4]
 8025006:	68ba      	ldr	r2, [r7, #8]
 8025008:	605a      	str	r2, [r3, #4]

  /* Next, Configure synchronization option */
  tc = slice->TC;
 802500a:	687b      	ldr	r3, [r7, #4]
 802500c:	695b      	ldr	r3, [r3, #20]
 802500e:	60fb      	str	r3, [r7, #12]

  if (synch_with_pwm == (bool) true)
 8025010:	78bb      	ldrb	r3, [r7, #2]
 8025012:	2b00      	cmp	r3, #0
 8025014:	d004      	beq.n	8025020 <XMC_CCU4_SLICE_TrapConfig+0x42>
  {
    tc |= (uint32_t) CCU4_CC4_TC_TRPSE_Msk;
 8025016:	68fb      	ldr	r3, [r7, #12]
 8025018:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 802501c:	60fb      	str	r3, [r7, #12]
 802501e:	e003      	b.n	8025028 <XMC_CCU4_SLICE_TrapConfig+0x4a>
  }
  else
  {
    tc &= ~((uint32_t) CCU4_CC4_TC_TRPSE_Msk);
 8025020:	68fb      	ldr	r3, [r7, #12]
 8025022:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8025026:	60fb      	str	r3, [r7, #12]
  }

  /* Configure exit mode */
  if (exit_mode == XMC_CCU4_SLICE_TRAP_EXIT_MODE_SW)
 8025028:	78fb      	ldrb	r3, [r7, #3]
 802502a:	2b01      	cmp	r3, #1
 802502c:	d104      	bne.n	8025038 <XMC_CCU4_SLICE_TrapConfig+0x5a>
  {
    tc |= (uint32_t) CCU4_CC4_TC_TRPSW_Msk;
 802502e:	68fb      	ldr	r3, [r7, #12]
 8025030:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8025034:	60fb      	str	r3, [r7, #12]
 8025036:	e003      	b.n	8025040 <XMC_CCU4_SLICE_TrapConfig+0x62>
  }
  else
  {
    tc &= ~((uint32_t) CCU4_CC4_TC_TRPSW_Msk);
 8025038:	68fb      	ldr	r3, [r7, #12]
 802503a:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 802503e:	60fb      	str	r3, [r7, #12]
  }

  slice->TC = tc;
 8025040:	687b      	ldr	r3, [r7, #4]
 8025042:	68fa      	ldr	r2, [r7, #12]
 8025044:	615a      	str	r2, [r3, #20]
}
 8025046:	bf00      	nop
 8025048:	3714      	adds	r7, #20
 802504a:	46bd      	mov	sp, r7
 802504c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025050:	4770      	bx	lr

08025052 <XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent>:

/* API to configure a slice Status Bit Override event */
void XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent(XMC_CCU4_SLICE_t *const slice,
    const XMC_CCU4_SLICE_EVENT_CONFIG_t *const ev1_config,
    const XMC_CCU4_SLICE_EVENT_CONFIG_t *const ev2_config)
{
 8025052:	b480      	push	{r7}
 8025054:	b087      	sub	sp, #28
 8025056:	af00      	add	r7, sp, #0
 8025058:	60f8      	str	r0, [r7, #12]
 802505a:	60b9      	str	r1, [r7, #8]
 802505c:	607a      	str	r2, [r7, #4]
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_INPUT_CONFIG_MASK) << CCU4_CC4_INS1_EV2IS_Pos);
  ins |= ((uint32_t) ev2_config->mapped_input) << CCU4_CC4_INS1_EV2IS_Pos;

  slice->INS1 = ins;
#else
  ins = slice->INS;
 802505e:	68fb      	ldr	r3, [r7, #12]
 8025060:	681b      	ldr	r3, [r3, #0]
 8025062:	617b      	str	r3, [r7, #20]

  /* Configure the edge sensitivity for event 1 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_EDGE_CONFIG_MASK) << CCU4_CC4_INS_EV1EM_Pos);
 8025064:	697b      	ldr	r3, [r7, #20]
 8025066:	f423 2340 	bic.w	r3, r3, #786432	; 0xc0000
 802506a:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev1_config->edge) << CCU4_CC4_INS_EV1EM_Pos;
 802506c:	68bb      	ldr	r3, [r7, #8]
 802506e:	785b      	ldrb	r3, [r3, #1]
 8025070:	049b      	lsls	r3, r3, #18
 8025072:	697a      	ldr	r2, [r7, #20]
 8025074:	4313      	orrs	r3, r2
 8025076:	617b      	str	r3, [r7, #20]

  /* Configure the edge sensitivity for event 2 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_EDGE_CONFIG_MASK) << CCU4_CC4_INS_EV2EM_Pos);
 8025078:	697b      	ldr	r3, [r7, #20]
 802507a:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 802507e:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev2_config->edge) << CCU4_CC4_INS_EV2EM_Pos;
 8025080:	687b      	ldr	r3, [r7, #4]
 8025082:	785b      	ldrb	r3, [r3, #1]
 8025084:	051b      	lsls	r3, r3, #20
 8025086:	697a      	ldr	r2, [r7, #20]
 8025088:	4313      	orrs	r3, r2
 802508a:	617b      	str	r3, [r7, #20]

  /* Configure the level sensitivity for event 1 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << CCU4_CC4_INS_EV1LM_Pos);
 802508c:	697b      	ldr	r3, [r7, #20]
 802508e:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8025092:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev1_config->level) << CCU4_CC4_INS_EV1LM_Pos;
 8025094:	68bb      	ldr	r3, [r7, #8]
 8025096:	789b      	ldrb	r3, [r3, #2]
 8025098:	05db      	lsls	r3, r3, #23
 802509a:	697a      	ldr	r2, [r7, #20]
 802509c:	4313      	orrs	r3, r2
 802509e:	617b      	str	r3, [r7, #20]

  /* Configure the level sensitivity for event 2 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << CCU4_CC4_INS_EV2LM_Pos);
 80250a0:	697b      	ldr	r3, [r7, #20]
 80250a2:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80250a6:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev2_config->level) << CCU4_CC4_INS_EV2LM_Pos;
 80250a8:	687b      	ldr	r3, [r7, #4]
 80250aa:	789b      	ldrb	r3, [r3, #2]
 80250ac:	061b      	lsls	r3, r3, #24
 80250ae:	697a      	ldr	r2, [r7, #20]
 80250b0:	4313      	orrs	r3, r2
 80250b2:	617b      	str	r3, [r7, #20]

  /* Configure the debounce filter for event 1 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << CCU4_CC4_INS_LPF1M_Pos);
 80250b4:	697b      	ldr	r3, [r7, #20]
 80250b6:	f023 53c0 	bic.w	r3, r3, #402653184	; 0x18000000
 80250ba:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev1_config->duration) << CCU4_CC4_INS_LPF1M_Pos;
 80250bc:	68bb      	ldr	r3, [r7, #8]
 80250be:	78db      	ldrb	r3, [r3, #3]
 80250c0:	06db      	lsls	r3, r3, #27
 80250c2:	697a      	ldr	r2, [r7, #20]
 80250c4:	4313      	orrs	r3, r2
 80250c6:	617b      	str	r3, [r7, #20]

  /* Configure the debounce filter for event 2 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << CCU4_CC4_INS_LPF2M_Pos);
 80250c8:	697b      	ldr	r3, [r7, #20]
 80250ca:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 80250ce:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev2_config->duration) << CCU4_CC4_INS_LPF2M_Pos;
 80250d0:	687b      	ldr	r3, [r7, #4]
 80250d2:	78db      	ldrb	r3, [r3, #3]
 80250d4:	075b      	lsls	r3, r3, #29
 80250d6:	697a      	ldr	r2, [r7, #20]
 80250d8:	4313      	orrs	r3, r2
 80250da:	617b      	str	r3, [r7, #20]

  /* Next, the input for Event1 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_INPUT_CONFIG_MASK) << CCU4_CC4_INS_EV1IS_Pos);
 80250dc:	697b      	ldr	r3, [r7, #20]
 80250de:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80250e2:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev1_config->mapped_input) << CCU4_CC4_INS_EV1IS_Pos;
 80250e4:	68bb      	ldr	r3, [r7, #8]
 80250e6:	781b      	ldrb	r3, [r3, #0]
 80250e8:	011b      	lsls	r3, r3, #4
 80250ea:	697a      	ldr	r2, [r7, #20]
 80250ec:	4313      	orrs	r3, r2
 80250ee:	617b      	str	r3, [r7, #20]

  /* Finally, the input for Event2 */
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_INPUT_CONFIG_MASK) << CCU4_CC4_INS_EV2IS_Pos);
 80250f0:	697b      	ldr	r3, [r7, #20]
 80250f2:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 80250f6:	617b      	str	r3, [r7, #20]
  ins |= ((uint32_t) ev2_config->mapped_input) << CCU4_CC4_INS_EV2IS_Pos;
 80250f8:	687b      	ldr	r3, [r7, #4]
 80250fa:	781b      	ldrb	r3, [r3, #0]
 80250fc:	021b      	lsls	r3, r3, #8
 80250fe:	697a      	ldr	r2, [r7, #20]
 8025100:	4313      	orrs	r3, r2
 8025102:	617b      	str	r3, [r7, #20]

  slice->INS = ins;
 8025104:	68fb      	ldr	r3, [r7, #12]
 8025106:	697a      	ldr	r2, [r7, #20]
 8025108:	601a      	str	r2, [r3, #0]
#endif
}
 802510a:	bf00      	nop
 802510c:	371c      	adds	r7, #28
 802510e:	46bd      	mov	sp, r7
 8025110:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025114:	4770      	bx	lr

08025116 <XMC_CCU4_SLICE_ConfigureEvent>:

/* API to configure a slice trigger event */
void XMC_CCU4_SLICE_ConfigureEvent(XMC_CCU4_SLICE_t *const slice,
                                   const XMC_CCU4_SLICE_EVENT_t event,
                                   const XMC_CCU4_SLICE_EVENT_CONFIG_t *const config)
{
 8025116:	b480      	push	{r7}
 8025118:	b089      	sub	sp, #36	; 0x24
 802511a:	af00      	add	r7, sp, #0
 802511c:	60f8      	str	r0, [r7, #12]
 802511e:	460b      	mov	r3, r1
 8025120:	607a      	str	r2, [r7, #4]
 8025122:	72fb      	strb	r3, [r7, #11]
             ((config->level == XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_HIGH) || \
              (config->level == XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_LOW)));
  XMC_ASSERT("XMC_CCU4_SLICE_ConfigureEvent:Invalid Debounce Period",
             XMC_CCU4_SLICE_CHECK_EVENT_FILTER(config->duration));
  /* Calculate offset with reference to event */
  offset = ((uint8_t) event) - 1U;
 8025124:	7afb      	ldrb	r3, [r7, #11]
 8025126:	3b01      	subs	r3, #1
 8025128:	77fb      	strb	r3, [r7, #31]
  ins |= ((uint32_t) config->mapped_input) << pos;

  slice->INS1 = ins;

#else
  ins = slice->INS;
 802512a:	68fb      	ldr	r3, [r7, #12]
 802512c:	681b      	ldr	r3, [r3, #0]
 802512e:	61bb      	str	r3, [r7, #24]

  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU4_CC4_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
 8025130:	7ffb      	ldrb	r3, [r7, #31]
 8025132:	005b      	lsls	r3, r3, #1
 8025134:	b2db      	uxtb	r3, r3
 8025136:	3310      	adds	r3, #16
 8025138:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
 802513a:	7dfb      	ldrb	r3, [r7, #23]
 802513c:	2203      	movs	r2, #3
 802513e:	fa02 f303 	lsl.w	r3, r2, r3
 8025142:	43db      	mvns	r3, r3
 8025144:	69ba      	ldr	r2, [r7, #24]
 8025146:	4013      	ands	r3, r2
 8025148:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) config->edge) << pos;
 802514a:	687b      	ldr	r3, [r7, #4]
 802514c:	785b      	ldrb	r3, [r3, #1]
 802514e:	461a      	mov	r2, r3
 8025150:	7dfb      	ldrb	r3, [r7, #23]
 8025152:	fa02 f303 	lsl.w	r3, r2, r3
 8025156:	69ba      	ldr	r2, [r7, #24]
 8025158:	4313      	orrs	r3, r2
 802515a:	61bb      	str	r3, [r7, #24]

  /* Next, the level */
  pos = ((uint8_t) CCU4_CC4_INS_EV0LM_Pos) + offset;
 802515c:	7ffb      	ldrb	r3, [r7, #31]
 802515e:	3316      	adds	r3, #22
 8025160:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
 8025162:	7dfb      	ldrb	r3, [r7, #23]
 8025164:	2201      	movs	r2, #1
 8025166:	fa02 f303 	lsl.w	r3, r2, r3
 802516a:	43db      	mvns	r3, r3
 802516c:	69ba      	ldr	r2, [r7, #24]
 802516e:	4013      	ands	r3, r2
 8025170:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) config->level) << pos;
 8025172:	687b      	ldr	r3, [r7, #4]
 8025174:	789b      	ldrb	r3, [r3, #2]
 8025176:	461a      	mov	r2, r3
 8025178:	7dfb      	ldrb	r3, [r7, #23]
 802517a:	fa02 f303 	lsl.w	r3, r2, r3
 802517e:	69ba      	ldr	r2, [r7, #24]
 8025180:	4313      	orrs	r3, r2
 8025182:	61bb      	str	r3, [r7, #24]

  /* Next, the debounce filter */
  pos = ((uint8_t) CCU4_CC4_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
 8025184:	7ffb      	ldrb	r3, [r7, #31]
 8025186:	005b      	lsls	r3, r3, #1
 8025188:	b2db      	uxtb	r3, r3
 802518a:	3319      	adds	r3, #25
 802518c:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
 802518e:	7dfb      	ldrb	r3, [r7, #23]
 8025190:	2203      	movs	r2, #3
 8025192:	fa02 f303 	lsl.w	r3, r2, r3
 8025196:	43db      	mvns	r3, r3
 8025198:	69ba      	ldr	r2, [r7, #24]
 802519a:	4013      	ands	r3, r2
 802519c:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) config->duration) << pos;
 802519e:	687b      	ldr	r3, [r7, #4]
 80251a0:	78db      	ldrb	r3, [r3, #3]
 80251a2:	461a      	mov	r2, r3
 80251a4:	7dfb      	ldrb	r3, [r7, #23]
 80251a6:	fa02 f303 	lsl.w	r3, r2, r3
 80251aa:	69ba      	ldr	r2, [r7, #24]
 80251ac:	4313      	orrs	r3, r2
 80251ae:	61bb      	str	r3, [r7, #24]

  /* Finally the input */
  pos = ((uint8_t) CCU4_CC4_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
 80251b0:	7ffb      	ldrb	r3, [r7, #31]
 80251b2:	009b      	lsls	r3, r3, #2
 80251b4:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
 80251b6:	7dfb      	ldrb	r3, [r7, #23]
 80251b8:	220f      	movs	r2, #15
 80251ba:	fa02 f303 	lsl.w	r3, r2, r3
 80251be:	43db      	mvns	r3, r3
 80251c0:	69ba      	ldr	r2, [r7, #24]
 80251c2:	4013      	ands	r3, r2
 80251c4:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) config->mapped_input) << pos;
 80251c6:	687b      	ldr	r3, [r7, #4]
 80251c8:	781b      	ldrb	r3, [r3, #0]
 80251ca:	461a      	mov	r2, r3
 80251cc:	7dfb      	ldrb	r3, [r7, #23]
 80251ce:	fa02 f303 	lsl.w	r3, r2, r3
 80251d2:	69ba      	ldr	r2, [r7, #24]
 80251d4:	4313      	orrs	r3, r2
 80251d6:	61bb      	str	r3, [r7, #24]

  slice->INS = ins;
 80251d8:	68fb      	ldr	r3, [r7, #12]
 80251da:	69ba      	ldr	r2, [r7, #24]
 80251dc:	601a      	str	r2, [r3, #0]
#endif
}
 80251de:	bf00      	nop
 80251e0:	3724      	adds	r7, #36	; 0x24
 80251e2:	46bd      	mov	sp, r7
 80251e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80251e8:	4770      	bx	lr

080251ea <XMC_CCU4_SLICE_GetCaptureRegisterValue>:
  }
}

/* Retrieves desired capture register value */
uint32_t XMC_CCU4_SLICE_GetCaptureRegisterValue(const XMC_CCU4_SLICE_t *const slice, const uint8_t reg_num)
{
 80251ea:	b480      	push	{r7}
 80251ec:	b083      	sub	sp, #12
 80251ee:	af00      	add	r7, sp, #0
 80251f0:	6078      	str	r0, [r7, #4]
 80251f2:	460b      	mov	r3, r1
 80251f4:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_CCU4_SLICE_GetCaptureRegisterValue:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_GetCaptureRegisterValue:Invalid register number", (reg_num < 4U));
  return (slice->CV[reg_num]);
 80251f6:	78fb      	ldrb	r3, [r7, #3]
 80251f8:	687a      	ldr	r2, [r7, #4]
 80251fa:	331c      	adds	r3, #28
 80251fc:	009b      	lsls	r3, r3, #2
 80251fe:	4413      	add	r3, r2
 8025200:	685b      	ldr	r3, [r3, #4]
}
 8025202:	4618      	mov	r0, r3
 8025204:	370c      	adds	r7, #12
 8025206:	46bd      	mov	sp, r7
 8025208:	f85d 7b04 	ldr.w	r7, [sp], #4
 802520c:	4770      	bx	lr

0802520e <XMC_CCU4_SLICE_SetPrescaler>:
  XMC_CCU4_SLICE_SetDitherCompareValue((XMC_CCU4_SLICE_t *)slice, (uint8_t)spread);
}

/* Programs Pre-scalar divider  */
void XMC_CCU4_SLICE_SetPrescaler(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_PRESCALER_t div_val)
{
 802520e:	b480      	push	{r7}
 8025210:	b085      	sub	sp, #20
 8025212:	af00      	add	r7, sp, #0
 8025214:	6078      	str	r0, [r7, #4]
 8025216:	460b      	mov	r3, r1
 8025218:	70fb      	strb	r3, [r7, #3]
  uint32_t fpc;

  XMC_ASSERT("XMC_CCU4_SLICE_SetPrescaler:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));

  fpc = slice->FPC;
 802521a:	687b      	ldr	r3, [r7, #4]
 802521c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802521e:	60fb      	str	r3, [r7, #12]
  fpc &= ~((uint32_t) CCU4_CC4_FPC_PVAL_Msk);
 8025220:	68fb      	ldr	r3, [r7, #12]
 8025222:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 8025226:	60fb      	str	r3, [r7, #12]
  fpc |= ((uint32_t) div_val) << CCU4_CC4_FPC_PVAL_Pos;
 8025228:	78fb      	ldrb	r3, [r7, #3]
 802522a:	021b      	lsls	r3, r3, #8
 802522c:	68fa      	ldr	r2, [r7, #12]
 802522e:	4313      	orrs	r3, r2
 8025230:	60fb      	str	r3, [r7, #12]
  slice->FPC = fpc;
 8025232:	687b      	ldr	r3, [r7, #4]
 8025234:	68fa      	ldr	r2, [r7, #12]
 8025236:	629a      	str	r2, [r3, #40]	; 0x28
  /*
   * In any case, update the initial value of the divider which is to be loaded once the prescaler increments to the
   * compare value.
   */
  slice->PSC = (uint32_t) div_val;
 8025238:	78fa      	ldrb	r2, [r7, #3]
 802523a:	687b      	ldr	r3, [r7, #4]
 802523c:	625a      	str	r2, [r3, #36]	; 0x24
}
 802523e:	bf00      	nop
 8025240:	3714      	adds	r7, #20
 8025242:	46bd      	mov	sp, r7
 8025244:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025248:	4770      	bx	lr
	...

0802524c <XMC_CCU4_SLICE_SetInterruptNode>:

/* Binds a capcom event to an NVIC node  */
void XMC_CCU4_SLICE_SetInterruptNode(XMC_CCU4_SLICE_t *const slice,
                                     const XMC_CCU4_SLICE_IRQ_ID_t event,
                                     const XMC_CCU4_SLICE_SR_ID_t sr)
{
 802524c:	b480      	push	{r7}
 802524e:	b087      	sub	sp, #28
 8025250:	af00      	add	r7, sp, #0
 8025252:	6078      	str	r0, [r7, #4]
 8025254:	460b      	mov	r3, r1
 8025256:	70fb      	strb	r3, [r7, #3]
 8025258:	4613      	mov	r3, r2
 802525a:	70bb      	strb	r3, [r7, #2]

  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU4_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));

  switch (event)
 802525c:	78fb      	ldrb	r3, [r7, #3]
 802525e:	2b0b      	cmp	r3, #11
 8025260:	d836      	bhi.n	80252d0 <XMC_CCU4_SLICE_SetInterruptNode+0x84>
 8025262:	a201      	add	r2, pc, #4	; (adr r2, 8025268 <XMC_CCU4_SLICE_SetInterruptNode+0x1c>)
 8025264:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8025268:	08025299 	.word	0x08025299
 802526c:	08025299 	.word	0x08025299
 8025270:	080252a3 	.word	0x080252a3
 8025274:	080252a3 	.word	0x080252a3
 8025278:	080252d1 	.word	0x080252d1
 802527c:	080252d1 	.word	0x080252d1
 8025280:	080252d1 	.word	0x080252d1
 8025284:	080252d1 	.word	0x080252d1
 8025288:	080252ad 	.word	0x080252ad
 802528c:	080252b9 	.word	0x080252b9
 8025290:	080252c5 	.word	0x080252c5
 8025294:	080252c5 	.word	0x080252c5
  {
    case XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH:
    case XMC_CCU4_SLICE_IRQ_ID_ONE_MATCH:
      mask = ((uint32_t) CCU4_CC4_SRS_POSR_Msk);
 8025298:	2303      	movs	r3, #3
 802529a:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_POSR_Pos;
 802529c:	2300      	movs	r3, #0
 802529e:	617b      	str	r3, [r7, #20]
      break;
 80252a0:	e01b      	b.n	80252da <XMC_CCU4_SLICE_SetInterruptNode+0x8e>

    case XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP:
    case XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_DOWN:
      mask = ((uint32_t) CCU4_CC4_SRS_CMSR_Msk);
 80252a2:	230c      	movs	r3, #12
 80252a4:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_CMSR_Pos;
 80252a6:	2302      	movs	r3, #2
 80252a8:	617b      	str	r3, [r7, #20]
      break;
 80252aa:	e016      	b.n	80252da <XMC_CCU4_SLICE_SetInterruptNode+0x8e>

    case XMC_CCU4_SLICE_IRQ_ID_EVENT0:
      mask = ((uint32_t) CCU4_CC4_SRS_E0SR_Msk);
 80252ac:	f44f 7340 	mov.w	r3, #768	; 0x300
 80252b0:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_E0SR_Pos;
 80252b2:	2308      	movs	r3, #8
 80252b4:	617b      	str	r3, [r7, #20]
      break;
 80252b6:	e010      	b.n	80252da <XMC_CCU4_SLICE_SetInterruptNode+0x8e>

    case XMC_CCU4_SLICE_IRQ_ID_EVENT1:
      mask = ((uint32_t) CCU4_CC4_SRS_E1SR_Msk);
 80252b8:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 80252bc:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_E1SR_Pos;
 80252be:	230a      	movs	r3, #10
 80252c0:	617b      	str	r3, [r7, #20]
      break;
 80252c2:	e00a      	b.n	80252da <XMC_CCU4_SLICE_SetInterruptNode+0x8e>

    case XMC_CCU4_SLICE_IRQ_ID_EVENT2:
    case XMC_CCU4_SLICE_IRQ_ID_TRAP:
      mask = ((uint32_t) CCU4_CC4_SRS_E2SR_Msk);
 80252c4:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 80252c8:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_E2SR_Pos;
 80252ca:	230c      	movs	r3, #12
 80252cc:	617b      	str	r3, [r7, #20]
      break;
 80252ce:	e004      	b.n	80252da <XMC_CCU4_SLICE_SetInterruptNode+0x8e>
	  
	default:
	  mask = 0;
 80252d0:	2300      	movs	r3, #0
 80252d2:	613b      	str	r3, [r7, #16]
	  pos = 0;
 80252d4:	2300      	movs	r3, #0
 80252d6:	617b      	str	r3, [r7, #20]
	  break;
 80252d8:	bf00      	nop
  }

  if (mask != 0)
 80252da:	693b      	ldr	r3, [r7, #16]
 80252dc:	2b00      	cmp	r3, #0
 80252de:	d013      	beq.n	8025308 <XMC_CCU4_SLICE_SetInterruptNode+0xbc>
  {
    srs = slice->SRS;
 80252e0:	687b      	ldr	r3, [r7, #4]
 80252e2:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 80252e6:	60fb      	str	r3, [r7, #12]
    srs &= ~mask;
 80252e8:	693b      	ldr	r3, [r7, #16]
 80252ea:	43db      	mvns	r3, r3
 80252ec:	68fa      	ldr	r2, [r7, #12]
 80252ee:	4013      	ands	r3, r2
 80252f0:	60fb      	str	r3, [r7, #12]
    srs |= (uint32_t)sr << pos;
 80252f2:	78ba      	ldrb	r2, [r7, #2]
 80252f4:	697b      	ldr	r3, [r7, #20]
 80252f6:	fa02 f303 	lsl.w	r3, r2, r3
 80252fa:	68fa      	ldr	r2, [r7, #12]
 80252fc:	4313      	orrs	r3, r2
 80252fe:	60fb      	str	r3, [r7, #12]
    slice->SRS = srs;
 8025300:	687b      	ldr	r3, [r7, #4]
 8025302:	68fa      	ldr	r2, [r7, #12]
 8025304:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
  }
}
 8025308:	bf00      	nop
 802530a:	371c      	adds	r7, #28
 802530c:	46bd      	mov	sp, r7
 802530e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025312:	4770      	bx	lr

08025314 <XMC_CCU8_StartPrescaler>:
{
 8025314:	b480      	push	{r7}
 8025316:	b083      	sub	sp, #12
 8025318:	af00      	add	r7, sp, #0
 802531a:	6078      	str	r0, [r7, #4]
  module->GIDLC = (uint32_t) CCU8_GIDLC_SPRB_Msk;
 802531c:	687b      	ldr	r3, [r7, #4]
 802531e:	f44f 7280 	mov.w	r2, #256	; 0x100
 8025322:	60da      	str	r2, [r3, #12]
}
 8025324:	bf00      	nop
 8025326:	370c      	adds	r7, #12
 8025328:	46bd      	mov	sp, r7
 802532a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802532e:	4770      	bx	lr

08025330 <XMC_CCU8_SLICE_StopTimer>:
{
 8025330:	b480      	push	{r7}
 8025332:	b083      	sub	sp, #12
 8025334:	af00      	add	r7, sp, #0
 8025336:	6078      	str	r0, [r7, #4]
  slice->TCCLR = (uint32_t) CCU8_CC8_TCCLR_TRBC_Msk;
 8025338:	687b      	ldr	r3, [r7, #4]
 802533a:	2201      	movs	r2, #1
 802533c:	611a      	str	r2, [r3, #16]
}
 802533e:	bf00      	nop
 8025340:	370c      	adds	r7, #12
 8025342:	46bd      	mov	sp, r7
 8025344:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025348:	4770      	bx	lr
	...

0802534c <XMC_CCU8_lDeassertReset>:
    XMC_ASSERT("XMC_CCU8_lAssertReset:Invalid Module Pointer", 0);
  }
}

__STATIC_INLINE void XMC_CCU8_lDeassertReset(const XMC_CCU8_MODULE_t *const module)
{
 802534c:	b580      	push	{r7, lr}
 802534e:	b082      	sub	sp, #8
 8025350:	af00      	add	r7, sp, #0
 8025352:	6078      	str	r0, [r7, #4]
  if (module == CCU80)
 8025354:	687b      	ldr	r3, [r7, #4]
 8025356:	4a09      	ldr	r2, [pc, #36]	; (802537c <XMC_CCU8_lDeassertReset+0x30>)
 8025358:	4293      	cmp	r3, r2
 802535a:	d103      	bne.n	8025364 <XMC_CCU8_lDeassertReset+0x18>
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU80);
 802535c:	2080      	movs	r0, #128	; 0x80
 802535e:	f7fe fc87 	bl	8023c70 <XMC_SCU_RESET_DeassertPeripheralReset>
#endif
  else
  {
    XMC_ASSERT("XMC_CCU8_lDeassertReset:Invalid Module Pointer", 0);
  }
}
 8025362:	e007      	b.n	8025374 <XMC_CCU8_lDeassertReset+0x28>
  else if (module == CCU81)
 8025364:	687b      	ldr	r3, [r7, #4]
 8025366:	4a06      	ldr	r2, [pc, #24]	; (8025380 <XMC_CCU8_lDeassertReset+0x34>)
 8025368:	4293      	cmp	r3, r2
 802536a:	d103      	bne.n	8025374 <XMC_CCU8_lDeassertReset+0x28>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU81);
 802536c:	f44f 7080 	mov.w	r0, #256	; 0x100
 8025370:	f7fe fc7e 	bl	8023c70 <XMC_SCU_RESET_DeassertPeripheralReset>
}
 8025374:	bf00      	nop
 8025376:	3708      	adds	r7, #8
 8025378:	46bd      	mov	sp, r7
 802537a:	bd80      	pop	{r7, pc}
 802537c:	40020000 	.word	0x40020000
 8025380:	40024000 	.word	0x40024000

08025384 <XMC_CCU8_lUngateClock>:
    XMC_ASSERT("XMC_CCU8_lGateClock:Invalid Module Pointer", 0);
  }
}

__STATIC_INLINE void XMC_CCU8_lUngateClock(XMC_CCU8_MODULE_t *const module)
{
 8025384:	b580      	push	{r7, lr}
 8025386:	b082      	sub	sp, #8
 8025388:	af00      	add	r7, sp, #0
 802538a:	6078      	str	r0, [r7, #4]
  if (module == CCU80)
 802538c:	687b      	ldr	r3, [r7, #4]
 802538e:	4a09      	ldr	r2, [pc, #36]	; (80253b4 <XMC_CCU8_lUngateClock+0x30>)
 8025390:	4293      	cmp	r3, r2
 8025392:	d103      	bne.n	802539c <XMC_CCU8_lUngateClock+0x18>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU80);
 8025394:	2080      	movs	r0, #128	; 0x80
 8025396:	f7fe fdc1 	bl	8023f1c <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
  else
  {
    XMC_ASSERT("XMC_CCU8_lUngateClock:Invalid Module Pointer", 0);
  }
}
 802539a:	e007      	b.n	80253ac <XMC_CCU8_lUngateClock+0x28>
  else if (module == CCU81)
 802539c:	687b      	ldr	r3, [r7, #4]
 802539e:	4a06      	ldr	r2, [pc, #24]	; (80253b8 <XMC_CCU8_lUngateClock+0x34>)
 80253a0:	4293      	cmp	r3, r2
 80253a2:	d103      	bne.n	80253ac <XMC_CCU8_lUngateClock+0x28>
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU81);
 80253a4:	f44f 7080 	mov.w	r0, #256	; 0x100
 80253a8:	f7fe fdb8 	bl	8023f1c <XMC_SCU_CLOCK_UngatePeripheralClock>
}
 80253ac:	bf00      	nop
 80253ae:	3708      	adds	r7, #8
 80253b0:	46bd      	mov	sp, r7
 80253b2:	bd80      	pop	{r7, pc}
 80253b4:	40020000 	.word	0x40020000
 80253b8:	40024000 	.word	0x40024000

080253bc <XMC_CCU8_EnableModule>:
 * API IMPLEMENTATION
 ********************************************************************************************************************/

/* API to set the CCU8 module as active and enable the clock  */
void XMC_CCU8_EnableModule(XMC_CCU8_MODULE_t *const module)
{
 80253bc:	b580      	push	{r7, lr}
 80253be:	b082      	sub	sp, #8
 80253c0:	af00      	add	r7, sp, #0
 80253c2:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU8_EnableModule:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));

#if (UC_FAMILY == XMC4)
  /* Enable CCU8 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 80253c4:	2010      	movs	r0, #16
 80253c6:	f7fe fd99 	bl	8023efc <XMC_SCU_CLOCK_EnableClock>
#endif

#if defined(CLOCK_GATING_SUPPORTED)
  XMC_CCU8_lUngateClock(module);
 80253ca:	6878      	ldr	r0, [r7, #4]
 80253cc:	f7ff ffda 	bl	8025384 <XMC_CCU8_lUngateClock>
#endif

#if defined(PERIPHERAL_RESET_SUPPORTED)
  XMC_CCU8_lDeassertReset(module);
 80253d0:	6878      	ldr	r0, [r7, #4]
 80253d2:	f7ff ffbb 	bl	802534c <XMC_CCU8_lDeassertReset>
#endif
}
 80253d6:	bf00      	nop
 80253d8:	3708      	adds	r7, #8
 80253da:	46bd      	mov	sp, r7
 80253dc:	bd80      	pop	{r7, pc}

080253de <XMC_CCU8_Init>:
#endif
}

/* API to initialize CCU8 global resources  */
void XMC_CCU8_Init(XMC_CCU8_MODULE_t *const module, const XMC_CCU8_SLICE_MCMS_ACTION_t mcs_action)
{
 80253de:	b580      	push	{r7, lr}
 80253e0:	b084      	sub	sp, #16
 80253e2:	af00      	add	r7, sp, #0
 80253e4:	6078      	str	r0, [r7, #4]
 80253e6:	460b      	mov	r3, r1
 80253e8:	70fb      	strb	r3, [r7, #3]

  XMC_ASSERT("XMC_CCU8_Init:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  XMC_ASSERT("XMC_CCU8_Init:Invalid mcs action", XMC_CCU8_SLICE_CHECK_MCS_ACTION(mcs_action));

  /* Enable CCU8 module */
  XMC_CCU8_EnableModule(module);
 80253ea:	6878      	ldr	r0, [r7, #4]
 80253ec:	f7ff ffe6 	bl	80253bc <XMC_CCU8_EnableModule>
  /* Start the prescaler */
  XMC_CCU8_StartPrescaler(module);
 80253f0:	6878      	ldr	r0, [r7, #4]
 80253f2:	f7ff ff8f 	bl	8025314 <XMC_CCU8_StartPrescaler>

  gctrl = module->GCTRL;
 80253f6:	687b      	ldr	r3, [r7, #4]
 80253f8:	681b      	ldr	r3, [r3, #0]
 80253fa:	60fb      	str	r3, [r7, #12]
  gctrl &= ~((uint32_t) CCU8_GCTRL_MSDE_Msk);
 80253fc:	68fb      	ldr	r3, [r7, #12]
 80253fe:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8025402:	60fb      	str	r3, [r7, #12]
  gctrl |= (uint32_t)mcs_action << CCU8_GCTRL_MSDE_Pos;
 8025404:	78fb      	ldrb	r3, [r7, #3]
 8025406:	039b      	lsls	r3, r3, #14
 8025408:	68fa      	ldr	r2, [r7, #12]
 802540a:	4313      	orrs	r3, r2
 802540c:	60fb      	str	r3, [r7, #12]

  module->GCTRL = gctrl;
 802540e:	687b      	ldr	r3, [r7, #4]
 8025410:	68fa      	ldr	r2, [r7, #12]
 8025412:	601a      	str	r2, [r3, #0]
}
 8025414:	bf00      	nop
 8025416:	3710      	adds	r7, #16
 8025418:	46bd      	mov	sp, r7
 802541a:	bd80      	pop	{r7, pc}

0802541c <XMC_CCU8_SLICE_CompareInit>:
}

/* API to configure CC8 Slice in Compare mode */
void XMC_CCU8_SLICE_CompareInit(XMC_CCU8_SLICE_t *const slice,
                                const XMC_CCU8_SLICE_COMPARE_CONFIG_t *const compare_init)
{
 802541c:	b580      	push	{r7, lr}
 802541e:	b082      	sub	sp, #8
 8025420:	af00      	add	r7, sp, #0
 8025422:	6078      	str	r0, [r7, #4]
 8025424:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU8_SLICE_CompareInit:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_CompareInit:Timer Init Pointer is NULL",
             (XMC_CCU8_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);
  /* Stops the timer */
  XMC_CCU8_SLICE_StopTimer(slice);
 8025426:	6878      	ldr	r0, [r7, #4]
 8025428:	f7ff ff82 	bl	8025330 <XMC_CCU8_SLICE_StopTimer>
  /* Program the timer mode */
  slice->TC = compare_init->tc;
 802542c:	683b      	ldr	r3, [r7, #0]
 802542e:	681a      	ldr	r2, [r3, #0]
 8025430:	687b      	ldr	r3, [r7, #4]
 8025432:	615a      	str	r2, [r3, #20]
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
 8025434:	683b      	ldr	r3, [r7, #0]
 8025436:	7b5b      	ldrb	r3, [r3, #13]
 8025438:	f3c3 1300 	ubfx	r3, r3, #4, #1
 802543c:	b2db      	uxtb	r3, r3
 802543e:	051a      	lsls	r2, r3, #20
 8025440:	687b      	ldr	r3, [r7, #4]
 8025442:	605a      	str	r2, [r3, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 8025444:	683b      	ldr	r3, [r7, #0]
 8025446:	7b1b      	ldrb	r3, [r3, #12]
 8025448:	f3c3 0303 	ubfx	r3, r3, #0, #4
 802544c:	b2db      	uxtb	r3, r3
 802544e:	461a      	mov	r2, r3
 8025450:	687b      	ldr	r3, [r7, #4]
 8025452:	625a      	str	r2, [r3, #36]	; 0x24
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 8025454:	683b      	ldr	r3, [r7, #0]
 8025456:	7b1b      	ldrb	r3, [r3, #12]
 8025458:	f3c3 1303 	ubfx	r3, r3, #4, #4
 802545c:	b2db      	uxtb	r3, r3
 802545e:	461a      	mov	r2, r3
 8025460:	687b      	ldr	r3, [r7, #4]
 8025462:	62da      	str	r2, [r3, #44]	; 0x2c
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 8025464:	683b      	ldr	r3, [r7, #0]
 8025466:	7b5b      	ldrb	r3, [r3, #13]
 8025468:	f3c3 0303 	ubfx	r3, r3, #0, #4
 802546c:	b2db      	uxtb	r3, r3
 802546e:	461a      	mov	r2, r3
 8025470:	687b      	ldr	r3, [r7, #4]
 8025472:	621a      	str	r2, [r3, #32]
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->psl;
 8025474:	683b      	ldr	r3, [r7, #0]
 8025476:	685a      	ldr	r2, [r3, #4]
 8025478:	687b      	ldr	r3, [r7, #4]
 802547a:	619a      	str	r2, [r3, #24]
  /* Asymmetric PWM and Slice output routing configuration */
#if defined(CCU8V3) /* Defined for XMC1400 devices only */
  slice->CHC = (uint32_t) compare_init->chc;
#else
  slice->CHC = (uint32_t)((uint32_t)compare_init->chc ^ XMC_CCU8_SLICE_CHC_CONFIG_MASK);
 802547c:	683b      	ldr	r3, [r7, #0]
 802547e:	689b      	ldr	r3, [r3, #8]
 8025480:	f083 0214 	eor.w	r2, r3, #20
 8025484:	687b      	ldr	r3, [r7, #4]
 8025486:	649a      	str	r2, [r3, #72]	; 0x48
#endif
}
 8025488:	bf00      	nop
 802548a:	3708      	adds	r7, #8
 802548c:	46bd      	mov	sp, r7
 802548e:	bd80      	pop	{r7, pc}

08025490 <XMC_CCU8_SLICE_StartConfig>:

/* API to configure the Start trigger function of a slice*/
void XMC_CCU8_SLICE_StartConfig(XMC_CCU8_SLICE_t *const slice,
                                const XMC_CCU8_SLICE_EVENT_t event,
                                const XMC_CCU8_SLICE_START_MODE_t start_mode)
{
 8025490:	b480      	push	{r7}
 8025492:	b085      	sub	sp, #20
 8025494:	af00      	add	r7, sp, #0
 8025496:	6078      	str	r0, [r7, #4]
 8025498:	460b      	mov	r3, r1
 802549a:	70fb      	strb	r3, [r7, #3]
 802549c:	4613      	mov	r3, r2
 802549e:	70bb      	strb	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU8_SLICE_StartConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_StartConfig:Invalid Event ID", XMC_CCU8_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU8_SLICE_StartConfig:Invalid Start Mode",
             ((start_mode == XMC_CCU8_SLICE_START_MODE_TIMER_START) || \
              (start_mode == XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR)));
  cmc = slice->CMC;
 80254a0:	687b      	ldr	r3, [r7, #4]
 80254a2:	685b      	ldr	r3, [r3, #4]
 80254a4:	60bb      	str	r3, [r7, #8]

  cmc &= ~((uint32_t) CCU8_CC8_CMC_STRTS_Msk);
 80254a6:	68bb      	ldr	r3, [r7, #8]
 80254a8:	f023 0303 	bic.w	r3, r3, #3
 80254ac:	60bb      	str	r3, [r7, #8]
  cmc |= ((uint32_t) event) << CCU8_CC8_CMC_STRTS_Pos;
 80254ae:	78fb      	ldrb	r3, [r7, #3]
 80254b0:	68ba      	ldr	r2, [r7, #8]
 80254b2:	4313      	orrs	r3, r2
 80254b4:	60bb      	str	r3, [r7, #8]

  slice->CMC = cmc;
 80254b6:	687b      	ldr	r3, [r7, #4]
 80254b8:	68ba      	ldr	r2, [r7, #8]
 80254ba:	605a      	str	r2, [r3, #4]

  tc  = slice->TC;
 80254bc:	687b      	ldr	r3, [r7, #4]
 80254be:	695b      	ldr	r3, [r3, #20]
 80254c0:	60fb      	str	r3, [r7, #12]

  if (start_mode == XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR)
 80254c2:	78bb      	ldrb	r3, [r7, #2]
 80254c4:	2b01      	cmp	r3, #1
 80254c6:	d104      	bne.n	80254d2 <XMC_CCU8_SLICE_StartConfig+0x42>
  {
    tc |= (uint32_t) CCU8_CC8_TC_STRM_Msk;
 80254c8:	68fb      	ldr	r3, [r7, #12]
 80254ca:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80254ce:	60fb      	str	r3, [r7, #12]
 80254d0:	e003      	b.n	80254da <XMC_CCU8_SLICE_StartConfig+0x4a>
  }
  else
  {
    tc &= ~((uint32_t) CCU8_CC8_TC_STRM_Msk);
 80254d2:	68fb      	ldr	r3, [r7, #12]
 80254d4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80254d8:	60fb      	str	r3, [r7, #12]
  }

  slice->TC = tc;
 80254da:	687b      	ldr	r3, [r7, #4]
 80254dc:	68fa      	ldr	r2, [r7, #12]
 80254de:	615a      	str	r2, [r3, #20]
}
 80254e0:	bf00      	nop
 80254e2:	3714      	adds	r7, #20
 80254e4:	46bd      	mov	sp, r7
 80254e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80254ea:	4770      	bx	lr

080254ec <XMC_CCU8_SLICE_StopConfig>:

/* API to configure the Stop trigger function of a slice */
void XMC_CCU8_SLICE_StopConfig(XMC_CCU8_SLICE_t *const slice,
                               const XMC_CCU8_SLICE_EVENT_t event,
                               const XMC_CCU8_SLICE_END_MODE_t end_mode)
{
 80254ec:	b480      	push	{r7}
 80254ee:	b085      	sub	sp, #20
 80254f0:	af00      	add	r7, sp, #0
 80254f2:	6078      	str	r0, [r7, #4]
 80254f4:	460b      	mov	r3, r1
 80254f6:	70fb      	strb	r3, [r7, #3]
 80254f8:	4613      	mov	r3, r2
 80254fa:	70bb      	strb	r3, [r7, #2]

  XMC_ASSERT("XMC_CCU8_SLICE_StopConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_StopConfig:Invalid Event ID", XMC_CCU8_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU8_SLICE_StopConfig:Invalid End Mode", XMC_CCU8_SLICE_CHECK_END_MODE(end_mode));

  cmc = slice->CMC;
 80254fc:	687b      	ldr	r3, [r7, #4]
 80254fe:	685b      	ldr	r3, [r3, #4]
 8025500:	60fb      	str	r3, [r7, #12]
  /* First, Bind the event with the stop function */
  cmc &= ~((uint32_t) CCU8_CC8_CMC_ENDS_Msk);
 8025502:	68fb      	ldr	r3, [r7, #12]
 8025504:	f023 030c 	bic.w	r3, r3, #12
 8025508:	60fb      	str	r3, [r7, #12]
  cmc |= ((uint32_t) event) << CCU8_CC8_CMC_ENDS_Pos;
 802550a:	78fb      	ldrb	r3, [r7, #3]
 802550c:	009b      	lsls	r3, r3, #2
 802550e:	68fa      	ldr	r2, [r7, #12]
 8025510:	4313      	orrs	r3, r2
 8025512:	60fb      	str	r3, [r7, #12]

  slice->CMC = cmc;
 8025514:	687b      	ldr	r3, [r7, #4]
 8025516:	68fa      	ldr	r2, [r7, #12]
 8025518:	605a      	str	r2, [r3, #4]

  /* Configure the stop mode */
  tc = slice->TC;
 802551a:	687b      	ldr	r3, [r7, #4]
 802551c:	695b      	ldr	r3, [r3, #20]
 802551e:	60bb      	str	r3, [r7, #8]
  tc &= ~((uint32_t) CCU8_CC8_TC_ENDM_Msk);
 8025520:	68bb      	ldr	r3, [r7, #8]
 8025522:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8025526:	60bb      	str	r3, [r7, #8]
  tc |= ((uint32_t) end_mode) << CCU8_CC8_TC_ENDM_Pos;
 8025528:	78bb      	ldrb	r3, [r7, #2]
 802552a:	021b      	lsls	r3, r3, #8
 802552c:	68ba      	ldr	r2, [r7, #8]
 802552e:	4313      	orrs	r3, r2
 8025530:	60bb      	str	r3, [r7, #8]

  slice->TC = tc;
 8025532:	687b      	ldr	r3, [r7, #4]
 8025534:	68ba      	ldr	r2, [r7, #8]
 8025536:	615a      	str	r2, [r3, #20]
}
 8025538:	bf00      	nop
 802553a:	3714      	adds	r7, #20
 802553c:	46bd      	mov	sp, r7
 802553e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025542:	4770      	bx	lr

08025544 <XMC_CCU8_SLICE_ConfigureEvent>:

/* API to configure a slice trigger event */
void XMC_CCU8_SLICE_ConfigureEvent(XMC_CCU8_SLICE_t *const slice,
                                   const XMC_CCU8_SLICE_EVENT_t event,
                                   const XMC_CCU8_SLICE_EVENT_CONFIG_t *const config)
{
 8025544:	b480      	push	{r7}
 8025546:	b089      	sub	sp, #36	; 0x24
 8025548:	af00      	add	r7, sp, #0
 802554a:	60f8      	str	r0, [r7, #12]
 802554c:	460b      	mov	r3, r1
 802554e:	607a      	str	r2, [r7, #4]
 8025550:	72fb      	strb	r3, [r7, #11]
              (config->level == XMC_CCU8_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_LOW)));
  XMC_ASSERT("XMC_CCU8_SLICE_ConfigureEvent:Invalid Debounce Period",
             XMC_CCU8_SLICE_CHECK_EVENT_FILTER(config->duration));

  /* Calculate offset with reference to event */
  offset = ((uint8_t) event) - 1U;
 8025552:	7afb      	ldrb	r3, [r7, #11]
 8025554:	3b01      	subs	r3, #1
 8025556:	77fb      	strb	r3, [r7, #31]
  ins |= ((uint32_t) config->mapped_input) << pos;

  slice->INS1 = ins;

#else
  ins = slice->INS;
 8025558:	68fb      	ldr	r3, [r7, #12]
 802555a:	681b      	ldr	r3, [r3, #0]
 802555c:	61bb      	str	r3, [r7, #24]

  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU8_CC8_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
 802555e:	7ffb      	ldrb	r3, [r7, #31]
 8025560:	005b      	lsls	r3, r3, #1
 8025562:	b2db      	uxtb	r3, r3
 8025564:	3310      	adds	r3, #16
 8025566:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
 8025568:	7dfb      	ldrb	r3, [r7, #23]
 802556a:	2203      	movs	r2, #3
 802556c:	fa02 f303 	lsl.w	r3, r2, r3
 8025570:	43db      	mvns	r3, r3
 8025572:	69ba      	ldr	r2, [r7, #24]
 8025574:	4013      	ands	r3, r2
 8025576:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) config->edge) << pos;
 8025578:	687b      	ldr	r3, [r7, #4]
 802557a:	785b      	ldrb	r3, [r3, #1]
 802557c:	461a      	mov	r2, r3
 802557e:	7dfb      	ldrb	r3, [r7, #23]
 8025580:	fa02 f303 	lsl.w	r3, r2, r3
 8025584:	69ba      	ldr	r2, [r7, #24]
 8025586:	4313      	orrs	r3, r2
 8025588:	61bb      	str	r3, [r7, #24]

  /* Next, the level */
  pos = ((uint8_t) CCU8_CC8_INS_EV0LM_Pos) + offset;
 802558a:	7ffb      	ldrb	r3, [r7, #31]
 802558c:	3316      	adds	r3, #22
 802558e:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
 8025590:	7dfb      	ldrb	r3, [r7, #23]
 8025592:	2201      	movs	r2, #1
 8025594:	fa02 f303 	lsl.w	r3, r2, r3
 8025598:	43db      	mvns	r3, r3
 802559a:	69ba      	ldr	r2, [r7, #24]
 802559c:	4013      	ands	r3, r2
 802559e:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) (config->level)) << pos;
 80255a0:	687b      	ldr	r3, [r7, #4]
 80255a2:	789b      	ldrb	r3, [r3, #2]
 80255a4:	461a      	mov	r2, r3
 80255a6:	7dfb      	ldrb	r3, [r7, #23]
 80255a8:	fa02 f303 	lsl.w	r3, r2, r3
 80255ac:	69ba      	ldr	r2, [r7, #24]
 80255ae:	4313      	orrs	r3, r2
 80255b0:	61bb      	str	r3, [r7, #24]

  /* Next, the debounce filter */
  pos = ((uint8_t) CCU8_CC8_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
 80255b2:	7ffb      	ldrb	r3, [r7, #31]
 80255b4:	005b      	lsls	r3, r3, #1
 80255b6:	b2db      	uxtb	r3, r3
 80255b8:	3319      	adds	r3, #25
 80255ba:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
 80255bc:	7dfb      	ldrb	r3, [r7, #23]
 80255be:	2203      	movs	r2, #3
 80255c0:	fa02 f303 	lsl.w	r3, r2, r3
 80255c4:	43db      	mvns	r3, r3
 80255c6:	69ba      	ldr	r2, [r7, #24]
 80255c8:	4013      	ands	r3, r2
 80255ca:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) config->duration) << pos;
 80255cc:	687b      	ldr	r3, [r7, #4]
 80255ce:	78db      	ldrb	r3, [r3, #3]
 80255d0:	461a      	mov	r2, r3
 80255d2:	7dfb      	ldrb	r3, [r7, #23]
 80255d4:	fa02 f303 	lsl.w	r3, r2, r3
 80255d8:	69ba      	ldr	r2, [r7, #24]
 80255da:	4313      	orrs	r3, r2
 80255dc:	61bb      	str	r3, [r7, #24]

  /* Finally the input */
  pos = ((uint8_t) CCU8_CC8_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
 80255de:	7ffb      	ldrb	r3, [r7, #31]
 80255e0:	009b      	lsls	r3, r3, #2
 80255e2:	75fb      	strb	r3, [r7, #23]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
 80255e4:	7dfb      	ldrb	r3, [r7, #23]
 80255e6:	220f      	movs	r2, #15
 80255e8:	fa02 f303 	lsl.w	r3, r2, r3
 80255ec:	43db      	mvns	r3, r3
 80255ee:	69ba      	ldr	r2, [r7, #24]
 80255f0:	4013      	ands	r3, r2
 80255f2:	61bb      	str	r3, [r7, #24]
  ins |= ((uint32_t) config->mapped_input) << pos;
 80255f4:	687b      	ldr	r3, [r7, #4]
 80255f6:	781b      	ldrb	r3, [r3, #0]
 80255f8:	461a      	mov	r2, r3
 80255fa:	7dfb      	ldrb	r3, [r7, #23]
 80255fc:	fa02 f303 	lsl.w	r3, r2, r3
 8025600:	69ba      	ldr	r2, [r7, #24]
 8025602:	4313      	orrs	r3, r2
 8025604:	61bb      	str	r3, [r7, #24]

  slice->INS = ins;
 8025606:	68fb      	ldr	r3, [r7, #12]
 8025608:	69ba      	ldr	r2, [r7, #24]
 802560a:	601a      	str	r2, [r3, #0]
#endif
}
 802560c:	bf00      	nop
 802560e:	3724      	adds	r7, #36	; 0x24
 8025610:	46bd      	mov	sp, r7
 8025612:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025616:	4770      	bx	lr

08025618 <XMC_CCU8_SLICE_SetTimerPeriodMatch>:
  slice->TC = tc;
}

/* Programs period match value of the timer  */
void XMC_CCU8_SLICE_SetTimerPeriodMatch(XMC_CCU8_SLICE_t *const slice, const uint16_t period_val)
{
 8025618:	b480      	push	{r7}
 802561a:	b083      	sub	sp, #12
 802561c:	af00      	add	r7, sp, #0
 802561e:	6078      	str	r0, [r7, #4]
 8025620:	460b      	mov	r3, r1
 8025622:	807b      	strh	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 8025624:	887a      	ldrh	r2, [r7, #2]
 8025626:	687b      	ldr	r3, [r7, #4]
 8025628:	635a      	str	r2, [r3, #52]	; 0x34
}
 802562a:	bf00      	nop
 802562c:	370c      	adds	r7, #12
 802562e:	46bd      	mov	sp, r7
 8025630:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025634:	4770      	bx	lr

08025636 <XMC_CCU8_SLICE_SetTimerCompareMatch>:

/* Programs timer compare match value for channel 1 or 2 */
void XMC_CCU8_SLICE_SetTimerCompareMatch(XMC_CCU8_SLICE_t *const slice,
    const XMC_CCU8_SLICE_COMPARE_CHANNEL_t channel,
    const uint16_t compare_val)
{
 8025636:	b480      	push	{r7}
 8025638:	b083      	sub	sp, #12
 802563a:	af00      	add	r7, sp, #0
 802563c:	6078      	str	r0, [r7, #4]
 802563e:	460b      	mov	r3, r1
 8025640:	70fb      	strb	r3, [r7, #3]
 8025642:	4613      	mov	r3, r2
 8025644:	803b      	strh	r3, [r7, #0]
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatch:Invalid channel", XMC_CCU8_SLICE_CHECK_COMP_CHANNEL(channel));

  if (XMC_CCU8_SLICE_COMPARE_CHANNEL_1 == channel)
 8025646:	78fb      	ldrb	r3, [r7, #3]
 8025648:	2b00      	cmp	r3, #0
 802564a:	d103      	bne.n	8025654 <XMC_CCU8_SLICE_SetTimerCompareMatch+0x1e>
  {
    slice->CR1S = (uint32_t) compare_val;
 802564c:	883a      	ldrh	r2, [r7, #0]
 802564e:	687b      	ldr	r3, [r7, #4]
 8025650:	63da      	str	r2, [r3, #60]	; 0x3c
  }
  else
  {
    slice->CR2S = (uint32_t) compare_val;
  }
}
 8025652:	e002      	b.n	802565a <XMC_CCU8_SLICE_SetTimerCompareMatch+0x24>
    slice->CR2S = (uint32_t) compare_val;
 8025654:	883a      	ldrh	r2, [r7, #0]
 8025656:	687b      	ldr	r3, [r7, #4]
 8025658:	645a      	str	r2, [r3, #68]	; 0x44
}
 802565a:	bf00      	nop
 802565c:	370c      	adds	r7, #12
 802565e:	46bd      	mov	sp, r7
 8025660:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025664:	4770      	bx	lr
	...

08025668 <XMC_CCU8_SLICE_SetInterruptNode>:

/* Binds a capcom event to an NVIC node  */
void XMC_CCU8_SLICE_SetInterruptNode(XMC_CCU8_SLICE_t *const slice,
                                     const XMC_CCU8_SLICE_IRQ_ID_t event,
                                     const XMC_CCU8_SLICE_SR_ID_t sr)
{
 8025668:	b480      	push	{r7}
 802566a:	b087      	sub	sp, #28
 802566c:	af00      	add	r7, sp, #0
 802566e:	6078      	str	r0, [r7, #4]
 8025670:	460b      	mov	r3, r1
 8025672:	70fb      	strb	r3, [r7, #3]
 8025674:	4613      	mov	r3, r2
 8025676:	70bb      	strb	r3, [r7, #2]

  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU8_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  switch (event)
 8025678:	78fb      	ldrb	r3, [r7, #3]
 802567a:	2b0b      	cmp	r3, #11
 802567c:	d83b      	bhi.n	80256f6 <XMC_CCU8_SLICE_SetInterruptNode+0x8e>
 802567e:	a201      	add	r2, pc, #4	; (adr r2, 8025684 <XMC_CCU8_SLICE_SetInterruptNode+0x1c>)
 8025680:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8025684:	080256b5 	.word	0x080256b5
 8025688:	080256b5 	.word	0x080256b5
 802568c:	080256bf 	.word	0x080256bf
 8025690:	080256bf 	.word	0x080256bf
 8025694:	080256c9 	.word	0x080256c9
 8025698:	080256c9 	.word	0x080256c9
 802569c:	080256f7 	.word	0x080256f7
 80256a0:	080256f7 	.word	0x080256f7
 80256a4:	080256d3 	.word	0x080256d3
 80256a8:	080256df 	.word	0x080256df
 80256ac:	080256eb 	.word	0x080256eb
 80256b0:	080256eb 	.word	0x080256eb
  {
    case XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH:
    case XMC_CCU8_SLICE_IRQ_ID_ONE_MATCH:
      mask = ((uint32_t) CCU8_CC8_SRS_POSR_Msk);
 80256b4:	2303      	movs	r3, #3
 80256b6:	617b      	str	r3, [r7, #20]
      pos  = CCU8_CC8_SRS_POSR_Pos;
 80256b8:	2300      	movs	r3, #0
 80256ba:	613b      	str	r3, [r7, #16]
      break;
 80256bc:	e020      	b.n	8025700 <XMC_CCU8_SLICE_SetInterruptNode+0x98>

    case XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_1:
    case XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_1:
      mask = ((uint32_t) CCU8_CC8_SRS_CM1SR_Msk);
 80256be:	230c      	movs	r3, #12
 80256c0:	617b      	str	r3, [r7, #20]
      pos  = CCU8_CC8_SRS_CM1SR_Pos;
 80256c2:	2302      	movs	r3, #2
 80256c4:	613b      	str	r3, [r7, #16]
      break;
 80256c6:	e01b      	b.n	8025700 <XMC_CCU8_SLICE_SetInterruptNode+0x98>

    case XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_2:
    case XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_2:
      mask = ((uint32_t) CCU8_CC8_SRS_CM2SR_Msk);
 80256c8:	2330      	movs	r3, #48	; 0x30
 80256ca:	617b      	str	r3, [r7, #20]
      pos  = CCU8_CC8_SRS_CM2SR_Pos;
 80256cc:	2304      	movs	r3, #4
 80256ce:	613b      	str	r3, [r7, #16]
      break;
 80256d0:	e016      	b.n	8025700 <XMC_CCU8_SLICE_SetInterruptNode+0x98>

    case XMC_CCU8_SLICE_IRQ_ID_EVENT0:
      mask = ((uint32_t) CCU8_CC8_SRS_E0SR_Msk);
 80256d2:	f44f 7340 	mov.w	r3, #768	; 0x300
 80256d6:	617b      	str	r3, [r7, #20]
      pos  = CCU8_CC8_SRS_E0SR_Pos;
 80256d8:	2308      	movs	r3, #8
 80256da:	613b      	str	r3, [r7, #16]
      break;
 80256dc:	e010      	b.n	8025700 <XMC_CCU8_SLICE_SetInterruptNode+0x98>

    case XMC_CCU8_SLICE_IRQ_ID_EVENT1:
      mask = ((uint32_t) CCU8_CC8_SRS_E1SR_Msk);
 80256de:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 80256e2:	617b      	str	r3, [r7, #20]
      pos  = CCU8_CC8_SRS_E1SR_Pos;
 80256e4:	230a      	movs	r3, #10
 80256e6:	613b      	str	r3, [r7, #16]
      break;
 80256e8:	e00a      	b.n	8025700 <XMC_CCU8_SLICE_SetInterruptNode+0x98>

    case XMC_CCU8_SLICE_IRQ_ID_EVENT2:
    case XMC_CCU8_SLICE_IRQ_ID_TRAP:
      mask = ((uint32_t) CCU8_CC8_SRS_E2SR_Msk);
 80256ea:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 80256ee:	617b      	str	r3, [r7, #20]
      pos  = CCU8_CC8_SRS_E2SR_Pos;
 80256f0:	230c      	movs	r3, #12
 80256f2:	613b      	str	r3, [r7, #16]
      break;
 80256f4:	e004      	b.n	8025700 <XMC_CCU8_SLICE_SetInterruptNode+0x98>
	  
	default:
	  mask = 0;
 80256f6:	2300      	movs	r3, #0
 80256f8:	617b      	str	r3, [r7, #20]
	  pos = 0;
 80256fa:	2300      	movs	r3, #0
 80256fc:	613b      	str	r3, [r7, #16]
	  break;
 80256fe:	bf00      	nop
  }

  if (mask != 0)
 8025700:	697b      	ldr	r3, [r7, #20]
 8025702:	2b00      	cmp	r3, #0
 8025704:	d013      	beq.n	802572e <XMC_CCU8_SLICE_SetInterruptNode+0xc6>
  {
    srs = slice->SRS;
 8025706:	687b      	ldr	r3, [r7, #4]
 8025708:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 802570c:	60fb      	str	r3, [r7, #12]
    srs &= ~mask;
 802570e:	697b      	ldr	r3, [r7, #20]
 8025710:	43db      	mvns	r3, r3
 8025712:	68fa      	ldr	r2, [r7, #12]
 8025714:	4013      	ands	r3, r2
 8025716:	60fb      	str	r3, [r7, #12]
    srs |= (uint32_t)sr << pos;
 8025718:	78ba      	ldrb	r2, [r7, #2]
 802571a:	693b      	ldr	r3, [r7, #16]
 802571c:	fa02 f303 	lsl.w	r3, r2, r3
 8025720:	68fa      	ldr	r2, [r7, #12]
 8025722:	4313      	orrs	r3, r2
 8025724:	60fb      	str	r3, [r7, #12]
    slice->SRS = srs;
 8025726:	687b      	ldr	r3, [r7, #4]
 8025728:	68fa      	ldr	r2, [r7, #12]
 802572a:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
  }
}
 802572e:	bf00      	nop
 8025730:	371c      	adds	r7, #28
 8025732:	46bd      	mov	sp, r7
 8025734:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025738:	4770      	bx	lr
 802573a:	bf00      	nop

0802573c <XMC_CCU8_SLICE_DeadTimeInit>:
}

/* Initializes Dead time configuration for the slice outputs */
void XMC_CCU8_SLICE_DeadTimeInit(XMC_CCU8_SLICE_t *const slice,
                                 const XMC_CCU8_SLICE_DEAD_TIME_CONFIG_t *const config)
{
 802573c:	b480      	push	{r7}
 802573e:	b083      	sub	sp, #12
 8025740:	af00      	add	r7, sp, #0
 8025742:	6078      	str	r0, [r7, #4]
 8025744:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU8_SLICE_ConfigureDeadTime:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));

  /* Program dead time value for channel 1 */
  slice->DC1R = config->dc1r;
 8025746:	683b      	ldr	r3, [r7, #0]
 8025748:	685a      	ldr	r2, [r3, #4]
 802574a:	687b      	ldr	r3, [r7, #4]
 802574c:	651a      	str	r2, [r3, #80]	; 0x50
  /* Program dead time value for channel 2 */
  slice->DC2R = config->dc2r;
 802574e:	683b      	ldr	r3, [r7, #0]
 8025750:	689a      	ldr	r2, [r3, #8]
 8025752:	687b      	ldr	r3, [r7, #4]
 8025754:	655a      	str	r2, [r3, #84]	; 0x54
  /* Program dead time control configuration */
  slice->DTC = config->dtc;
 8025756:	683b      	ldr	r3, [r7, #0]
 8025758:	681a      	ldr	r2, [r3, #0]
 802575a:	687b      	ldr	r3, [r7, #4]
 802575c:	64da      	str	r2, [r3, #76]	; 0x4c
}
 802575e:	bf00      	nop
 8025760:	370c      	adds	r7, #12
 8025762:	46bd      	mov	sp, r7
 8025764:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025768:	4770      	bx	lr

0802576a <XMC_FCE_Init>:
/*
 * Initialize the FCE peripheral:
 * Update FCE configuration and initialize seed value
 */
XMC_FCE_STATUS_t XMC_FCE_Init(const XMC_FCE_t *const engine)
{
 802576a:	b480      	push	{r7}
 802576c:	b083      	sub	sp, #12
 802576e:	af00      	add	r7, sp, #0
 8025770:	6078      	str	r0, [r7, #4]
  engine->kernel_ptr->CFG = engine->fce_cfg_update.regval;
 8025772:	687b      	ldr	r3, [r7, #4]
 8025774:	681b      	ldr	r3, [r3, #0]
 8025776:	687a      	ldr	r2, [r7, #4]
 8025778:	6852      	ldr	r2, [r2, #4]
 802577a:	609a      	str	r2, [r3, #8]
  engine->kernel_ptr->CRC = engine->seedvalue;
 802577c:	687b      	ldr	r3, [r7, #4]
 802577e:	681b      	ldr	r3, [r3, #0]
 8025780:	687a      	ldr	r2, [r7, #4]
 8025782:	6892      	ldr	r2, [r2, #8]
 8025784:	619a      	str	r2, [r3, #24]

  return XMC_FCE_STATUS_OK;
 8025786:	2300      	movs	r3, #0
}
 8025788:	4618      	mov	r0, r3
 802578a:	370c      	adds	r7, #12
 802578c:	46bd      	mov	sp, r7
 802578e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025792:	4770      	bx	lr

08025794 <XMC_FCE_Enable>:

}

/* Enable FCE */
void XMC_FCE_Enable(void)
{
 8025794:	b580      	push	{r7, lr}
 8025796:	af00      	add	r7, sp, #0
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_FCE);
 8025798:	4806      	ldr	r0, [pc, #24]	; (80257b4 <XMC_FCE_Enable+0x20>)
 802579a:	f7fe fbbf 	bl	8023f1c <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif

  XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_FCE);
 802579e:	4805      	ldr	r0, [pc, #20]	; (80257b4 <XMC_FCE_Enable+0x20>)
 80257a0:	f7fe fa66 	bl	8023c70 <XMC_SCU_RESET_DeassertPeripheralReset>

  FCE->CLC &= (uint32_t)~FCE_CLC_DISR_Msk;
 80257a4:	4b04      	ldr	r3, [pc, #16]	; (80257b8 <XMC_FCE_Enable+0x24>)
 80257a6:	681b      	ldr	r3, [r3, #0]
 80257a8:	4a03      	ldr	r2, [pc, #12]	; (80257b8 <XMC_FCE_Enable+0x24>)
 80257aa:	f023 0301 	bic.w	r3, r3, #1
 80257ae:	6013      	str	r3, [r2, #0]
}
 80257b0:	bf00      	nop
 80257b2:	bd80      	pop	{r7, pc}
 80257b4:	20000040 	.word	0x20000040
 80257b8:	50020000 	.word	0x50020000

080257bc <XMC_FCE_CalculateCRC32>:
/* Calculate and return the IEEE 802.3 Ethernet CRC32 checksum */
XMC_FCE_STATUS_t XMC_FCE_CalculateCRC32(const XMC_FCE_t *const engine,
                                        const uint32_t *data,
                                        uint32_t length,
                                        uint32_t *result)
{
 80257bc:	b480      	push	{r7}
 80257be:	b087      	sub	sp, #28
 80257c0:	af00      	add	r7, sp, #0
 80257c2:	60f8      	str	r0, [r7, #12]
 80257c4:	60b9      	str	r1, [r7, #8]
 80257c6:	607a      	str	r2, [r7, #4]
 80257c8:	603b      	str	r3, [r7, #0]
  XMC_FCE_STATUS_t status = XMC_FCE_STATUS_OK;
 80257ca:	2300      	movs	r3, #0
 80257cc:	75fb      	strb	r3, [r7, #23]
             (engine->kernel_ptr == XMC_FCE_CRC32_1)));
  XMC_ASSERT("XMC_FCE_CalculateCRC32: Length field is empty", (length != 0));
  XMC_ASSERT("XMC_FCE_CalculateCRC32: Length is not aligned", ((length & 0x3U) == 0));

  /* Check length is a multiple of 4 */
  if ((length == 0) || ((length & 0x3U) != 0U))
 80257ce:	687b      	ldr	r3, [r7, #4]
 80257d0:	2b00      	cmp	r3, #0
 80257d2:	d004      	beq.n	80257de <XMC_FCE_CalculateCRC32+0x22>
 80257d4:	687b      	ldr	r3, [r7, #4]
 80257d6:	f003 0303 	and.w	r3, r3, #3
 80257da:	2b00      	cmp	r3, #0
 80257dc:	d00d      	beq.n	80257fa <XMC_FCE_CalculateCRC32+0x3e>
  {
    status = XMC_FCE_STATUS_ERROR;
 80257de:	2302      	movs	r3, #2
 80257e0:	75fb      	strb	r3, [r7, #23]
 80257e2:	e012      	b.n	802580a <XMC_FCE_CalculateCRC32+0x4e>
  }
  else
  {
    while (0UL != length)
    {
      engine->kernel_ptr->IR = *data;
 80257e4:	68fb      	ldr	r3, [r7, #12]
 80257e6:	681b      	ldr	r3, [r3, #0]
 80257e8:	68ba      	ldr	r2, [r7, #8]
 80257ea:	6812      	ldr	r2, [r2, #0]
 80257ec:	601a      	str	r2, [r3, #0]
      data++;
 80257ee:	68bb      	ldr	r3, [r7, #8]
 80257f0:	3304      	adds	r3, #4
 80257f2:	60bb      	str	r3, [r7, #8]
      length -= 4U;
 80257f4:	687b      	ldr	r3, [r7, #4]
 80257f6:	3b04      	subs	r3, #4
 80257f8:	607b      	str	r3, [r7, #4]
    while (0UL != length)
 80257fa:	687b      	ldr	r3, [r7, #4]
 80257fc:	2b00      	cmp	r3, #0
 80257fe:	d1f1      	bne.n	80257e4 <XMC_FCE_CalculateCRC32+0x28>
    }

    *result = engine->kernel_ptr->CRC;
 8025800:	68fb      	ldr	r3, [r7, #12]
 8025802:	681b      	ldr	r3, [r3, #0]
 8025804:	699a      	ldr	r2, [r3, #24]
 8025806:	683b      	ldr	r3, [r7, #0]
 8025808:	601a      	str	r2, [r3, #0]
  }

  return status;
 802580a:	7dfb      	ldrb	r3, [r7, #23]
}
 802580c:	4618      	mov	r0, r3
 802580e:	371c      	adds	r7, #28
 8025810:	46bd      	mov	sp, r7
 8025812:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025816:	4770      	bx	lr

08025818 <XMC_GPIO_SetHardwareControl>:
  port->IOCR[(uint32_t)pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U)));
  port->IOCR[(uint32_t)pin >> 2U] |= (uint32_t)mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
}

void XMC_GPIO_SetHardwareControl(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_HWCTRL_t hwctrl)
{
 8025818:	b480      	push	{r7}
 802581a:	b083      	sub	sp, #12
 802581c:	af00      	add	r7, sp, #0
 802581e:	6078      	str	r0, [r7, #4]
 8025820:	460b      	mov	r3, r1
 8025822:	70fb      	strb	r3, [r7, #3]
 8025824:	4613      	mov	r3, r2
 8025826:	70bb      	strb	r3, [r7, #2]
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid hwctrl", XMC_GPIO_CHECK_HWCTRL(hwctrl));

  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
 8025828:	687b      	ldr	r3, [r7, #4]
 802582a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 802582c:	78fb      	ldrb	r3, [r7, #3]
 802582e:	005b      	lsls	r3, r3, #1
 8025830:	2103      	movs	r1, #3
 8025832:	fa01 f303 	lsl.w	r3, r1, r3
 8025836:	43db      	mvns	r3, r3
 8025838:	401a      	ands	r2, r3
 802583a:	687b      	ldr	r3, [r7, #4]
 802583c:	675a      	str	r2, [r3, #116]	; 0x74
  port->HWSEL |= (uint32_t)hwctrl << ((uint32_t)pin << 1U);
 802583e:	687b      	ldr	r3, [r7, #4]
 8025840:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8025842:	78b9      	ldrb	r1, [r7, #2]
 8025844:	78fb      	ldrb	r3, [r7, #3]
 8025846:	005b      	lsls	r3, r3, #1
 8025848:	fa01 f303 	lsl.w	r3, r1, r3
 802584c:	431a      	orrs	r2, r3
 802584e:	687b      	ldr	r3, [r7, #4]
 8025850:	675a      	str	r2, [r3, #116]	; 0x74
}
 8025852:	bf00      	nop
 8025854:	370c      	adds	r7, #12
 8025856:	46bd      	mov	sp, r7
 8025858:	f85d 7b04 	ldr.w	r7, [sp], #4
 802585c:	4770      	bx	lr

0802585e <XMC_POSIF_Stop>:
{
 802585e:	b480      	push	{r7}
 8025860:	b083      	sub	sp, #12
 8025862:	af00      	add	r7, sp, #0
 8025864:	6078      	str	r0, [r7, #4]
  peripheral->PRUNC = (uint32_t)(POSIF_PRUNC_CRB_Msk | POSIF_PRUNC_CSM_Msk);
 8025866:	687b      	ldr	r3, [r7, #4]
 8025868:	2203      	movs	r2, #3
 802586a:	60da      	str	r2, [r3, #12]
}
 802586c:	bf00      	nop
 802586e:	370c      	adds	r7, #12
 8025870:	46bd      	mov	sp, r7
 8025872:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025876:	4770      	bx	lr

08025878 <XMC_POSIF_Enable>:
 * API IMPLEMENTATION
 ********************************************************************************************************************/

/* API to enable the POSIF module */
void XMC_POSIF_Enable(XMC_POSIF_t *const peripheral)
{
 8025878:	b580      	push	{r7, lr}
 802587a:	b082      	sub	sp, #8
 802587c:	af00      	add	r7, sp, #0
 802587e:	6078      	str	r0, [r7, #4]
#if UC_FAMILY == XMC4
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 8025880:	2010      	movs	r0, #16
 8025882:	f7fe fb3b 	bl	8023efc <XMC_SCU_CLOCK_EnableClock>
#endif

  if (peripheral == POSIF0)
 8025886:	687b      	ldr	r3, [r7, #4]
 8025888:	4a0d      	ldr	r2, [pc, #52]	; (80258c0 <XMC_POSIF_Enable+0x48>)
 802588a:	4293      	cmp	r3, r2
 802588c:	d108      	bne.n	80258a0 <XMC_POSIF_Enable+0x28>
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_POSIF0);
 802588e:	f44f 7000 	mov.w	r0, #512	; 0x200
 8025892:	f7fe fb43 	bl	8023f1c <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
#if defined(PERIPHERAL_RESET_SUPPORTED)
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_POSIF0);
 8025896:	f44f 7000 	mov.w	r0, #512	; 0x200
 802589a:	f7fe f9e9 	bl	8023c70 <XMC_SCU_RESET_DeassertPeripheralReset>
#endif
  else
  {
    XMC_ASSERT("XMC_POSIF_Disable:Invalid module pointer", 0);
  }
}
 802589e:	e00b      	b.n	80258b8 <XMC_POSIF_Enable+0x40>
  else if (peripheral == POSIF1)
 80258a0:	687b      	ldr	r3, [r7, #4]
 80258a2:	4a08      	ldr	r2, [pc, #32]	; (80258c4 <XMC_POSIF_Enable+0x4c>)
 80258a4:	4293      	cmp	r3, r2
 80258a6:	d107      	bne.n	80258b8 <XMC_POSIF_Enable+0x40>
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_POSIF1);
 80258a8:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80258ac:	f7fe fb36 	bl	8023f1c <XMC_SCU_CLOCK_UngatePeripheralClock>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_POSIF1);
 80258b0:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80258b4:	f7fe f9dc 	bl	8023c70 <XMC_SCU_RESET_DeassertPeripheralReset>
}
 80258b8:	bf00      	nop
 80258ba:	3708      	adds	r7, #8
 80258bc:	46bd      	mov	sp, r7
 80258be:	bd80      	pop	{r7, pc}
 80258c0:	40028000 	.word	0x40028000
 80258c4:	4002c000 	.word	0x4002c000

080258c8 <XMC_POSIF_Init>:
  }
}

/* API to initialize POSIF global resources */
void XMC_POSIF_Init(XMC_POSIF_t *const peripheral, const XMC_POSIF_CONFIG_t *const config)
{
 80258c8:	b580      	push	{r7, lr}
 80258ca:	b082      	sub	sp, #8
 80258cc:	af00      	add	r7, sp, #0
 80258ce:	6078      	str	r0, [r7, #4]
 80258d0:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_POSIF_Init:Invalid module pointer", XMC_POSIF_IsPeripheralValid(peripheral));
  XMC_ASSERT("XMC_POSIF_Init:NULL Pointer", (config != (XMC_POSIF_CONFIG_t *)NULL) );

  /* Enable the POSIF module */
  XMC_POSIF_Enable(peripheral);
 80258d2:	6878      	ldr	r0, [r7, #4]
 80258d4:	f7ff ffd0 	bl	8025878 <XMC_POSIF_Enable>

  /* Stop POSIF */
  XMC_POSIF_Stop(peripheral);
 80258d8:	6878      	ldr	r0, [r7, #4]
 80258da:	f7ff ffc0 	bl	802585e <XMC_POSIF_Stop>

  /* Program the operational mode, input selectors and debounce filter */
  peripheral->PCONF = config->pconf;
 80258de:	683b      	ldr	r3, [r7, #0]
 80258e0:	681a      	ldr	r2, [r3, #0]
 80258e2:	687b      	ldr	r3, [r7, #4]
 80258e4:	601a      	str	r2, [r3, #0]
}
 80258e6:	bf00      	nop
 80258e8:	3708      	adds	r7, #8
 80258ea:	46bd      	mov	sp, r7
 80258ec:	bd80      	pop	{r7, pc}

080258ee <XMC_POSIF_HSC_Init>:

/* API to initialize hall sensor interface */
XMC_POSIF_STATUS_t XMC_POSIF_HSC_Init(XMC_POSIF_t *const peripheral, const XMC_POSIF_HSC_CONFIG_t *const config)
{
 80258ee:	b480      	push	{r7}
 80258f0:	b085      	sub	sp, #20
 80258f2:	af00      	add	r7, sp, #0
 80258f4:	6078      	str	r0, [r7, #4]
 80258f6:	6039      	str	r1, [r7, #0]
  XMC_POSIF_STATUS_t retval;

  XMC_ASSERT("XMC_POSIF_HSC_Init:Invalid module pointer\n", XMC_POSIF_IsPeripheralValid(peripheral));
  XMC_ASSERT("XMC_POSIF_HSC_Init:NULL Pointer\n", (config != (XMC_POSIF_HSC_CONFIG_t *)NULL) );

  if (XMC_POSIF_MODE_HALL_SENSOR == (XMC_POSIF_MODE_t)((peripheral->PCONF) & (uint32_t)POSIF_PCONF_FSEL_Msk) )
 80258f8:	687b      	ldr	r3, [r7, #4]
 80258fa:	681b      	ldr	r3, [r3, #0]
 80258fc:	b2db      	uxtb	r3, r3
 80258fe:	f003 0303 	and.w	r3, r3, #3
 8025902:	2b00      	cmp	r3, #0
 8025904:	d109      	bne.n	802591a <XMC_POSIF_HSC_Init+0x2c>
  {
    peripheral->PCONF |= config->hall_config;
 8025906:	687b      	ldr	r3, [r7, #4]
 8025908:	681a      	ldr	r2, [r3, #0]
 802590a:	683b      	ldr	r3, [r7, #0]
 802590c:	681b      	ldr	r3, [r3, #0]
 802590e:	431a      	orrs	r2, r3
 8025910:	687b      	ldr	r3, [r7, #4]
 8025912:	601a      	str	r2, [r3, #0]
    retval = XMC_POSIF_STATUS_OK;
 8025914:	2300      	movs	r3, #0
 8025916:	73fb      	strb	r3, [r7, #15]
 8025918:	e001      	b.n	802591e <XMC_POSIF_HSC_Init+0x30>
  }
  else
  {
    retval = XMC_POSIF_STATUS_ERROR;
 802591a:	2301      	movs	r3, #1
 802591c:	73fb      	strb	r3, [r7, #15]
  }
  return retval;
 802591e:	7bfb      	ldrb	r3, [r7, #15]
}
 8025920:	4618      	mov	r0, r3
 8025922:	3714      	adds	r7, #20
 8025924:	46bd      	mov	sp, r7
 8025926:	f85d 7b04 	ldr.w	r7, [sp], #4
 802592a:	4770      	bx	lr

0802592c <XMC_POSIF_MCM_Init>:

/* API to initialize multi-channel mode.
 * This is used in Hall mode, standalone multi-channel mode and quadrature with multi-channel mode
 */
XMC_POSIF_STATUS_t XMC_POSIF_MCM_Init(XMC_POSIF_t *const peripheral, const XMC_POSIF_MCM_CONFIG_t *const config)
{
 802592c:	b480      	push	{r7}
 802592e:	b085      	sub	sp, #20
 8025930:	af00      	add	r7, sp, #0
 8025932:	6078      	str	r0, [r7, #4]
 8025934:	6039      	str	r1, [r7, #0]
  XMC_POSIF_STATUS_t retval;

  XMC_ASSERT("XMC_POSIF_MCM_Init:Invalid module pointer", XMC_POSIF_IsPeripheralValid(peripheral));
  XMC_ASSERT("XMC_POSIF_MCM_Init:NULL Pointer", (config != (XMC_POSIF_MCM_CONFIG_t *)NULL) );

  if ((XMC_POSIF_MODE_t)((peripheral->PCONF) & (uint32_t)POSIF_PCONF_FSEL_Msk) != XMC_POSIF_MODE_QD)
 8025936:	687b      	ldr	r3, [r7, #4]
 8025938:	681b      	ldr	r3, [r3, #0]
 802593a:	b2db      	uxtb	r3, r3
 802593c:	f003 0303 	and.w	r3, r3, #3
 8025940:	2b01      	cmp	r3, #1
 8025942:	d009      	beq.n	8025958 <XMC_POSIF_MCM_Init+0x2c>
  {
    peripheral->PCONF |= config->mcm_config;
 8025944:	687b      	ldr	r3, [r7, #4]
 8025946:	681a      	ldr	r2, [r3, #0]
 8025948:	683b      	ldr	r3, [r7, #0]
 802594a:	681b      	ldr	r3, [r3, #0]
 802594c:	431a      	orrs	r2, r3
 802594e:	687b      	ldr	r3, [r7, #4]
 8025950:	601a      	str	r2, [r3, #0]
    retval = XMC_POSIF_STATUS_OK;
 8025952:	2300      	movs	r3, #0
 8025954:	73fb      	strb	r3, [r7, #15]
 8025956:	e001      	b.n	802595c <XMC_POSIF_MCM_Init+0x30>
  }
  else
  {
    retval = XMC_POSIF_STATUS_ERROR;
 8025958:	2301      	movs	r3, #1
 802595a:	73fb      	strb	r3, [r7, #15]
  }
  return retval;
 802595c:	7bfb      	ldrb	r3, [r7, #15]
}
 802595e:	4618      	mov	r0, r3
 8025960:	3714      	adds	r7, #20
 8025962:	46bd      	mov	sp, r7
 8025964:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025968:	4770      	bx	lr

0802596a <XMC_POSIF_SetInterruptNode>:
  peripheral->PCONF = ((peripheral->PCONF & ~(uint32_t)XMC_POSIF_PCONF_INSEL_Msk) | reg);
}

/* API to select an interrupt node */
void XMC_POSIF_SetInterruptNode(XMC_POSIF_t *const peripheral, const XMC_POSIF_IRQ_EVENT_t event, const XMC_POSIF_SR_ID_t sr)
{
 802596a:	b480      	push	{r7}
 802596c:	b085      	sub	sp, #20
 802596e:	af00      	add	r7, sp, #0
 8025970:	6078      	str	r0, [r7, #4]
 8025972:	460b      	mov	r3, r1
 8025974:	70fb      	strb	r3, [r7, #3]
 8025976:	4613      	mov	r3, r2
 8025978:	70bb      	strb	r3, [r7, #2]

  XMC_ASSERT("XMC_POSIF_SetInterruptNode:Invalid module pointer", XMC_POSIF_IsPeripheralValid(peripheral));
  XMC_ASSERT("XMC_POSIF_SetInterruptNode:Wrong IRQ event", (event <= XMC_POSIF_IRQ_EVENT_PCLK) );
  XMC_ASSERT("XMC_POSIF_SetInterruptNode:Wrong SR ID", (sr <= XMC_POSIF_SR_ID_1) );

  reg = peripheral->PFLGE;
 802597a:	687b      	ldr	r3, [r7, #4]
 802597c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 802597e:	60fb      	str	r3, [r7, #12]
  reg &= ~((uint32_t)1 << ((uint32_t)event + (uint32_t)POSIF_PFLGE_CHESEL_Pos));
 8025980:	78fb      	ldrb	r3, [r7, #3]
 8025982:	3310      	adds	r3, #16
 8025984:	2201      	movs	r2, #1
 8025986:	fa02 f303 	lsl.w	r3, r2, r3
 802598a:	43db      	mvns	r3, r3
 802598c:	68fa      	ldr	r2, [r7, #12]
 802598e:	4013      	ands	r3, r2
 8025990:	60fb      	str	r3, [r7, #12]
  reg |= (uint32_t)sr << ((uint32_t)event + (uint32_t)POSIF_PFLGE_CHESEL_Pos);
 8025992:	78ba      	ldrb	r2, [r7, #2]
 8025994:	78fb      	ldrb	r3, [r7, #3]
 8025996:	3310      	adds	r3, #16
 8025998:	fa02 f303 	lsl.w	r3, r2, r3
 802599c:	68fa      	ldr	r2, [r7, #12]
 802599e:	4313      	orrs	r3, r2
 80259a0:	60fb      	str	r3, [r7, #12]
  peripheral->PFLGE = reg;
 80259a2:	687b      	ldr	r3, [r7, #4]
 80259a4:	68fa      	ldr	r2, [r7, #12]
 80259a6:	675a      	str	r2, [r3, #116]	; 0x74
}
 80259a8:	bf00      	nop
 80259aa:	3714      	adds	r7, #20
 80259ac:	46bd      	mov	sp, r7
 80259ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80259b2:	4770      	bx	lr

080259b4 <XMC_VADC_GROUP_ExternalMuxControlInit>:
{
 80259b4:	b480      	push	{r7}
 80259b6:	b085      	sub	sp, #20
 80259b8:	af00      	add	r7, sp, #0
 80259ba:	6078      	str	r0, [r7, #4]
 80259bc:	6039      	str	r1, [r7, #0]
  emux_config = ((uint32_t)emux_cfg.starting_external_channel << (uint32_t)VADC_G_EMUXCTR_EMUXSET_Pos) |
 80259be:	783b      	ldrb	r3, [r7, #0]
 80259c0:	f3c3 0302 	ubfx	r3, r3, #0, #3
 80259c4:	b2db      	uxtb	r3, r3
 80259c6:	461a      	mov	r2, r3
                ((uint32_t)emux_cfg.connected_channel << (uint32_t)VADC_G_EMUXCTR_EMUXCH_Pos);
 80259c8:	887b      	ldrh	r3, [r7, #2]
 80259ca:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80259ce:	b29b      	uxth	r3, r3
 80259d0:	041b      	lsls	r3, r3, #16
  emux_config = ((uint32_t)emux_cfg.starting_external_channel << (uint32_t)VADC_G_EMUXCTR_EMUXSET_Pos) |
 80259d2:	4313      	orrs	r3, r2
 80259d4:	60fb      	str	r3, [r7, #12]
  group_ptr->EMUXCTR  = emux_config;
 80259d6:	687b      	ldr	r3, [r7, #4]
 80259d8:	68fa      	ldr	r2, [r7, #12]
 80259da:	f8c3 21f0 	str.w	r2, [r3, #496]	; 0x1f0
  emux_config = ((uint32_t)emux_cfg.emux_coding << (uint32_t)VADC_G_EMUXCTR_EMXCOD_Pos)  |
 80259de:	78fb      	ldrb	r3, [r7, #3]
 80259e0:	f3c3 1300 	ubfx	r3, r3, #4, #1
 80259e4:	b2db      	uxtb	r3, r3
 80259e6:	071a      	lsls	r2, r3, #28
                ((uint32_t)emux_cfg.emux_mode  << (uint32_t)VADC_G_EMUXCTR_EMUXMODE_Pos) |
 80259e8:	78fb      	ldrb	r3, [r7, #3]
 80259ea:	f3c3 0381 	ubfx	r3, r3, #2, #2
 80259ee:	b2db      	uxtb	r3, r3
 80259f0:	069b      	lsls	r3, r3, #26
  emux_config = ((uint32_t)emux_cfg.emux_coding << (uint32_t)VADC_G_EMUXCTR_EMXCOD_Pos)  |
 80259f2:	431a      	orrs	r2, r3
                ((uint32_t)emux_cfg.stce_usage << (uint32_t)VADC_G_EMUXCTR_EMXST_Pos);
 80259f4:	78fb      	ldrb	r3, [r7, #3]
 80259f6:	f3c3 1340 	ubfx	r3, r3, #5, #1
 80259fa:	b2db      	uxtb	r3, r3
 80259fc:	075b      	lsls	r3, r3, #29
  emux_config = ((uint32_t)emux_cfg.emux_coding << (uint32_t)VADC_G_EMUXCTR_EMXCOD_Pos)  |
 80259fe:	4313      	orrs	r3, r2
 8025a00:	60fb      	str	r3, [r7, #12]
  emux_config |= ((uint32_t)emux_cfg.emux_channel_select_style << (uint32_t)VADC_G_EMUXCTR_EMXCSS_Pos);
 8025a02:	78fb      	ldrb	r3, [r7, #3]
 8025a04:	f3c3 1380 	ubfx	r3, r3, #6, #1
 8025a08:	b2db      	uxtb	r3, r3
 8025a0a:	079b      	lsls	r3, r3, #30
 8025a0c:	68fa      	ldr	r2, [r7, #12]
 8025a0e:	4313      	orrs	r3, r2
 8025a10:	60fb      	str	r3, [r7, #12]
  group_ptr->EMUXCTR  |= (emux_config | ((uint32_t)VADC_G_EMUXCTR_EMXWC_Msk)) ;
 8025a12:	687b      	ldr	r3, [r7, #4]
 8025a14:	f8d3 21f0 	ldr.w	r2, [r3, #496]	; 0x1f0
 8025a18:	68fb      	ldr	r3, [r7, #12]
 8025a1a:	4313      	orrs	r3, r2
 8025a1c:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 8025a20:	687b      	ldr	r3, [r7, #4]
 8025a22:	f8c3 21f0 	str.w	r2, [r3, #496]	; 0x1f0
}
 8025a26:	bf00      	nop
 8025a28:	3714      	adds	r7, #20
 8025a2a:	46bd      	mov	sp, r7
 8025a2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025a30:	4770      	bx	lr

08025a32 <XMC_VADC_GROUP_BackgroundEnableArbitrationSlot>:
{
 8025a32:	b480      	push	{r7}
 8025a34:	b083      	sub	sp, #12
 8025a36:	af00      	add	r7, sp, #0
 8025a38:	6078      	str	r0, [r7, #4]
  group_ptr->ARBPR |= (uint32_t)VADC_G_ARBPR_ASEN2_Msk;
 8025a3a:	687b      	ldr	r3, [r7, #4]
 8025a3c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8025a40:	f043 6280 	orr.w	r2, r3, #67108864	; 0x4000000
 8025a44:	687b      	ldr	r3, [r7, #4]
 8025a46:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
 8025a4a:	bf00      	nop
 8025a4c:	370c      	adds	r7, #12
 8025a4e:	46bd      	mov	sp, r7
 8025a50:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025a54:	4770      	bx	lr

08025a56 <XMC_VADC_GROUP_BackgroundDisableArbitrationSlot>:
{
 8025a56:	b480      	push	{r7}
 8025a58:	b083      	sub	sp, #12
 8025a5a:	af00      	add	r7, sp, #0
 8025a5c:	6078      	str	r0, [r7, #4]
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN2_Msk);
 8025a5e:	687b      	ldr	r3, [r7, #4]
 8025a60:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8025a64:	f023 6280 	bic.w	r2, r3, #67108864	; 0x4000000
 8025a68:	687b      	ldr	r3, [r7, #4]
 8025a6a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
 8025a6e:	bf00      	nop
 8025a70:	370c      	adds	r7, #12
 8025a72:	46bd      	mov	sp, r7
 8025a74:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025a78:	4770      	bx	lr

08025a7a <XMC_VADC_GROUP_QueueEnableArbitrationSlot>:
{
 8025a7a:	b480      	push	{r7}
 8025a7c:	b083      	sub	sp, #12
 8025a7e:	af00      	add	r7, sp, #0
 8025a80:	6078      	str	r0, [r7, #4]
  group_ptr->ARBPR |= (uint32_t)((uint32_t)1 << VADC_G_ARBPR_ASEN0_Pos);
 8025a82:	687b      	ldr	r3, [r7, #4]
 8025a84:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8025a88:	f043 7280 	orr.w	r2, r3, #16777216	; 0x1000000
 8025a8c:	687b      	ldr	r3, [r7, #4]
 8025a8e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
 8025a92:	bf00      	nop
 8025a94:	370c      	adds	r7, #12
 8025a96:	46bd      	mov	sp, r7
 8025a98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025a9c:	4770      	bx	lr

08025a9e <XMC_VADC_GROUP_QueueDisableArbitrationSlot>:
{
 8025a9e:	b480      	push	{r7}
 8025aa0:	b083      	sub	sp, #12
 8025aa2:	af00      	add	r7, sp, #0
 8025aa4:	6078      	str	r0, [r7, #4]
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN0_Msk);
 8025aa6:	687b      	ldr	r3, [r7, #4]
 8025aa8:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8025aac:	f023 7280 	bic.w	r2, r3, #16777216	; 0x1000000
 8025ab0:	687b      	ldr	r3, [r7, #4]
 8025ab2:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
 8025ab6:	bf00      	nop
 8025ab8:	370c      	adds	r7, #12
 8025aba:	46bd      	mov	sp, r7
 8025abc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025ac0:	4770      	bx	lr

08025ac2 <XMC_VADC_GLOBAL_EnableModule>:
 * API IMPLEMENTATION
 ********************************************************************************************************************/

/*API to enable the VADC Module*/
void XMC_VADC_GLOBAL_EnableModule(void)
{
 8025ac2:	b580      	push	{r7, lr}
 8025ac4:	af00      	add	r7, sp, #0
#if defined (COMPARATOR)
  COMPARATOR->ORCCTRL = (uint32_t)0xFF;
#endif

#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_VADC);
 8025ac6:	2001      	movs	r0, #1
 8025ac8:	f7fe fa28 	bl	8023f1c <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif

#if defined(PERIPHERAL_RESET_SUPPORTED)
  /* Reset the Hardware */
  XMC_SCU_RESET_DeassertPeripheralReset((XMC_SCU_PERIPHERAL_RESET_t)XMC_SCU_PERIPHERAL_RESET_VADC );
 8025acc:	2001      	movs	r0, #1
 8025ace:	f7fe f8cf 	bl	8023c70 <XMC_SCU_RESET_DeassertPeripheralReset>
#endif
}
 8025ad2:	bf00      	nop
 8025ad4:	bd80      	pop	{r7, pc}

08025ad6 <XMC_VADC_GLOBAL_Init>:
}


/* API to initialize global resources */
void XMC_VADC_GLOBAL_Init(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_GLOBAL_CONFIG_t *config)
{
 8025ad6:	b580      	push	{r7, lr}
 8025ad8:	b082      	sub	sp, #8
 8025ada:	af00      	add	r7, sp, #0
 8025adc:	6078      	str	r0, [r7, #4]
 8025ade:	6039      	str	r1, [r7, #0]
#if (UC_SERIES == XMC14)
  XMC_SCU_CLOCK_SetAdcClockSrc(XMC_SCU_CLOCK_ADCCLKSRC_48MHZ);
#endif

  /* Enable the VADC module*/
  XMC_VADC_GLOBAL_EnableModule();
 8025ae0:	f7ff ffef 	bl	8025ac2 <XMC_VADC_GLOBAL_EnableModule>

  global_ptr->CLC = (uint32_t)(config->clc);
 8025ae4:	683b      	ldr	r3, [r7, #0]
 8025ae6:	695a      	ldr	r2, [r3, #20]
 8025ae8:	687b      	ldr	r3, [r7, #4]
 8025aea:	601a      	str	r2, [r3, #0]

  /* Clock configuration */

#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  global_ptr->GLOBCFG  = (uint32_t)(config->clock_config.globcfg | (uint32_t)(VADC_GLOBCFG_DIVWC_Msk));
 8025aec:	683b      	ldr	r3, [r7, #0]
 8025aee:	685b      	ldr	r3, [r3, #4]
 8025af0:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
 8025af4:	687b      	ldr	r3, [r7, #4]
 8025af6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
#endif

  /* ICLASS-0 configuration */
  global_ptr->GLOBICLASS[0] = (uint32_t)(config->class0.globiclass);
 8025afa:	683b      	ldr	r3, [r7, #0]
 8025afc:	689a      	ldr	r2, [r3, #8]
 8025afe:	687b      	ldr	r3, [r7, #4]
 8025b00:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

  /* ICLASS-1 configuration */
  global_ptr->GLOBICLASS[1] = (uint32_t)(config->class1.globiclass);
 8025b04:	683b      	ldr	r3, [r7, #0]
 8025b06:	68da      	ldr	r2, [r3, #12]
 8025b08:	687b      	ldr	r3, [r7, #4]
 8025b0a:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4


  /*Result generation related configuration */
  global_ptr->GLOBRCR = (uint32_t)(config->globrcr);
 8025b0e:	683b      	ldr	r3, [r7, #0]
 8025b10:	691a      	ldr	r2, [r3, #16]
 8025b12:	687b      	ldr	r3, [r7, #4]
 8025b14:	f8c3 2280 	str.w	r2, [r3, #640]	; 0x280

#if (XMC_VADC_BOUNDARY_AVAILABLE == 1U)

  /* Boundaries */
  global_ptr->GLOBBOUND = (uint32_t)(config->globbound);
 8025b18:	683b      	ldr	r3, [r7, #0]
 8025b1a:	681a      	ldr	r2, [r3, #0]
 8025b1c:	687b      	ldr	r3, [r7, #4]
 8025b1e:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

  /* From the Errata sheet of XMC1100 V1.7*/
  XMC_VADC_CONV_ENABLE_FOR_XMC11 = 1U;
#endif

}
 8025b22:	bf00      	nop
 8025b24:	3708      	adds	r7, #8
 8025b26:	46bd      	mov	sp, r7
 8025b28:	bd80      	pop	{r7, pc}
	...

08025b2c <XMC_VADC_GLOBAL_InputClassInit>:

/* API to Set the Global IClass registers*/
void XMC_VADC_GLOBAL_InputClassInit(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_GLOBAL_CLASS_t config,
                                    const XMC_VADC_GROUP_CONV_t conv_type, const uint32_t set_num)
{
 8025b2c:	b480      	push	{r7}
 8025b2e:	b085      	sub	sp, #20
 8025b30:	af00      	add	r7, sp, #0
 8025b32:	60f8      	str	r0, [r7, #12]
 8025b34:	60b9      	str	r1, [r7, #8]
 8025b36:	603b      	str	r3, [r7, #0]
 8025b38:	4613      	mov	r3, r2
 8025b3a:	71fb      	strb	r3, [r7, #7]
  XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong Module Pointer", (global_ptr == VADC))
  XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong Conversion Type", ((conv_type) <= XMC_VADC_GROUP_CONV_EMUX))
  XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong ICLASS set number", (set_num < XMC_VADC_MAX_ICLASS_SET))

#if(XMC_VADC_EMUX_AVAILABLE == 1U)
  if (conv_type == XMC_VADC_GROUP_CONV_STD )
 8025b3c:	79fb      	ldrb	r3, [r7, #7]
 8025b3e:	2b00      	cmp	r3, #0
 8025b40:	d109      	bne.n	8025b56 <XMC_VADC_GLOBAL_InputClassInit+0x2a>
  {
#endif
    XMC_UNUSED_ARG(conv_type);
    global_ptr->GLOBICLASS[set_num] = config.globiclass &
 8025b42:	68ba      	ldr	r2, [r7, #8]
 8025b44:	f240 731f 	movw	r3, #1823	; 0x71f
 8025b48:	4013      	ands	r3, r2
 8025b4a:	68fa      	ldr	r2, [r7, #12]
 8025b4c:	6839      	ldr	r1, [r7, #0]
 8025b4e:	3128      	adds	r1, #40	; 0x28
 8025b50:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  else
  {
    global_ptr->GLOBICLASS[set_num] = config.globiclass & (uint32_t)(VADC_GLOBICLASS_CME_Msk | VADC_GLOBICLASS_STCE_Msk);
  }
#endif
}
 8025b54:	e007      	b.n	8025b66 <XMC_VADC_GLOBAL_InputClassInit+0x3a>
    global_ptr->GLOBICLASS[set_num] = config.globiclass & (uint32_t)(VADC_GLOBICLASS_CME_Msk | VADC_GLOBICLASS_STCE_Msk);
 8025b56:	68ba      	ldr	r2, [r7, #8]
 8025b58:	4b06      	ldr	r3, [pc, #24]	; (8025b74 <XMC_VADC_GLOBAL_InputClassInit+0x48>)
 8025b5a:	4013      	ands	r3, r2
 8025b5c:	68fa      	ldr	r2, [r7, #12]
 8025b5e:	6839      	ldr	r1, [r7, #0]
 8025b60:	3128      	adds	r1, #40	; 0x28
 8025b62:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
 8025b66:	bf00      	nop
 8025b68:	3714      	adds	r7, #20
 8025b6a:	46bd      	mov	sp, r7
 8025b6c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025b70:	4770      	bx	lr
 8025b72:	bf00      	nop
 8025b74:	071f0000 	.word	0x071f0000

08025b78 <XMC_VADC_GLOBAL_StartupCalibration>:

/* API to enable startup calibration feature */
void XMC_VADC_GLOBAL_StartupCalibration(XMC_VADC_GLOBAL_t *const global_ptr)
{
 8025b78:	b480      	push	{r7}
 8025b7a:	b085      	sub	sp, #20
 8025b7c:	af00      	add	r7, sp, #0
 8025b7e:	6078      	str	r0, [r7, #4]
  VADC_G_TypeDef *group_ptr;
#endif

  XMC_ASSERT("XMC_VADC_GLOBAL_StartupCalibration:Wrong Module Pointer", (global_ptr == VADC))

  global_ptr->GLOBCFG |= (uint32_t)VADC_GLOBCFG_SUCAL_Msk;
 8025b80:	687b      	ldr	r3, [r7, #4]
 8025b82:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8025b86:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 8025b8a:	687b      	ldr	r3, [r7, #4]
 8025b8c:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  /* Loop until all active groups finish calibration */
  for (i = 0U; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 8025b90:	2300      	movs	r3, #0
 8025b92:	73fb      	strb	r3, [r7, #15]
 8025b94:	e017      	b.n	8025bc6 <XMC_VADC_GLOBAL_StartupCalibration+0x4e>
  {
    group_ptr = g_xmc_vadc_group_array[i];
 8025b96:	7bfb      	ldrb	r3, [r7, #15]
 8025b98:	4a10      	ldr	r2, [pc, #64]	; (8025bdc <XMC_VADC_GLOBAL_StartupCalibration+0x64>)
 8025b9a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8025b9e:	60bb      	str	r3, [r7, #8]
    if ( (group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_ANONS_Msk)
 8025ba0:	68bb      	ldr	r3, [r7, #8]
 8025ba2:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8025ba6:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8025baa:	2b00      	cmp	r3, #0
 8025bac:	d008      	beq.n	8025bc0 <XMC_VADC_GLOBAL_StartupCalibration+0x48>
      while ((group_ptr->ARBCFG & (uint32_t)VADC_G_ARBCFG_CALS_Msk) == 0)
      {
        __NOP();
      }
#endif
      while ((group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_CAL_Msk)
 8025bae:	e000      	b.n	8025bb2 <XMC_VADC_GLOBAL_StartupCalibration+0x3a>
      {
        __NOP();
 8025bb0:	bf00      	nop
      while ((group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_CAL_Msk)
 8025bb2:	68bb      	ldr	r3, [r7, #8]
 8025bb4:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8025bb8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8025bbc:	2b00      	cmp	r3, #0
 8025bbe:	d1f7      	bne.n	8025bb0 <XMC_VADC_GLOBAL_StartupCalibration+0x38>
  for (i = 0U; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 8025bc0:	7bfb      	ldrb	r3, [r7, #15]
 8025bc2:	3301      	adds	r3, #1
 8025bc4:	73fb      	strb	r3, [r7, #15]
 8025bc6:	7bfb      	ldrb	r3, [r7, #15]
 8025bc8:	2b03      	cmp	r3, #3
 8025bca:	d9e4      	bls.n	8025b96 <XMC_VADC_GLOBAL_StartupCalibration+0x1e>
         XMC_VADC_SHS_START_UP_CAL_ACTIVE )
  {
    __NOP();
  }
#endif
}
 8025bcc:	bf00      	nop
 8025bce:	bf00      	nop
 8025bd0:	3714      	adds	r7, #20
 8025bd2:	46bd      	mov	sp, r7
 8025bd4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025bd8:	4770      	bx	lr
 8025bda:	bf00      	nop
 8025bdc:	080284a4 	.word	0x080284a4

08025be0 <XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode>:
  global_ptr->GLOBEVNP |= (uint32_t)(node << VADC_GLOBEVNP_REV0NP_Pos);
}

/* API to bind request source event with a service request line */
void XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode(XMC_VADC_GLOBAL_t *const global_ptr, XMC_VADC_SR_t sr)
{
 8025be0:	b480      	push	{r7}
 8025be2:	b085      	sub	sp, #20
 8025be4:	af00      	add	r7, sp, #0
 8025be6:	6078      	str	r0, [r7, #4]
 8025be8:	460b      	mov	r3, r1
 8025bea:	70fb      	strb	r3, [r7, #3]
  uint32_t node;

  XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode:Wrong Module Pointer", (global_ptr == VADC))

  if (sr >= XMC_VADC_SR_SHARED_SR0)
 8025bec:	78fb      	ldrb	r3, [r7, #3]
 8025bee:	2b03      	cmp	r3, #3
 8025bf0:	d903      	bls.n	8025bfa <XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode+0x1a>
  {
    node = (uint32_t)sr - (uint32_t)XMC_VADC_SR_SHARED_SR0;
 8025bf2:	78fb      	ldrb	r3, [r7, #3]
 8025bf4:	3b04      	subs	r3, #4
 8025bf6:	60fb      	str	r3, [r7, #12]
 8025bf8:	e001      	b.n	8025bfe <XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode+0x1e>
  }
  else
  {
    node = (uint32_t)sr;
 8025bfa:	78fb      	ldrb	r3, [r7, #3]
 8025bfc:	60fb      	str	r3, [r7, #12]
  }

  global_ptr->GLOBEVNP &= ~((uint32_t)VADC_GLOBEVNP_SEV0NP_Msk);
 8025bfe:	687b      	ldr	r3, [r7, #4]
 8025c00:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 8025c04:	f023 020f 	bic.w	r2, r3, #15
 8025c08:	687b      	ldr	r3, [r7, #4]
 8025c0a:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
  global_ptr->GLOBEVNP |= (uint32_t) (node << VADC_GLOBEVNP_SEV0NP_Pos);
 8025c0e:	687b      	ldr	r3, [r7, #4]
 8025c10:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
 8025c14:	68fb      	ldr	r3, [r7, #12]
 8025c16:	431a      	orrs	r2, r3
 8025c18:	687b      	ldr	r3, [r7, #4]
 8025c1a:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
}
 8025c1e:	bf00      	nop
 8025c20:	3714      	adds	r7, #20
 8025c22:	46bd      	mov	sp, r7
 8025c24:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025c28:	4770      	bx	lr

08025c2a <XMC_VADC_GROUP_Init>:

/* API to initialize an instance of group of VADC hardware */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
void XMC_VADC_GROUP_Init( XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_CONFIG_t *config)
{
 8025c2a:	b580      	push	{r7, lr}
 8025c2c:	b082      	sub	sp, #8
 8025c2e:	af00      	add	r7, sp, #0
 8025c30:	6078      	str	r0, [r7, #4]
 8025c32:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_VADC_GROUP_Init:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  /* Program the input classes */
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class0, XMC_VADC_GROUP_CONV_STD, 0U);
 8025c34:	6839      	ldr	r1, [r7, #0]
 8025c36:	2300      	movs	r3, #0
 8025c38:	2200      	movs	r2, #0
 8025c3a:	6849      	ldr	r1, [r1, #4]
 8025c3c:	6878      	ldr	r0, [r7, #4]
 8025c3e:	f000 f828 	bl	8025c92 <XMC_VADC_GROUP_InputClassInit>
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class0, XMC_VADC_GROUP_CONV_EMUX, 0U);
 8025c42:	6839      	ldr	r1, [r7, #0]
 8025c44:	2300      	movs	r3, #0
 8025c46:	2201      	movs	r2, #1
 8025c48:	6849      	ldr	r1, [r1, #4]
 8025c4a:	6878      	ldr	r0, [r7, #4]
 8025c4c:	f000 f821 	bl	8025c92 <XMC_VADC_GROUP_InputClassInit>
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class1, XMC_VADC_GROUP_CONV_STD, 1U);
 8025c50:	6839      	ldr	r1, [r7, #0]
 8025c52:	2301      	movs	r3, #1
 8025c54:	2200      	movs	r2, #0
 8025c56:	6889      	ldr	r1, [r1, #8]
 8025c58:	6878      	ldr	r0, [r7, #4]
 8025c5a:	f000 f81a 	bl	8025c92 <XMC_VADC_GROUP_InputClassInit>
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class1, XMC_VADC_GROUP_CONV_EMUX, 1U);
 8025c5e:	6839      	ldr	r1, [r7, #0]
 8025c60:	2301      	movs	r3, #1
 8025c62:	2201      	movs	r2, #1
 8025c64:	6889      	ldr	r1, [r1, #8]
 8025c66:	6878      	ldr	r0, [r7, #4]
 8025c68:	f000 f813 	bl	8025c92 <XMC_VADC_GROUP_InputClassInit>

  group_ptr->ARBCFG = config->g_arbcfg;
 8025c6c:	683b      	ldr	r3, [r7, #0]
 8025c6e:	691a      	ldr	r2, [r3, #16]
 8025c70:	687b      	ldr	r3, [r7, #4]
 8025c72:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  group_ptr->BOUND = config->g_bound;
 8025c76:	683b      	ldr	r3, [r7, #0]
 8025c78:	68da      	ldr	r2, [r3, #12]
 8025c7a:	687b      	ldr	r3, [r7, #4]
 8025c7c:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

  /* External mux configuration */
  XMC_VADC_GROUP_ExternalMuxControlInit(group_ptr, config->emux_config);
 8025c80:	683b      	ldr	r3, [r7, #0]
 8025c82:	6819      	ldr	r1, [r3, #0]
 8025c84:	6878      	ldr	r0, [r7, #4]
 8025c86:	f7ff fe95 	bl	80259b4 <XMC_VADC_GROUP_ExternalMuxControlInit>

}
 8025c8a:	bf00      	nop
 8025c8c:	3708      	adds	r7, #8
 8025c8e:	46bd      	mov	sp, r7
 8025c90:	bd80      	pop	{r7, pc}

08025c92 <XMC_VADC_GROUP_InputClassInit>:

/* API to program conversion characteristics */
void XMC_VADC_GROUP_InputClassInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_CLASS_t config,
                                   const XMC_VADC_GROUP_CONV_t conv_type, const uint32_t set_num)
{
 8025c92:	b480      	push	{r7}
 8025c94:	b08d      	sub	sp, #52	; 0x34
 8025c96:	af00      	add	r7, sp, #0
 8025c98:	60f8      	str	r0, [r7, #12]
 8025c9a:	60b9      	str	r1, [r7, #8]
 8025c9c:	603b      	str	r3, [r7, #0]
 8025c9e:	4613      	mov	r3, r2
 8025ca0:	71fb      	strb	r3, [r7, #7]

  /*
   * Obtain the mask and position macros of the parameters based on what is being requested - Standard channels vs
   * external mux channels.
   */
  if (XMC_VADC_GROUP_CONV_STD == conv_type)
 8025ca2:	79fb      	ldrb	r3, [r7, #7]
 8025ca4:	2b00      	cmp	r3, #0
 8025ca6:	d113      	bne.n	8025cd0 <XMC_VADC_GROUP_InputClassInit+0x3e>
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CMS_Pos;
 8025ca8:	2308      	movs	r3, #8
 8025caa:	62fb      	str	r3, [r7, #44]	; 0x2c
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CMS_Msk;
 8025cac:	f44f 63e0 	mov.w	r3, #1792	; 0x700
 8025cb0:	627b      	str	r3, [r7, #36]	; 0x24
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCS_Pos;
 8025cb2:	2300      	movs	r3, #0
 8025cb4:	62bb      	str	r3, [r7, #40]	; 0x28
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCS_Msk;
 8025cb6:	231f      	movs	r3, #31
 8025cb8:	623b      	str	r3, [r7, #32]
    sample_time      = (uint32_t) config.sample_time_std_conv;
 8025cba:	7a3b      	ldrb	r3, [r7, #8]
 8025cbc:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8025cc0:	b2db      	uxtb	r3, r3
 8025cc2:	61fb      	str	r3, [r7, #28]
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_standard;
 8025cc4:	7a7b      	ldrb	r3, [r7, #9]
 8025cc6:	f3c3 0302 	ubfx	r3, r3, #0, #3
 8025cca:	b2db      	uxtb	r3, r3
 8025ccc:	76fb      	strb	r3, [r7, #27]
 8025cce:	e013      	b.n	8025cf8 <XMC_VADC_GROUP_InputClassInit+0x66>
  }
  else
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CME_Pos;
 8025cd0:	2318      	movs	r3, #24
 8025cd2:	62fb      	str	r3, [r7, #44]	; 0x2c
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CME_Msk;
 8025cd4:	f04f 63e0 	mov.w	r3, #117440512	; 0x7000000
 8025cd8:	627b      	str	r3, [r7, #36]	; 0x24
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCE_Pos;
 8025cda:	2310      	movs	r3, #16
 8025cdc:	62bb      	str	r3, [r7, #40]	; 0x28
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCE_Msk;
 8025cde:	f44f 13f8 	mov.w	r3, #2031616	; 0x1f0000
 8025ce2:	623b      	str	r3, [r7, #32]
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
 8025ce4:	7abb      	ldrb	r3, [r7, #10]
 8025ce6:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8025cea:	b2db      	uxtb	r3, r3
 8025cec:	61fb      	str	r3, [r7, #28]
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
 8025cee:	7afb      	ldrb	r3, [r7, #11]
 8025cf0:	f3c3 0302 	ubfx	r3, r3, #0, #3
 8025cf4:	b2db      	uxtb	r3, r3
 8025cf6:	76fb      	strb	r3, [r7, #27]
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 8025cf8:	68fb      	ldr	r3, [r7, #12]
 8025cfa:	683a      	ldr	r2, [r7, #0]
 8025cfc:	3228      	adds	r2, #40	; 0x28
 8025cfe:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8025d02:	617b      	str	r3, [r7, #20]

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 8025d04:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025d06:	43db      	mvns	r3, r3
 8025d08:	697a      	ldr	r2, [r7, #20]
 8025d0a:	4013      	ands	r3, r2
 8025d0c:	617b      	str	r3, [r7, #20]
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 8025d0e:	7efa      	ldrb	r2, [r7, #27]
 8025d10:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8025d12:	fa02 f303 	lsl.w	r3, r2, r3
 8025d16:	697a      	ldr	r2, [r7, #20]
 8025d18:	4313      	orrs	r3, r2
 8025d1a:	617b      	str	r3, [r7, #20]
  conv_class &= ~(sample_time_mask);
 8025d1c:	6a3b      	ldr	r3, [r7, #32]
 8025d1e:	43db      	mvns	r3, r3
 8025d20:	697a      	ldr	r2, [r7, #20]
 8025d22:	4013      	ands	r3, r2
 8025d24:	617b      	str	r3, [r7, #20]
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 8025d26:	69fa      	ldr	r2, [r7, #28]
 8025d28:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8025d2a:	fa02 f303 	lsl.w	r3, r2, r3
 8025d2e:	697a      	ldr	r2, [r7, #20]
 8025d30:	4313      	orrs	r3, r2
 8025d32:	617b      	str	r3, [r7, #20]
  group_ptr->ICLASS[set_num] = conv_class;
 8025d34:	68fb      	ldr	r3, [r7, #12]
 8025d36:	683a      	ldr	r2, [r7, #0]
 8025d38:	3228      	adds	r2, #40	; 0x28
 8025d3a:	6979      	ldr	r1, [r7, #20]
 8025d3c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8025d40:	bf00      	nop
 8025d42:	3734      	adds	r7, #52	; 0x34
 8025d44:	46bd      	mov	sp, r7
 8025d46:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025d4a:	4770      	bx	lr

08025d4c <XMC_VADC_GROUP_SetPowerMode>:

/* API which sets the power mode of analog converter of a VADC group */
void XMC_VADC_GROUP_SetPowerMode(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_POWERMODE_t power_mode)
{
 8025d4c:	b480      	push	{r7}
 8025d4e:	b085      	sub	sp, #20
 8025d50:	af00      	add	r7, sp, #0
 8025d52:	6078      	str	r0, [r7, #4]
 8025d54:	460b      	mov	r3, r1
 8025d56:	70fb      	strb	r3, [r7, #3]
  uint32_t arbcfg;

  XMC_ASSERT("XMC_VADC_GROUP_SetPowerMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_SetPowerMode:Wrong Power Mode", (power_mode <= XMC_VADC_GROUP_POWERMODE_NORMAL))

  arbcfg = group_ptr->ARBCFG;
 8025d58:	687b      	ldr	r3, [r7, #4]
 8025d5a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8025d5e:	60fb      	str	r3, [r7, #12]

  arbcfg &= ~((uint32_t)VADC_G_ARBCFG_ANONC_Msk);
 8025d60:	68fb      	ldr	r3, [r7, #12]
 8025d62:	f023 0303 	bic.w	r3, r3, #3
 8025d66:	60fb      	str	r3, [r7, #12]
  arbcfg |= (uint32_t)power_mode;
 8025d68:	78fb      	ldrb	r3, [r7, #3]
 8025d6a:	68fa      	ldr	r2, [r7, #12]
 8025d6c:	4313      	orrs	r3, r2
 8025d6e:	60fb      	str	r3, [r7, #12]

  group_ptr->ARBCFG = arbcfg;
 8025d70:	687b      	ldr	r3, [r7, #4]
 8025d72:	68fa      	ldr	r2, [r7, #12]
 8025d74:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
}
 8025d78:	bf00      	nop
 8025d7a:	3714      	adds	r7, #20
 8025d7c:	46bd      	mov	sp, r7
 8025d7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025d82:	4770      	bx	lr

08025d84 <XMC_VADC_GROUP_SetBoundaries>:
  return ( (XMC_VADC_GROUP_STATE_t)arbcfg);
}

/* API to set boundaries for conversion results */
void XMC_VADC_GROUP_SetBoundaries(XMC_VADC_GROUP_t *const group_ptr, const uint32_t boundary0, const uint32_t boundary1)
{
 8025d84:	b480      	push	{r7}
 8025d86:	b087      	sub	sp, #28
 8025d88:	af00      	add	r7, sp, #0
 8025d8a:	60f8      	str	r0, [r7, #12]
 8025d8c:	60b9      	str	r1, [r7, #8]
 8025d8e:	607a      	str	r2, [r7, #4]
  uint32_t bound;

  XMC_ASSERT("XMC_VADC_GROUP_SetBoundaries:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  /* Program the Boundary registers */
  bound  = group_ptr->BOUND;
 8025d90:	68fb      	ldr	r3, [r7, #12]
 8025d92:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8025d96:	617b      	str	r3, [r7, #20]
  bound &= ~((uint32_t) VADC_G_BOUND_BOUNDARY0_Msk);
 8025d98:	697b      	ldr	r3, [r7, #20]
 8025d9a:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 8025d9e:	f023 030f 	bic.w	r3, r3, #15
 8025da2:	617b      	str	r3, [r7, #20]
  bound &= ~((uint32_t) VADC_G_BOUND_BOUNDARY1_Msk);
 8025da4:	697b      	ldr	r3, [r7, #20]
 8025da6:	f023 637f 	bic.w	r3, r3, #267386880	; 0xff00000
 8025daa:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
 8025dae:	617b      	str	r3, [r7, #20]
  bound |= (uint32_t) ((uint32_t) boundary0 << VADC_G_BOUND_BOUNDARY0_Pos);
 8025db0:	697a      	ldr	r2, [r7, #20]
 8025db2:	68bb      	ldr	r3, [r7, #8]
 8025db4:	4313      	orrs	r3, r2
 8025db6:	617b      	str	r3, [r7, #20]
  bound |= (uint32_t) ((uint32_t) boundary1 << VADC_G_BOUND_BOUNDARY1_Pos);
 8025db8:	687b      	ldr	r3, [r7, #4]
 8025dba:	041b      	lsls	r3, r3, #16
 8025dbc:	697a      	ldr	r2, [r7, #20]
 8025dbe:	4313      	orrs	r3, r2
 8025dc0:	617b      	str	r3, [r7, #20]
  group_ptr->BOUND = bound;
 8025dc2:	68fb      	ldr	r3, [r7, #12]
 8025dc4:	697a      	ldr	r2, [r7, #20]
 8025dc6:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
}
 8025dca:	bf00      	nop
 8025dcc:	371c      	adds	r7, #28
 8025dce:	46bd      	mov	sp, r7
 8025dd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025dd4:	4770      	bx	lr
	...

08025dd8 <XMC_VADC_GLOBAL_BackgroundInit>:
}
#endif

/* API to initialize background scan request source hardware */
void XMC_VADC_GLOBAL_BackgroundInit(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_BACKGROUND_CONFIG_t *config)
{
 8025dd8:	b580      	push	{r7, lr}
 8025dda:	b086      	sub	sp, #24
 8025ddc:	af00      	add	r7, sp, #0
 8025dde:	6078      	str	r0, [r7, #4]
 8025de0:	6039      	str	r1, [r7, #0]
#endif

  XMC_ASSERT("XMC_VADC_GLOBAL_BackgroundInit:Wrong Module Pointer", (global_ptr == VADC))

#if (XMC_VADC_GROUP_AVAILABLE ==1U)
  for (i = (uint8_t)0; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 8025de2:	2300      	movs	r3, #0
 8025de4:	75fb      	strb	r3, [r7, #23]
 8025de6:	e009      	b.n	8025dfc <XMC_VADC_GLOBAL_BackgroundInit+0x24>
  {
    XMC_VADC_GROUP_BackgroundDisableArbitrationSlot((XMC_VADC_GROUP_t *)g_xmc_vadc_group_array[i]);
 8025de8:	7dfb      	ldrb	r3, [r7, #23]
 8025dea:	4a3a      	ldr	r2, [pc, #232]	; (8025ed4 <XMC_VADC_GLOBAL_BackgroundInit+0xfc>)
 8025dec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8025df0:	4618      	mov	r0, r3
 8025df2:	f7ff fe30 	bl	8025a56 <XMC_VADC_GROUP_BackgroundDisableArbitrationSlot>
  for (i = (uint8_t)0; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 8025df6:	7dfb      	ldrb	r3, [r7, #23]
 8025df8:	3301      	adds	r3, #1
 8025dfa:	75fb      	strb	r3, [r7, #23]
 8025dfc:	7dfb      	ldrb	r3, [r7, #23]
 8025dfe:	2b03      	cmp	r3, #3
 8025e00:	d9f2      	bls.n	8025de8 <XMC_VADC_GLOBAL_BackgroundInit+0x10>
  }

  conv_start_mask = (uint32_t) 0;
 8025e02:	2300      	movs	r3, #0
 8025e04:	613b      	str	r3, [r7, #16]
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)config->conv_start_mode)
 8025e06:	683b      	ldr	r3, [r7, #0]
 8025e08:	781b      	ldrb	r3, [r3, #0]
 8025e0a:	f003 0303 	and.w	r3, r3, #3
 8025e0e:	b2db      	uxtb	r3, r3
 8025e10:	2b00      	cmp	r3, #0
 8025e12:	d002      	beq.n	8025e1a <XMC_VADC_GLOBAL_BackgroundInit+0x42>
  {
    conv_start_mask = (uint32_t)VADC_G_ARBPR_CSM2_Msk;
 8025e14:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8025e18:	613b      	str	r3, [r7, #16]
  }

  for (i = 0U; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 8025e1a:	2300      	movs	r3, #0
 8025e1c:	75fb      	strb	r3, [r7, #23]
 8025e1e:	e021      	b.n	8025e64 <XMC_VADC_GLOBAL_BackgroundInit+0x8c>
  {
    reg = g_xmc_vadc_group_array[i]->ARBPR;
 8025e20:	7dfb      	ldrb	r3, [r7, #23]
 8025e22:	4a2c      	ldr	r2, [pc, #176]	; (8025ed4 <XMC_VADC_GLOBAL_BackgroundInit+0xfc>)
 8025e24:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8025e28:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8025e2c:	60fb      	str	r3, [r7, #12]

    reg &= ~(uint32_t)(VADC_G_ARBPR_PRIO2_Msk);
 8025e2e:	68fb      	ldr	r3, [r7, #12]
 8025e30:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8025e34:	60fb      	str	r3, [r7, #12]

    /* Program the priority of the request source */
    reg |= (uint32_t)((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO2_Pos);
 8025e36:	683b      	ldr	r3, [r7, #0]
 8025e38:	781b      	ldrb	r3, [r3, #0]
 8025e3a:	f3c3 0381 	ubfx	r3, r3, #2, #2
 8025e3e:	b2db      	uxtb	r3, r3
 8025e40:	021b      	lsls	r3, r3, #8
 8025e42:	68fa      	ldr	r2, [r7, #12]
 8025e44:	4313      	orrs	r3, r2
 8025e46:	60fb      	str	r3, [r7, #12]

    /* Program the start mode */
    reg |= conv_start_mask;
 8025e48:	68fa      	ldr	r2, [r7, #12]
 8025e4a:	693b      	ldr	r3, [r7, #16]
 8025e4c:	4313      	orrs	r3, r2
 8025e4e:	60fb      	str	r3, [r7, #12]

    g_xmc_vadc_group_array[i]->ARBPR = reg;
 8025e50:	7dfb      	ldrb	r3, [r7, #23]
 8025e52:	4a20      	ldr	r2, [pc, #128]	; (8025ed4 <XMC_VADC_GLOBAL_BackgroundInit+0xfc>)
 8025e54:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8025e58:	68fa      	ldr	r2, [r7, #12]
 8025e5a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  for (i = 0U; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 8025e5e:	7dfb      	ldrb	r3, [r7, #23]
 8025e60:	3301      	adds	r3, #1
 8025e62:	75fb      	strb	r3, [r7, #23]
 8025e64:	7dfb      	ldrb	r3, [r7, #23]
 8025e66:	2b03      	cmp	r3, #3
 8025e68:	d9da      	bls.n	8025e20 <XMC_VADC_GLOBAL_BackgroundInit+0x48>

  }
#endif

  /* program BRSCTRL register */
  global_ptr->BRSCTRL = (uint32_t)(config->asctrl | (uint32_t)VADC_BRSCTRL_XTWC_Msk | (uint32_t)VADC_BRSCTRL_GTWC_Msk);
 8025e6a:	683b      	ldr	r3, [r7, #0]
 8025e6c:	685b      	ldr	r3, [r3, #4]
 8025e6e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8025e72:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8025e76:	687a      	ldr	r2, [r7, #4]
 8025e78:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

  /* program BRSMR register */
  global_ptr->BRSMR = (uint32_t)((config->asmr) | (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_BRSMR_ENGT_Pos));
 8025e7c:	683b      	ldr	r3, [r7, #0]
 8025e7e:	689b      	ldr	r3, [r3, #8]
 8025e80:	f043 0201 	orr.w	r2, r3, #1
 8025e84:	687b      	ldr	r3, [r7, #4]
 8025e86:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204

#if (XMC_VADC_GROUP_AVAILABLE ==1U)
  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
 8025e8a:	683b      	ldr	r3, [r7, #0]
 8025e8c:	781b      	ldrb	r3, [r3, #0]
 8025e8e:	f003 0303 	and.w	r3, r3, #3
 8025e92:	b2db      	uxtb	r3, r3
 8025e94:	2b02      	cmp	r3, #2
 8025e96:	d107      	bne.n	8025ea8 <XMC_VADC_GLOBAL_BackgroundInit+0xd0>
  {
    global_ptr->BRSMR |= (uint32_t)VADC_BRSMR_RPTDIS_Msk;
 8025e98:	687b      	ldr	r3, [r7, #4]
 8025e9a:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
 8025e9e:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 8025ea2:	687b      	ldr	r3, [r7, #4]
 8025ea4:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
  }
#endif

#if (XMC_VADC_GROUP_AVAILABLE ==1U)
  for (i = (uint8_t)0; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 8025ea8:	2300      	movs	r3, #0
 8025eaa:	75fb      	strb	r3, [r7, #23]
 8025eac:	e009      	b.n	8025ec2 <XMC_VADC_GLOBAL_BackgroundInit+0xea>
  {
    XMC_VADC_GROUP_BackgroundEnableArbitrationSlot((XMC_VADC_GROUP_t *)g_xmc_vadc_group_array[i]);
 8025eae:	7dfb      	ldrb	r3, [r7, #23]
 8025eb0:	4a08      	ldr	r2, [pc, #32]	; (8025ed4 <XMC_VADC_GLOBAL_BackgroundInit+0xfc>)
 8025eb2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8025eb6:	4618      	mov	r0, r3
 8025eb8:	f7ff fdbb 	bl	8025a32 <XMC_VADC_GROUP_BackgroundEnableArbitrationSlot>
  for (i = (uint8_t)0; i < XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 8025ebc:	7dfb      	ldrb	r3, [r7, #23]
 8025ebe:	3301      	adds	r3, #1
 8025ec0:	75fb      	strb	r3, [r7, #23]
 8025ec2:	7dfb      	ldrb	r3, [r7, #23]
 8025ec4:	2b03      	cmp	r3, #3
 8025ec6:	d9f2      	bls.n	8025eae <XMC_VADC_GLOBAL_BackgroundInit+0xd6>
  }
#endif

}
 8025ec8:	bf00      	nop
 8025eca:	bf00      	nop
 8025ecc:	3718      	adds	r7, #24
 8025ece:	46bd      	mov	sp, r7
 8025ed0:	bd80      	pop	{r7, pc}
 8025ed2:	bf00      	nop
 8025ed4:	080284a4 	.word	0x080284a4

08025ed8 <XMC_VADC_GROUP_QueueInit>:
}

#if (XMC_VADC_QUEUE_AVAILABLE == 1U)
/* API to initialize queue request source */
void XMC_VADC_GROUP_QueueInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_QUEUE_CONFIG_t *config)
{
 8025ed8:	b580      	push	{r7, lr}
 8025eda:	b084      	sub	sp, #16
 8025edc:	af00      	add	r7, sp, #0
 8025ede:	6078      	str	r0, [r7, #4]
 8025ee0:	6039      	str	r1, [r7, #0]
  uint32_t          reg;

  XMC_ASSERT("XMC_VADC_GROUP_QueueInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  /* Disable arbitration slot of the queue request source */
  XMC_VADC_GROUP_QueueDisableArbitrationSlot(group_ptr);
 8025ee2:	6878      	ldr	r0, [r7, #4]
 8025ee4:	f7ff fddb 	bl	8025a9e <XMC_VADC_GROUP_QueueDisableArbitrationSlot>

  reg = group_ptr->ARBPR;
 8025ee8:	687b      	ldr	r3, [r7, #4]
 8025eea:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8025eee:	60fb      	str	r3, [r7, #12]

  /* Request Source priority */
  reg &= ~((uint32_t)VADC_G_ARBPR_PRIO0_Msk);
 8025ef0:	68fb      	ldr	r3, [r7, #12]
 8025ef2:	f023 0303 	bic.w	r3, r3, #3
 8025ef6:	60fb      	str	r3, [r7, #12]
  reg |= (uint32_t) ((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO0_Pos);
 8025ef8:	683b      	ldr	r3, [r7, #0]
 8025efa:	781b      	ldrb	r3, [r3, #0]
 8025efc:	f3c3 0381 	ubfx	r3, r3, #2, #2
 8025f00:	b2db      	uxtb	r3, r3
 8025f02:	461a      	mov	r2, r3
 8025f04:	68fb      	ldr	r3, [r7, #12]
 8025f06:	4313      	orrs	r3, r2
 8025f08:	60fb      	str	r3, [r7, #12]

  /* Conversion Start mode */
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)config->conv_start_mode)
 8025f0a:	683b      	ldr	r3, [r7, #0]
 8025f0c:	781b      	ldrb	r3, [r3, #0]
 8025f0e:	f003 0303 	and.w	r3, r3, #3
 8025f12:	b2db      	uxtb	r3, r3
 8025f14:	2b00      	cmp	r3, #0
 8025f16:	d003      	beq.n	8025f20 <XMC_VADC_GROUP_QueueInit+0x48>
  {
    reg |= (uint32_t)(VADC_G_ARBPR_CSM0_Msk);
 8025f18:	68fb      	ldr	r3, [r7, #12]
 8025f1a:	f043 0308 	orr.w	r3, r3, #8
 8025f1e:	60fb      	str	r3, [r7, #12]
  }

  group_ptr->ARBPR = reg;
 8025f20:	687b      	ldr	r3, [r7, #4]
 8025f22:	68fa      	ldr	r2, [r7, #12]
 8025f24:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84


  group_ptr->QCTRL0 = (uint32_t)((config->qctrl0) | (uint32_t)(VADC_G_QCTRL0_XTWC_Msk) |
 8025f28:	683b      	ldr	r3, [r7, #0]
 8025f2a:	685b      	ldr	r3, [r3, #4]
 8025f2c:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 8025f30:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8025f34:	687a      	ldr	r2, [r7, #4]
 8025f36:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
                                 (uint32_t)(VADC_G_QCTRL0_TMWC_Msk) |
                                 (uint32_t)(VADC_G_QCTRL0_GTWC_Msk));

  /* Gating mode */
  group_ptr->QMR0 = ((uint32_t)(config->qmr0) | (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_QMR0_ENGT_Pos));
 8025f3a:	683b      	ldr	r3, [r7, #0]
 8025f3c:	689b      	ldr	r3, [r3, #8]
 8025f3e:	f043 0201 	orr.w	r2, r3, #1
 8025f42:	687b      	ldr	r3, [r7, #4]
 8025f44:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104

  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode) )
 8025f48:	683b      	ldr	r3, [r7, #0]
 8025f4a:	781b      	ldrb	r3, [r3, #0]
 8025f4c:	f003 0303 	and.w	r3, r3, #3
 8025f50:	b2db      	uxtb	r3, r3
 8025f52:	2b02      	cmp	r3, #2
 8025f54:	d107      	bne.n	8025f66 <XMC_VADC_GROUP_QueueInit+0x8e>
  {
    group_ptr->QMR0 |= (uint32_t)((uint32_t)1 << VADC_G_QMR0_RPTDIS_Pos);
 8025f56:	687b      	ldr	r3, [r7, #4]
 8025f58:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8025f5c:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 8025f60:	687b      	ldr	r3, [r7, #4]
 8025f62:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  }
  /* Enable arbitration slot for the queue request source */
  XMC_VADC_GROUP_QueueEnableArbitrationSlot(group_ptr);
 8025f66:	6878      	ldr	r0, [r7, #4]
 8025f68:	f7ff fd87 	bl	8025a7a <XMC_VADC_GROUP_QueueEnableArbitrationSlot>

}
 8025f6c:	bf00      	nop
 8025f6e:	3710      	adds	r7, #16
 8025f70:	46bd      	mov	sp, r7
 8025f72:	bd80      	pop	{r7, pc}

08025f74 <XMC_VADC_GROUP_ChannelInit>:

#if (XMC_VADC_GROUP_AVAILABLE ==1U)
/* API to initialize a channel unit */
void XMC_VADC_GROUP_ChannelInit(XMC_VADC_GROUP_t *const group_ptr, const uint32_t ch_num,
                                const XMC_VADC_CHANNEL_CONFIG_t *config)
{
 8025f74:	b480      	push	{r7}
 8025f76:	b089      	sub	sp, #36	; 0x24
 8025f78:	af00      	add	r7, sp, #0
 8025f7a:	60f8      	str	r0, [r7, #12]
 8025f7c:	60b9      	str	r1, [r7, #8]
 8025f7e:	607a      	str	r2, [r7, #4]


  XMC_ASSERT("XMC_VADC_GROUP_ChannelInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_ChannelInit:Wrong Channel Number", ((ch_num) < XMC_VADC_NUM_CHANNELS_PER_GROUP))

  prio  = (uint32_t)config->channel_priority;
 8025f80:	687b      	ldr	r3, [r7, #4]
 8025f82:	7b1b      	ldrb	r3, [r3, #12]
 8025f84:	61bb      	str	r3, [r7, #24]

  /* Priority channel */
  ch_assign  = group_ptr->CHASS;
 8025f86:	68fb      	ldr	r3, [r7, #12]
 8025f88:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8025f8c:	617b      	str	r3, [r7, #20]
  ch_assign &= ~((uint32_t)((uint32_t)1 << ch_num));
 8025f8e:	2201      	movs	r2, #1
 8025f90:	68bb      	ldr	r3, [r7, #8]
 8025f92:	fa02 f303 	lsl.w	r3, r2, r3
 8025f96:	43db      	mvns	r3, r3
 8025f98:	697a      	ldr	r2, [r7, #20]
 8025f9a:	4013      	ands	r3, r2
 8025f9c:	617b      	str	r3, [r7, #20]
  ch_assign |= (uint32_t)(prio << ch_num);
 8025f9e:	69ba      	ldr	r2, [r7, #24]
 8025fa0:	68bb      	ldr	r3, [r7, #8]
 8025fa2:	fa02 f303 	lsl.w	r3, r2, r3
 8025fa6:	697a      	ldr	r2, [r7, #20]
 8025fa8:	4313      	orrs	r3, r2
 8025faa:	617b      	str	r3, [r7, #20]
  group_ptr->CHASS = ch_assign;
 8025fac:	68fb      	ldr	r3, [r7, #12]
 8025fae:	697a      	ldr	r2, [r7, #20]
 8025fb0:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Alias channel */
  if (config->alias_channel >= (int32_t)0)
 8025fb4:	687b      	ldr	r3, [r7, #4]
 8025fb6:	f993 300d 	ldrsb.w	r3, [r3, #13]
 8025fba:	2b00      	cmp	r3, #0
 8025fbc:	db2a      	blt.n	8026014 <XMC_VADC_GROUP_ChannelInit+0xa0>
  {
    mask = (uint32_t)0;
 8025fbe:	2300      	movs	r3, #0
 8025fc0:	61fb      	str	r3, [r7, #28]
    if ((uint32_t)1 == ch_num)
 8025fc2:	68bb      	ldr	r3, [r7, #8]
 8025fc4:	2b01      	cmp	r3, #1
 8025fc6:	d10a      	bne.n	8025fde <XMC_VADC_GROUP_ChannelInit+0x6a>
    {
      mask = VADC_G_ALIAS_ALIAS1_Pos;
 8025fc8:	2308      	movs	r3, #8
 8025fca:	61fb      	str	r3, [r7, #28]
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS1_Msk);
 8025fcc:	68fb      	ldr	r3, [r7, #12]
 8025fce:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 8025fd2:	f423 52f8 	bic.w	r2, r3, #7936	; 0x1f00
 8025fd6:	68fb      	ldr	r3, [r7, #12]
 8025fd8:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
 8025fdc:	e00c      	b.n	8025ff8 <XMC_VADC_GROUP_ChannelInit+0x84>
    }
    else if ((uint32_t)0 == ch_num)
 8025fde:	68bb      	ldr	r3, [r7, #8]
 8025fe0:	2b00      	cmp	r3, #0
 8025fe2:	d109      	bne.n	8025ff8 <XMC_VADC_GROUP_ChannelInit+0x84>
    {
      mask = VADC_G_ALIAS_ALIAS0_Pos;
 8025fe4:	2300      	movs	r3, #0
 8025fe6:	61fb      	str	r3, [r7, #28]
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS0_Msk);
 8025fe8:	68fb      	ldr	r3, [r7, #12]
 8025fea:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 8025fee:	f023 021f 	bic.w	r2, r3, #31
 8025ff2:	68fb      	ldr	r3, [r7, #12]
 8025ff4:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
    }

    group_ptr->ALIAS |= (uint32_t)(config->alias_channel << mask);
 8025ff8:	68fb      	ldr	r3, [r7, #12]
 8025ffa:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 8025ffe:	687a      	ldr	r2, [r7, #4]
 8026000:	f992 200d 	ldrsb.w	r2, [r2, #13]
 8026004:	4611      	mov	r1, r2
 8026006:	69fa      	ldr	r2, [r7, #28]
 8026008:	fa01 f202 	lsl.w	r2, r1, r2
 802600c:	431a      	orrs	r2, r3
 802600e:	68fb      	ldr	r3, [r7, #12]
 8026010:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
  }

  group_ptr->BFL |= config->bfl;
 8026014:	68fb      	ldr	r3, [r7, #12]
 8026016:	f8d3 20c8 	ldr.w	r2, [r3, #200]	; 0xc8
 802601a:	687b      	ldr	r3, [r7, #4]
 802601c:	685b      	ldr	r3, [r3, #4]
 802601e:	431a      	orrs	r2, r3
 8026020:	68fb      	ldr	r3, [r7, #12]
 8026022:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8

#if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
  group_ptr->BFLC |= config->bflc;
 8026026:	68fb      	ldr	r3, [r7, #12]
 8026028:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
 802602c:	687b      	ldr	r3, [r7, #4]
 802602e:	689b      	ldr	r3, [r3, #8]
 8026030:	431a      	orrs	r2, r3
 8026032:	68fb      	ldr	r3, [r7, #12]
 8026034:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
#endif
  /* Program the CHCTR register */
  group_ptr->CHCTR[ch_num] = config->chctr;
 8026038:	687b      	ldr	r3, [r7, #4]
 802603a:	6819      	ldr	r1, [r3, #0]
 802603c:	68fb      	ldr	r3, [r7, #12]
 802603e:	68ba      	ldr	r2, [r7, #8]
 8026040:	3280      	adds	r2, #128	; 0x80
 8026042:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

}
 8026046:	bf00      	nop
 8026048:	3724      	adds	r7, #36	; 0x24
 802604a:	46bd      	mov	sp, r7
 802604c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026050:	4770      	bx	lr

08026052 <XMC_VADC_GROUP_ChannelSetEventInterruptNode>:

/* API to bind channel event with a service request (NVIC Node) */
void XMC_VADC_GROUP_ChannelSetEventInterruptNode(XMC_VADC_GROUP_t *const group_ptr,
    const uint32_t ch_num,
    const XMC_VADC_SR_t sr)
{
 8026052:	b480      	push	{r7}
 8026054:	b087      	sub	sp, #28
 8026056:	af00      	add	r7, sp, #0
 8026058:	60f8      	str	r0, [r7, #12]
 802605a:	60b9      	str	r1, [r7, #8]
 802605c:	4613      	mov	r3, r2
 802605e:	71fb      	strb	r3, [r7, #7]
  XMC_ASSERT("XMC_VADC_GROUP_ChannelSetEventInterruptNode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_ChannelSetEventInterruptNode:Wrong Channel Number",
             ((ch_num) < XMC_VADC_NUM_CHANNELS_PER_GROUP))
  XMC_ASSERT("XMC_VADC_GROUP_ChannelSetEventInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  route_mask  = group_ptr->CEVNP0;
 8026060:	68fb      	ldr	r3, [r7, #12]
 8026062:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 8026066:	617b      	str	r3, [r7, #20]
  route_mask &= ~((uint32_t)15 << (ch_num * (uint32_t)4));
 8026068:	68bb      	ldr	r3, [r7, #8]
 802606a:	009b      	lsls	r3, r3, #2
 802606c:	220f      	movs	r2, #15
 802606e:	fa02 f303 	lsl.w	r3, r2, r3
 8026072:	43db      	mvns	r3, r3
 8026074:	697a      	ldr	r2, [r7, #20]
 8026076:	4013      	ands	r3, r2
 8026078:	617b      	str	r3, [r7, #20]
  route_mask |= (uint32_t)( (uint32_t)sr << (ch_num * (uint32_t)4));
 802607a:	79fa      	ldrb	r2, [r7, #7]
 802607c:	68bb      	ldr	r3, [r7, #8]
 802607e:	009b      	lsls	r3, r3, #2
 8026080:	fa02 f303 	lsl.w	r3, r2, r3
 8026084:	697a      	ldr	r2, [r7, #20]
 8026086:	4313      	orrs	r3, r2
 8026088:	617b      	str	r3, [r7, #20]
  group_ptr->CEVNP0 = route_mask;
 802608a:	68fb      	ldr	r3, [r7, #12]
 802608c:	697a      	ldr	r2, [r7, #20]
 802608e:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0
}
 8026092:	bf00      	nop
 8026094:	371c      	adds	r7, #28
 8026096:	46bd      	mov	sp, r7
 8026098:	f85d 7b04 	ldr.w	r7, [sp], #4
 802609c:	4770      	bx	lr

0802609e <_init>:
  }
}

/* Init */
void _init(void)
{}
 802609e:	b480      	push	{r7}
 80260a0:	af00      	add	r7, sp, #0
 80260a2:	bf00      	nop
 80260a4:	46bd      	mov	sp, r7
 80260a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80260aa:	4770      	bx	lr

080260ac <__NVIC_GetPriorityGrouping>:
{
 80260ac:	b480      	push	{r7}
 80260ae:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80260b0:	4b04      	ldr	r3, [pc, #16]	; (80260c4 <__NVIC_GetPriorityGrouping+0x18>)
 80260b2:	68db      	ldr	r3, [r3, #12]
 80260b4:	0a1b      	lsrs	r3, r3, #8
 80260b6:	f003 0307 	and.w	r3, r3, #7
}
 80260ba:	4618      	mov	r0, r3
 80260bc:	46bd      	mov	sp, r7
 80260be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80260c2:	4770      	bx	lr
 80260c4:	e000ed00 	.word	0xe000ed00

080260c8 <__NVIC_SetPriority>:
{
 80260c8:	b480      	push	{r7}
 80260ca:	b083      	sub	sp, #12
 80260cc:	af00      	add	r7, sp, #0
 80260ce:	4603      	mov	r3, r0
 80260d0:	6039      	str	r1, [r7, #0]
 80260d2:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80260d4:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80260d8:	2b00      	cmp	r3, #0
 80260da:	db0a      	blt.n	80260f2 <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80260dc:	683b      	ldr	r3, [r7, #0]
 80260de:	b2da      	uxtb	r2, r3
 80260e0:	490c      	ldr	r1, [pc, #48]	; (8026114 <__NVIC_SetPriority+0x4c>)
 80260e2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80260e6:	0092      	lsls	r2, r2, #2
 80260e8:	b2d2      	uxtb	r2, r2
 80260ea:	440b      	add	r3, r1
 80260ec:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 80260f0:	e00a      	b.n	8026108 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80260f2:	683b      	ldr	r3, [r7, #0]
 80260f4:	b2da      	uxtb	r2, r3
 80260f6:	4908      	ldr	r1, [pc, #32]	; (8026118 <__NVIC_SetPriority+0x50>)
 80260f8:	79fb      	ldrb	r3, [r7, #7]
 80260fa:	f003 030f 	and.w	r3, r3, #15
 80260fe:	3b04      	subs	r3, #4
 8026100:	0092      	lsls	r2, r2, #2
 8026102:	b2d2      	uxtb	r2, r2
 8026104:	440b      	add	r3, r1
 8026106:	761a      	strb	r2, [r3, #24]
}
 8026108:	bf00      	nop
 802610a:	370c      	adds	r7, #12
 802610c:	46bd      	mov	sp, r7
 802610e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026112:	4770      	bx	lr
 8026114:	e000e100 	.word	0xe000e100
 8026118:	e000ed00 	.word	0xe000ed00

0802611c <NVIC_EncodePriority>:
{
 802611c:	b480      	push	{r7}
 802611e:	b089      	sub	sp, #36	; 0x24
 8026120:	af00      	add	r7, sp, #0
 8026122:	60f8      	str	r0, [r7, #12]
 8026124:	60b9      	str	r1, [r7, #8]
 8026126:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8026128:	68fb      	ldr	r3, [r7, #12]
 802612a:	f003 0307 	and.w	r3, r3, #7
 802612e:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8026130:	69fb      	ldr	r3, [r7, #28]
 8026132:	f1c3 0307 	rsb	r3, r3, #7
 8026136:	2b06      	cmp	r3, #6
 8026138:	bf28      	it	cs
 802613a:	2306      	movcs	r3, #6
 802613c:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802613e:	69fb      	ldr	r3, [r7, #28]
 8026140:	3306      	adds	r3, #6
 8026142:	2b06      	cmp	r3, #6
 8026144:	d902      	bls.n	802614c <NVIC_EncodePriority+0x30>
 8026146:	69fb      	ldr	r3, [r7, #28]
 8026148:	3b01      	subs	r3, #1
 802614a:	e000      	b.n	802614e <NVIC_EncodePriority+0x32>
 802614c:	2300      	movs	r3, #0
 802614e:	617b      	str	r3, [r7, #20]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8026150:	f04f 32ff 	mov.w	r2, #4294967295
 8026154:	69bb      	ldr	r3, [r7, #24]
 8026156:	fa02 f303 	lsl.w	r3, r2, r3
 802615a:	43da      	mvns	r2, r3
 802615c:	68bb      	ldr	r3, [r7, #8]
 802615e:	401a      	ands	r2, r3
 8026160:	697b      	ldr	r3, [r7, #20]
 8026162:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8026164:	f04f 31ff 	mov.w	r1, #4294967295
 8026168:	697b      	ldr	r3, [r7, #20]
 802616a:	fa01 f303 	lsl.w	r3, r1, r3
 802616e:	43d9      	mvns	r1, r3
 8026170:	687b      	ldr	r3, [r7, #4]
 8026172:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8026174:	4313      	orrs	r3, r2
}
 8026176:	4618      	mov	r0, r3
 8026178:	3724      	adds	r7, #36	; 0x24
 802617a:	46bd      	mov	sp, r7
 802617c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026180:	4770      	bx	lr
	...

08026184 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8026184:	b580      	push	{r7, lr}
 8026186:	b082      	sub	sp, #8
 8026188:	af00      	add	r7, sp, #0
 802618a:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 802618c:	687b      	ldr	r3, [r7, #4]
 802618e:	3b01      	subs	r3, #1
 8026190:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8026194:	d301      	bcc.n	802619a <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 8026196:	2301      	movs	r3, #1
 8026198:	e00f      	b.n	80261ba <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 802619a:	4a0a      	ldr	r2, [pc, #40]	; (80261c4 <SysTick_Config+0x40>)
 802619c:	687b      	ldr	r3, [r7, #4]
 802619e:	3b01      	subs	r3, #1
 80261a0:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 80261a2:	213f      	movs	r1, #63	; 0x3f
 80261a4:	f04f 30ff 	mov.w	r0, #4294967295
 80261a8:	f7ff ff8e 	bl	80260c8 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80261ac:	4b05      	ldr	r3, [pc, #20]	; (80261c4 <SysTick_Config+0x40>)
 80261ae:	2200      	movs	r2, #0
 80261b0:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80261b2:	4b04      	ldr	r3, [pc, #16]	; (80261c4 <SysTick_Config+0x40>)
 80261b4:	2207      	movs	r2, #7
 80261b6:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 80261b8:	2300      	movs	r3, #0
}
 80261ba:	4618      	mov	r0, r3
 80261bc:	3708      	adds	r7, #8
 80261be:	46bd      	mov	sp, r7
 80261c0:	bd80      	pop	{r7, pc}
 80261c2:	bf00      	nop
 80261c4:	e000e010 	.word	0xe000e010

080261c8 <SYSTIMER_lInsertTimerList>:
**********************************************************************************************************************/
/*
 * This function is called to insert a timer into the timer list.
 */
static void SYSTIMER_lInsertTimerList(uint32_t tbl_index)
{
 80261c8:	b490      	push	{r4, r7}
 80261ca:	b086      	sub	sp, #24
 80261cc:	af00      	add	r7, sp, #0
 80261ce:	6078      	str	r0, [r7, #4]
  SYSTIMER_OBJECT_t *object_ptr;
  int32_t delta_ticks;
  int32_t timer_count;
  bool found_flag = false;
 80261d0:	2300      	movs	r3, #0
 80261d2:	73fb      	strb	r3, [r7, #15]
   /* Get timer time */
  timer_count = (int32_t)g_timer_tbl[tbl_index].count;
 80261d4:	496d      	ldr	r1, [pc, #436]	; (802638c <SYSTIMER_lInsertTimerList+0x1c4>)
 80261d6:	687a      	ldr	r2, [r7, #4]
 80261d8:	4613      	mov	r3, r2
 80261da:	00db      	lsls	r3, r3, #3
 80261dc:	4413      	add	r3, r2
 80261de:	009b      	lsls	r3, r3, #2
 80261e0:	440b      	add	r3, r1
 80261e2:	3318      	adds	r3, #24
 80261e4:	681b      	ldr	r3, [r3, #0]
 80261e6:	60bb      	str	r3, [r7, #8]
  /* Check if Timer list is NULL */
  if (NULL == g_timer_list)
 80261e8:	4b69      	ldr	r3, [pc, #420]	; (8026390 <SYSTIMER_lInsertTimerList+0x1c8>)
 80261ea:	681b      	ldr	r3, [r3, #0]
 80261ec:	2b00      	cmp	r3, #0
 80261ee:	d109      	bne.n	8026204 <SYSTIMER_lInsertTimerList+0x3c>
  {
    /* Set this as first Timer */
    g_timer_list = &g_timer_tbl[tbl_index];
 80261f0:	687a      	ldr	r2, [r7, #4]
 80261f2:	4613      	mov	r3, r2
 80261f4:	00db      	lsls	r3, r3, #3
 80261f6:	4413      	add	r3, r2
 80261f8:	009b      	lsls	r3, r3, #2
 80261fa:	4a64      	ldr	r2, [pc, #400]	; (802638c <SYSTIMER_lInsertTimerList+0x1c4>)
 80261fc:	4413      	add	r3, r2
 80261fe:	4a64      	ldr	r2, [pc, #400]	; (8026390 <SYSTIMER_lInsertTimerList+0x1c8>)
 8026200:	6013      	str	r3, [r2, #0]
      }
      /* Get the next item in timer list */
      object_ptr = object_ptr->next;
    }
  }
}
 8026202:	e0bd      	b.n	8026380 <SYSTIMER_lInsertTimerList+0x1b8>
    object_ptr = g_timer_list;
 8026204:	4b62      	ldr	r3, [pc, #392]	; (8026390 <SYSTIMER_lInsertTimerList+0x1c8>)
 8026206:	681b      	ldr	r3, [r3, #0]
 8026208:	617b      	str	r3, [r7, #20]
    delta_ticks = timer_count;
 802620a:	68bb      	ldr	r3, [r7, #8]
 802620c:	613b      	str	r3, [r7, #16]
    while ((NULL != object_ptr) && (false == found_flag))
 802620e:	e0ad      	b.n	802636c <SYSTIMER_lInsertTimerList+0x1a4>
      delta_ticks -= (int32_t)object_ptr->count;
 8026210:	697b      	ldr	r3, [r7, #20]
 8026212:	699b      	ldr	r3, [r3, #24]
 8026214:	461a      	mov	r2, r3
 8026216:	693b      	ldr	r3, [r7, #16]
 8026218:	1a9b      	subs	r3, r3, r2
 802621a:	613b      	str	r3, [r7, #16]
      if (delta_ticks <= 0)
 802621c:	693b      	ldr	r3, [r7, #16]
 802621e:	2b00      	cmp	r3, #0
 8026220:	dc7b      	bgt.n	802631a <SYSTIMER_lInsertTimerList+0x152>
        if (NULL != object_ptr->prev)
 8026222:	697b      	ldr	r3, [r7, #20]
 8026224:	685b      	ldr	r3, [r3, #4]
 8026226:	2b00      	cmp	r3, #0
 8026228:	d027      	beq.n	802627a <SYSTIMER_lInsertTimerList+0xb2>
          object_ptr->prev->next = &g_timer_tbl[tbl_index];
 802622a:	697b      	ldr	r3, [r7, #20]
 802622c:	6859      	ldr	r1, [r3, #4]
 802622e:	687a      	ldr	r2, [r7, #4]
 8026230:	4613      	mov	r3, r2
 8026232:	00db      	lsls	r3, r3, #3
 8026234:	4413      	add	r3, r2
 8026236:	009b      	lsls	r3, r3, #2
 8026238:	4a54      	ldr	r2, [pc, #336]	; (802638c <SYSTIMER_lInsertTimerList+0x1c4>)
 802623a:	4413      	add	r3, r2
 802623c:	600b      	str	r3, [r1, #0]
          g_timer_tbl[tbl_index].prev = object_ptr->prev;
 802623e:	697b      	ldr	r3, [r7, #20]
 8026240:	6859      	ldr	r1, [r3, #4]
 8026242:	4852      	ldr	r0, [pc, #328]	; (802638c <SYSTIMER_lInsertTimerList+0x1c4>)
 8026244:	687a      	ldr	r2, [r7, #4]
 8026246:	4613      	mov	r3, r2
 8026248:	00db      	lsls	r3, r3, #3
 802624a:	4413      	add	r3, r2
 802624c:	009b      	lsls	r3, r3, #2
 802624e:	4403      	add	r3, r0
 8026250:	3304      	adds	r3, #4
 8026252:	6019      	str	r1, [r3, #0]
          g_timer_tbl[tbl_index].next = object_ptr;
 8026254:	494d      	ldr	r1, [pc, #308]	; (802638c <SYSTIMER_lInsertTimerList+0x1c4>)
 8026256:	687a      	ldr	r2, [r7, #4]
 8026258:	4613      	mov	r3, r2
 802625a:	00db      	lsls	r3, r3, #3
 802625c:	4413      	add	r3, r2
 802625e:	009b      	lsls	r3, r3, #2
 8026260:	440b      	add	r3, r1
 8026262:	697a      	ldr	r2, [r7, #20]
 8026264:	601a      	str	r2, [r3, #0]
          object_ptr->prev = &g_timer_tbl[tbl_index];
 8026266:	687a      	ldr	r2, [r7, #4]
 8026268:	4613      	mov	r3, r2
 802626a:	00db      	lsls	r3, r3, #3
 802626c:	4413      	add	r3, r2
 802626e:	009b      	lsls	r3, r3, #2
 8026270:	4a46      	ldr	r2, [pc, #280]	; (802638c <SYSTIMER_lInsertTimerList+0x1c4>)
 8026272:	441a      	add	r2, r3
 8026274:	697b      	ldr	r3, [r7, #20]
 8026276:	605a      	str	r2, [r3, #4]
 8026278:	e01c      	b.n	80262b4 <SYSTIMER_lInsertTimerList+0xec>
          g_timer_tbl[tbl_index].next = g_timer_list;
 802627a:	4b45      	ldr	r3, [pc, #276]	; (8026390 <SYSTIMER_lInsertTimerList+0x1c8>)
 802627c:	6819      	ldr	r1, [r3, #0]
 802627e:	4843      	ldr	r0, [pc, #268]	; (802638c <SYSTIMER_lInsertTimerList+0x1c4>)
 8026280:	687a      	ldr	r2, [r7, #4]
 8026282:	4613      	mov	r3, r2
 8026284:	00db      	lsls	r3, r3, #3
 8026286:	4413      	add	r3, r2
 8026288:	009b      	lsls	r3, r3, #2
 802628a:	4403      	add	r3, r0
 802628c:	6019      	str	r1, [r3, #0]
          g_timer_list->prev = &g_timer_tbl[tbl_index];
 802628e:	4b40      	ldr	r3, [pc, #256]	; (8026390 <SYSTIMER_lInsertTimerList+0x1c8>)
 8026290:	6819      	ldr	r1, [r3, #0]
 8026292:	687a      	ldr	r2, [r7, #4]
 8026294:	4613      	mov	r3, r2
 8026296:	00db      	lsls	r3, r3, #3
 8026298:	4413      	add	r3, r2
 802629a:	009b      	lsls	r3, r3, #2
 802629c:	4a3b      	ldr	r2, [pc, #236]	; (802638c <SYSTIMER_lInsertTimerList+0x1c4>)
 802629e:	4413      	add	r3, r2
 80262a0:	604b      	str	r3, [r1, #4]
          g_timer_list = &g_timer_tbl[tbl_index];
 80262a2:	687a      	ldr	r2, [r7, #4]
 80262a4:	4613      	mov	r3, r2
 80262a6:	00db      	lsls	r3, r3, #3
 80262a8:	4413      	add	r3, r2
 80262aa:	009b      	lsls	r3, r3, #2
 80262ac:	4a37      	ldr	r2, [pc, #220]	; (802638c <SYSTIMER_lInsertTimerList+0x1c4>)
 80262ae:	4413      	add	r3, r2
 80262b0:	4a37      	ldr	r2, [pc, #220]	; (8026390 <SYSTIMER_lInsertTimerList+0x1c8>)
 80262b2:	6013      	str	r3, [r2, #0]
        g_timer_tbl[tbl_index].count = g_timer_tbl[tbl_index].next->count + (uint32_t)delta_ticks;
 80262b4:	4935      	ldr	r1, [pc, #212]	; (802638c <SYSTIMER_lInsertTimerList+0x1c4>)
 80262b6:	687a      	ldr	r2, [r7, #4]
 80262b8:	4613      	mov	r3, r2
 80262ba:	00db      	lsls	r3, r3, #3
 80262bc:	4413      	add	r3, r2
 80262be:	009b      	lsls	r3, r3, #2
 80262c0:	440b      	add	r3, r1
 80262c2:	681b      	ldr	r3, [r3, #0]
 80262c4:	699a      	ldr	r2, [r3, #24]
 80262c6:	693b      	ldr	r3, [r7, #16]
 80262c8:	18d1      	adds	r1, r2, r3
 80262ca:	4830      	ldr	r0, [pc, #192]	; (802638c <SYSTIMER_lInsertTimerList+0x1c4>)
 80262cc:	687a      	ldr	r2, [r7, #4]
 80262ce:	4613      	mov	r3, r2
 80262d0:	00db      	lsls	r3, r3, #3
 80262d2:	4413      	add	r3, r2
 80262d4:	009b      	lsls	r3, r3, #2
 80262d6:	4403      	add	r3, r0
 80262d8:	3318      	adds	r3, #24
 80262da:	6019      	str	r1, [r3, #0]
        g_timer_tbl[tbl_index].next->count  -= g_timer_tbl[tbl_index].count;
 80262dc:	492b      	ldr	r1, [pc, #172]	; (802638c <SYSTIMER_lInsertTimerList+0x1c4>)
 80262de:	687a      	ldr	r2, [r7, #4]
 80262e0:	4613      	mov	r3, r2
 80262e2:	00db      	lsls	r3, r3, #3
 80262e4:	4413      	add	r3, r2
 80262e6:	009b      	lsls	r3, r3, #2
 80262e8:	440b      	add	r3, r1
 80262ea:	681b      	ldr	r3, [r3, #0]
 80262ec:	6998      	ldr	r0, [r3, #24]
 80262ee:	4927      	ldr	r1, [pc, #156]	; (802638c <SYSTIMER_lInsertTimerList+0x1c4>)
 80262f0:	687a      	ldr	r2, [r7, #4]
 80262f2:	4613      	mov	r3, r2
 80262f4:	00db      	lsls	r3, r3, #3
 80262f6:	4413      	add	r3, r2
 80262f8:	009b      	lsls	r3, r3, #2
 80262fa:	440b      	add	r3, r1
 80262fc:	3318      	adds	r3, #24
 80262fe:	6819      	ldr	r1, [r3, #0]
 8026300:	4c22      	ldr	r4, [pc, #136]	; (802638c <SYSTIMER_lInsertTimerList+0x1c4>)
 8026302:	687a      	ldr	r2, [r7, #4]
 8026304:	4613      	mov	r3, r2
 8026306:	00db      	lsls	r3, r3, #3
 8026308:	4413      	add	r3, r2
 802630a:	009b      	lsls	r3, r3, #2
 802630c:	4423      	add	r3, r4
 802630e:	681b      	ldr	r3, [r3, #0]
 8026310:	1a42      	subs	r2, r0, r1
 8026312:	619a      	str	r2, [r3, #24]
        found_flag = true;
 8026314:	2301      	movs	r3, #1
 8026316:	73fb      	strb	r3, [r7, #15]
 8026318:	e025      	b.n	8026366 <SYSTIMER_lInsertTimerList+0x19e>
        if ((delta_ticks > 0) && (NULL == object_ptr->next))
 802631a:	693b      	ldr	r3, [r7, #16]
 802631c:	2b00      	cmp	r3, #0
 802631e:	dd22      	ble.n	8026366 <SYSTIMER_lInsertTimerList+0x19e>
 8026320:	697b      	ldr	r3, [r7, #20]
 8026322:	681b      	ldr	r3, [r3, #0]
 8026324:	2b00      	cmp	r3, #0
 8026326:	d11e      	bne.n	8026366 <SYSTIMER_lInsertTimerList+0x19e>
          g_timer_tbl[tbl_index].prev = object_ptr;
 8026328:	4918      	ldr	r1, [pc, #96]	; (802638c <SYSTIMER_lInsertTimerList+0x1c4>)
 802632a:	687a      	ldr	r2, [r7, #4]
 802632c:	4613      	mov	r3, r2
 802632e:	00db      	lsls	r3, r3, #3
 8026330:	4413      	add	r3, r2
 8026332:	009b      	lsls	r3, r3, #2
 8026334:	440b      	add	r3, r1
 8026336:	3304      	adds	r3, #4
 8026338:	697a      	ldr	r2, [r7, #20]
 802633a:	601a      	str	r2, [r3, #0]
          object_ptr->next = &g_timer_tbl[tbl_index];
 802633c:	687a      	ldr	r2, [r7, #4]
 802633e:	4613      	mov	r3, r2
 8026340:	00db      	lsls	r3, r3, #3
 8026342:	4413      	add	r3, r2
 8026344:	009b      	lsls	r3, r3, #2
 8026346:	4a11      	ldr	r2, [pc, #68]	; (802638c <SYSTIMER_lInsertTimerList+0x1c4>)
 8026348:	441a      	add	r2, r3
 802634a:	697b      	ldr	r3, [r7, #20]
 802634c:	601a      	str	r2, [r3, #0]
          g_timer_tbl[tbl_index].count = (uint32_t)delta_ticks;
 802634e:	6939      	ldr	r1, [r7, #16]
 8026350:	480e      	ldr	r0, [pc, #56]	; (802638c <SYSTIMER_lInsertTimerList+0x1c4>)
 8026352:	687a      	ldr	r2, [r7, #4]
 8026354:	4613      	mov	r3, r2
 8026356:	00db      	lsls	r3, r3, #3
 8026358:	4413      	add	r3, r2
 802635a:	009b      	lsls	r3, r3, #2
 802635c:	4403      	add	r3, r0
 802635e:	3318      	adds	r3, #24
 8026360:	6019      	str	r1, [r3, #0]
          found_flag = true;
 8026362:	2301      	movs	r3, #1
 8026364:	73fb      	strb	r3, [r7, #15]
      object_ptr = object_ptr->next;
 8026366:	697b      	ldr	r3, [r7, #20]
 8026368:	681b      	ldr	r3, [r3, #0]
 802636a:	617b      	str	r3, [r7, #20]
    while ((NULL != object_ptr) && (false == found_flag))
 802636c:	697b      	ldr	r3, [r7, #20]
 802636e:	2b00      	cmp	r3, #0
 8026370:	d006      	beq.n	8026380 <SYSTIMER_lInsertTimerList+0x1b8>
 8026372:	7bfb      	ldrb	r3, [r7, #15]
 8026374:	f083 0301 	eor.w	r3, r3, #1
 8026378:	b2db      	uxtb	r3, r3
 802637a:	2b00      	cmp	r3, #0
 802637c:	f47f af48 	bne.w	8026210 <SYSTIMER_lInsertTimerList+0x48>
}
 8026380:	bf00      	nop
 8026382:	3718      	adds	r7, #24
 8026384:	46bd      	mov	sp, r7
 8026386:	bc90      	pop	{r4, r7}
 8026388:	4770      	bx	lr
 802638a:	bf00      	nop
 802638c:	1ffea180 	.word	0x1ffea180
 8026390:	1ffea2a0 	.word	0x1ffea2a0

08026394 <SYSTIMER_lRemoveTimerList>:

/*
 * This function is called to remove a timer from the timer list. 
 */
static void SYSTIMER_lRemoveTimerList(uint32_t tbl_index)
{
 8026394:	b480      	push	{r7}
 8026396:	b085      	sub	sp, #20
 8026398:	af00      	add	r7, sp, #0
 802639a:	6078      	str	r0, [r7, #4]
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = &g_timer_tbl[tbl_index];
 802639c:	687a      	ldr	r2, [r7, #4]
 802639e:	4613      	mov	r3, r2
 80263a0:	00db      	lsls	r3, r3, #3
 80263a2:	4413      	add	r3, r2
 80263a4:	009b      	lsls	r3, r3, #2
 80263a6:	4a29      	ldr	r2, [pc, #164]	; (802644c <SYSTIMER_lRemoveTimerList+0xb8>)
 80263a8:	4413      	add	r3, r2
 80263aa:	60fb      	str	r3, [r7, #12]
  /* Check whether only one timer available */
  if ((NULL == object_ptr->prev) && (NULL == object_ptr->next ))
 80263ac:	68fb      	ldr	r3, [r7, #12]
 80263ae:	685b      	ldr	r3, [r3, #4]
 80263b0:	2b00      	cmp	r3, #0
 80263b2:	d107      	bne.n	80263c4 <SYSTIMER_lRemoveTimerList+0x30>
 80263b4:	68fb      	ldr	r3, [r7, #12]
 80263b6:	681b      	ldr	r3, [r3, #0]
 80263b8:	2b00      	cmp	r3, #0
 80263ba:	d103      	bne.n	80263c4 <SYSTIMER_lRemoveTimerList+0x30>
  {
    /* set timer list as NULL */ 
    g_timer_list = NULL;                  
 80263bc:	4b24      	ldr	r3, [pc, #144]	; (8026450 <SYSTIMER_lRemoveTimerList+0xbc>)
 80263be:	2200      	movs	r2, #0
 80263c0:	601a      	str	r2, [r3, #0]
    object_ptr->next->prev  =  object_ptr->prev;
    object_ptr->next->count += object_ptr->count;
    object_ptr->next = NULL;
    object_ptr->prev = NULL;
  }
}
 80263c2:	e03d      	b.n	8026440 <SYSTIMER_lRemoveTimerList+0xac>
  else if (NULL == object_ptr->prev)
 80263c4:	68fb      	ldr	r3, [r7, #12]
 80263c6:	685b      	ldr	r3, [r3, #4]
 80263c8:	2b00      	cmp	r3, #0
 80263ca:	d114      	bne.n	80263f6 <SYSTIMER_lRemoveTimerList+0x62>
    g_timer_list  = object_ptr->next;
 80263cc:	68fb      	ldr	r3, [r7, #12]
 80263ce:	681b      	ldr	r3, [r3, #0]
 80263d0:	4a1f      	ldr	r2, [pc, #124]	; (8026450 <SYSTIMER_lRemoveTimerList+0xbc>)
 80263d2:	6013      	str	r3, [r2, #0]
    g_timer_list->prev = NULL;
 80263d4:	4b1e      	ldr	r3, [pc, #120]	; (8026450 <SYSTIMER_lRemoveTimerList+0xbc>)
 80263d6:	681b      	ldr	r3, [r3, #0]
 80263d8:	2200      	movs	r2, #0
 80263da:	605a      	str	r2, [r3, #4]
    g_timer_list->count += object_ptr->count;
 80263dc:	4b1c      	ldr	r3, [pc, #112]	; (8026450 <SYSTIMER_lRemoveTimerList+0xbc>)
 80263de:	681b      	ldr	r3, [r3, #0]
 80263e0:	6999      	ldr	r1, [r3, #24]
 80263e2:	68fb      	ldr	r3, [r7, #12]
 80263e4:	699a      	ldr	r2, [r3, #24]
 80263e6:	4b1a      	ldr	r3, [pc, #104]	; (8026450 <SYSTIMER_lRemoveTimerList+0xbc>)
 80263e8:	681b      	ldr	r3, [r3, #0]
 80263ea:	440a      	add	r2, r1
 80263ec:	619a      	str	r2, [r3, #24]
    object_ptr->next    = NULL;
 80263ee:	68fb      	ldr	r3, [r7, #12]
 80263f0:	2200      	movs	r2, #0
 80263f2:	601a      	str	r2, [r3, #0]
}
 80263f4:	e024      	b.n	8026440 <SYSTIMER_lRemoveTimerList+0xac>
  else if (NULL == object_ptr->next)
 80263f6:	68fb      	ldr	r3, [r7, #12]
 80263f8:	681b      	ldr	r3, [r3, #0]
 80263fa:	2b00      	cmp	r3, #0
 80263fc:	d107      	bne.n	802640e <SYSTIMER_lRemoveTimerList+0x7a>
    object_ptr->prev->next = NULL;
 80263fe:	68fb      	ldr	r3, [r7, #12]
 8026400:	685b      	ldr	r3, [r3, #4]
 8026402:	2200      	movs	r2, #0
 8026404:	601a      	str	r2, [r3, #0]
    object_ptr->prev = NULL;
 8026406:	68fb      	ldr	r3, [r7, #12]
 8026408:	2200      	movs	r2, #0
 802640a:	605a      	str	r2, [r3, #4]
}
 802640c:	e018      	b.n	8026440 <SYSTIMER_lRemoveTimerList+0xac>
    object_ptr->prev->next  =  object_ptr->next;
 802640e:	68fb      	ldr	r3, [r7, #12]
 8026410:	685b      	ldr	r3, [r3, #4]
 8026412:	68fa      	ldr	r2, [r7, #12]
 8026414:	6812      	ldr	r2, [r2, #0]
 8026416:	601a      	str	r2, [r3, #0]
    object_ptr->next->prev  =  object_ptr->prev;
 8026418:	68fb      	ldr	r3, [r7, #12]
 802641a:	681b      	ldr	r3, [r3, #0]
 802641c:	68fa      	ldr	r2, [r7, #12]
 802641e:	6852      	ldr	r2, [r2, #4]
 8026420:	605a      	str	r2, [r3, #4]
    object_ptr->next->count += object_ptr->count;
 8026422:	68fb      	ldr	r3, [r7, #12]
 8026424:	681b      	ldr	r3, [r3, #0]
 8026426:	6999      	ldr	r1, [r3, #24]
 8026428:	68fb      	ldr	r3, [r7, #12]
 802642a:	699a      	ldr	r2, [r3, #24]
 802642c:	68fb      	ldr	r3, [r7, #12]
 802642e:	681b      	ldr	r3, [r3, #0]
 8026430:	440a      	add	r2, r1
 8026432:	619a      	str	r2, [r3, #24]
    object_ptr->next = NULL;
 8026434:	68fb      	ldr	r3, [r7, #12]
 8026436:	2200      	movs	r2, #0
 8026438:	601a      	str	r2, [r3, #0]
    object_ptr->prev = NULL;
 802643a:	68fb      	ldr	r3, [r7, #12]
 802643c:	2200      	movs	r2, #0
 802643e:	605a      	str	r2, [r3, #4]
}
 8026440:	bf00      	nop
 8026442:	3714      	adds	r7, #20
 8026444:	46bd      	mov	sp, r7
 8026446:	f85d 7b04 	ldr.w	r7, [sp], #4
 802644a:	4770      	bx	lr
 802644c:	1ffea180 	.word	0x1ffea180
 8026450:	1ffea2a0 	.word	0x1ffea2a0

08026454 <SYSTIMER_lTimerHandler>:

/*
 * Handler function called from SysTick event handler.
 */
static void SYSTIMER_lTimerHandler(void)
{
 8026454:	b580      	push	{r7, lr}
 8026456:	b082      	sub	sp, #8
 8026458:	af00      	add	r7, sp, #0
  SYSTIMER_OBJECT_t *object_ptr;
  /* Get first item of timer list */
  object_ptr = g_timer_list;
 802645a:	4b30      	ldr	r3, [pc, #192]	; (802651c <SYSTIMER_lTimerHandler+0xc8>)
 802645c:	681b      	ldr	r3, [r3, #0]
 802645e:	607b      	str	r3, [r7, #4]
  while ((NULL != object_ptr) && (0U == object_ptr->count))
 8026460:	e04e      	b.n	8026500 <SYSTIMER_lTimerHandler+0xac>
  {
    if (true == object_ptr->delete_swtmr)
 8026462:	687b      	ldr	r3, [r7, #4]
 8026464:	f893 3020 	ldrb.w	r3, [r3, #32]
 8026468:	2b00      	cmp	r3, #0
 802646a:	d013      	beq.n	8026494 <SYSTIMER_lTimerHandler+0x40>
    {
      /* Yes, remove this timer from timer list */
      SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
 802646c:	687b      	ldr	r3, [r7, #4]
 802646e:	695b      	ldr	r3, [r3, #20]
 8026470:	4618      	mov	r0, r3
 8026472:	f7ff ff8f 	bl	8026394 <SYSTIMER_lRemoveTimerList>
      /* Set timer status as SYSTIMER_STATE_NOT_INITIALIZED */
      object_ptr->state = SYSTIMER_STATE_NOT_INITIALIZED;
 8026476:	687b      	ldr	r3, [r7, #4]
 8026478:	2200      	movs	r2, #0
 802647a:	735a      	strb	r2, [r3, #13]
      /* Release resource which are hold by this timer */
      g_timer_tracker &= ~(1U << object_ptr->id);
 802647c:	687b      	ldr	r3, [r7, #4]
 802647e:	695b      	ldr	r3, [r3, #20]
 8026480:	2201      	movs	r2, #1
 8026482:	fa02 f303 	lsl.w	r3, r2, r3
 8026486:	43da      	mvns	r2, r3
 8026488:	4b25      	ldr	r3, [pc, #148]	; (8026520 <SYSTIMER_lTimerHandler+0xcc>)
 802648a:	681b      	ldr	r3, [r3, #0]
 802648c:	4013      	ands	r3, r2
 802648e:	4a24      	ldr	r2, [pc, #144]	; (8026520 <SYSTIMER_lTimerHandler+0xcc>)
 8026490:	6013      	str	r3, [r2, #0]
 8026492:	e032      	b.n	80264fa <SYSTIMER_lTimerHandler+0xa6>
    }
    /* Check whether timer is a one shot timer */
    else if (SYSTIMER_MODE_ONE_SHOT == object_ptr->mode)
 8026494:	687b      	ldr	r3, [r7, #4]
 8026496:	7b1b      	ldrb	r3, [r3, #12]
 8026498:	2b00      	cmp	r3, #0
 802649a:	d112      	bne.n	80264c2 <SYSTIMER_lTimerHandler+0x6e>
    {
      if (SYSTIMER_STATE_RUNNING == object_ptr->state)
 802649c:	687b      	ldr	r3, [r7, #4]
 802649e:	7b5b      	ldrb	r3, [r3, #13]
 80264a0:	2b01      	cmp	r3, #1
 80264a2:	d12a      	bne.n	80264fa <SYSTIMER_lTimerHandler+0xa6>
      {
        /* Yes, remove this timer from timer list */
        SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
 80264a4:	687b      	ldr	r3, [r7, #4]
 80264a6:	695b      	ldr	r3, [r3, #20]
 80264a8:	4618      	mov	r0, r3
 80264aa:	f7ff ff73 	bl	8026394 <SYSTIMER_lRemoveTimerList>
        /* Set timer status as SYSTIMER_STATE_STOPPED */
        object_ptr->state = SYSTIMER_STATE_STOPPED;
 80264ae:	687b      	ldr	r3, [r7, #4]
 80264b0:	2202      	movs	r2, #2
 80264b2:	735a      	strb	r2, [r3, #13]
        /* Call timer callback function */
        (object_ptr->callback)(object_ptr->args);
 80264b4:	687b      	ldr	r3, [r7, #4]
 80264b6:	689b      	ldr	r3, [r3, #8]
 80264b8:	687a      	ldr	r2, [r7, #4]
 80264ba:	6912      	ldr	r2, [r2, #16]
 80264bc:	4610      	mov	r0, r2
 80264be:	4798      	blx	r3
 80264c0:	e01b      	b.n	80264fa <SYSTIMER_lTimerHandler+0xa6>
      }
    }
    /* Check whether timer is periodic timer */
    else if (SYSTIMER_MODE_PERIODIC == object_ptr->mode)
 80264c2:	687b      	ldr	r3, [r7, #4]
 80264c4:	7b1b      	ldrb	r3, [r3, #12]
 80264c6:	2b01      	cmp	r3, #1
 80264c8:	d122      	bne.n	8026510 <SYSTIMER_lTimerHandler+0xbc>
    {
      if (SYSTIMER_STATE_RUNNING == object_ptr->state)
 80264ca:	687b      	ldr	r3, [r7, #4]
 80264cc:	7b5b      	ldrb	r3, [r3, #13]
 80264ce:	2b01      	cmp	r3, #1
 80264d0:	d113      	bne.n	80264fa <SYSTIMER_lTimerHandler+0xa6>
      {
        /* Yes, remove this timer from timer list */
        SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
 80264d2:	687b      	ldr	r3, [r7, #4]
 80264d4:	695b      	ldr	r3, [r3, #20]
 80264d6:	4618      	mov	r0, r3
 80264d8:	f7ff ff5c 	bl	8026394 <SYSTIMER_lRemoveTimerList>
        /* Reset timer tick */
        object_ptr->count = object_ptr->reload;
 80264dc:	687b      	ldr	r3, [r7, #4]
 80264de:	69da      	ldr	r2, [r3, #28]
 80264e0:	687b      	ldr	r3, [r7, #4]
 80264e2:	619a      	str	r2, [r3, #24]
        /* Insert timer into timer list */
        SYSTIMER_lInsertTimerList((uint32_t)object_ptr->id);
 80264e4:	687b      	ldr	r3, [r7, #4]
 80264e6:	695b      	ldr	r3, [r3, #20]
 80264e8:	4618      	mov	r0, r3
 80264ea:	f7ff fe6d 	bl	80261c8 <SYSTIMER_lInsertTimerList>
        /* Call timer callback function */
        (object_ptr->callback)(object_ptr->args);
 80264ee:	687b      	ldr	r3, [r7, #4]
 80264f0:	689b      	ldr	r3, [r3, #8]
 80264f2:	687a      	ldr	r2, [r7, #4]
 80264f4:	6912      	ldr	r2, [r2, #16]
 80264f6:	4610      	mov	r0, r2
 80264f8:	4798      	blx	r3
    else
    {
      break;
    }
    /* Get first item of timer list */
    object_ptr = g_timer_list;
 80264fa:	4b08      	ldr	r3, [pc, #32]	; (802651c <SYSTIMER_lTimerHandler+0xc8>)
 80264fc:	681b      	ldr	r3, [r3, #0]
 80264fe:	607b      	str	r3, [r7, #4]
  while ((NULL != object_ptr) && (0U == object_ptr->count))
 8026500:	687b      	ldr	r3, [r7, #4]
 8026502:	2b00      	cmp	r3, #0
 8026504:	d005      	beq.n	8026512 <SYSTIMER_lTimerHandler+0xbe>
 8026506:	687b      	ldr	r3, [r7, #4]
 8026508:	699b      	ldr	r3, [r3, #24]
 802650a:	2b00      	cmp	r3, #0
 802650c:	d0a9      	beq.n	8026462 <SYSTIMER_lTimerHandler+0xe>
  }
}
 802650e:	e000      	b.n	8026512 <SYSTIMER_lTimerHandler+0xbe>
      break;
 8026510:	bf00      	nop
}
 8026512:	bf00      	nop
 8026514:	3708      	adds	r7, #8
 8026516:	46bd      	mov	sp, r7
 8026518:	bd80      	pop	{r7, pc}
 802651a:	bf00      	nop
 802651c:	1ffea2a0 	.word	0x1ffea2a0
 8026520:	1ffea2a4 	.word	0x1ffea2a4

08026524 <SysTick_Handler>:

/*
 *  SysTick Event Handler.
 */
void SysTick_Handler(void)
{
 8026524:	b580      	push	{r7, lr}
 8026526:	b082      	sub	sp, #8
 8026528:	af00      	add	r7, sp, #0
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = g_timer_list;
 802652a:	4b0f      	ldr	r3, [pc, #60]	; (8026568 <SysTick_Handler+0x44>)
 802652c:	681b      	ldr	r3, [r3, #0]
 802652e:	607b      	str	r3, [r7, #4]
  g_systick_count++;
 8026530:	4b0e      	ldr	r3, [pc, #56]	; (802656c <SysTick_Handler+0x48>)
 8026532:	681b      	ldr	r3, [r3, #0]
 8026534:	3301      	adds	r3, #1
 8026536:	4a0d      	ldr	r2, [pc, #52]	; (802656c <SysTick_Handler+0x48>)
 8026538:	6013      	str	r3, [r2, #0]

  if (NULL != object_ptr)
 802653a:	687b      	ldr	r3, [r7, #4]
 802653c:	2b00      	cmp	r3, #0
 802653e:	d00e      	beq.n	802655e <SysTick_Handler+0x3a>
  {
    if (object_ptr->count > 1UL)
 8026540:	687b      	ldr	r3, [r7, #4]
 8026542:	699b      	ldr	r3, [r3, #24]
 8026544:	2b01      	cmp	r3, #1
 8026546:	d905      	bls.n	8026554 <SysTick_Handler+0x30>
    {
      object_ptr->count--;
 8026548:	687b      	ldr	r3, [r7, #4]
 802654a:	699b      	ldr	r3, [r3, #24]
 802654c:	1e5a      	subs	r2, r3, #1
 802654e:	687b      	ldr	r3, [r7, #4]
 8026550:	619a      	str	r2, [r3, #24]
    {
      object_ptr->count = 0U;
      SYSTIMER_lTimerHandler();
    }
  }
}
 8026552:	e004      	b.n	802655e <SysTick_Handler+0x3a>
      object_ptr->count = 0U;
 8026554:	687b      	ldr	r3, [r7, #4]
 8026556:	2200      	movs	r2, #0
 8026558:	619a      	str	r2, [r3, #24]
      SYSTIMER_lTimerHandler();
 802655a:	f7ff ff7b 	bl	8026454 <SYSTIMER_lTimerHandler>
}
 802655e:	bf00      	nop
 8026560:	3708      	adds	r7, #8
 8026562:	46bd      	mov	sp, r7
 8026564:	bd80      	pop	{r7, pc}
 8026566:	bf00      	nop
 8026568:	1ffea2a0 	.word	0x1ffea2a0
 802656c:	1ffea2a8 	.word	0x1ffea2a8

08026570 <SYSTIMER_Init>:

/*
 * Initialization function which initializes the SYSTIMER APP, configures SysTick timer and SysTick exception.
 */
SYSTIMER_STATUS_t SYSTIMER_Init(SYSTIMER_t *handle)
{
 8026570:	b580      	push	{r7, lr}
 8026572:	b084      	sub	sp, #16
 8026574:	af00      	add	r7, sp, #0
 8026576:	6078      	str	r0, [r7, #4]
  SYSTIMER_STATUS_t status = SYSTIMER_STATUS_SUCCESS;
 8026578:	2300      	movs	r3, #0
 802657a:	73fb      	strb	r3, [r7, #15]
  XMC_ASSERT("SYSTIMER_Init: SYSTIMER APP handle pointer uninitialized", (handle != NULL));

  /* Check APP initialization status to ensure whether SYSTIMER_Init called or not, initialize SYSTIMER if
   * SYSTIMER_Init called first time.
   */
  if (false == handle->init_status)
 802657c:	687b      	ldr	r3, [r7, #4]
 802657e:	781b      	ldrb	r3, [r3, #0]
 8026580:	f083 0301 	eor.w	r3, r3, #1
 8026584:	b2db      	uxtb	r3, r3
 8026586:	2b00      	cmp	r3, #0
 8026588:	d021      	beq.n	80265ce <SYSTIMER_Init+0x5e>
  {
    /* Initialize the header of the list */
    g_timer_list = NULL;
 802658a:	4b13      	ldr	r3, [pc, #76]	; (80265d8 <SYSTIMER_Init+0x68>)
 802658c:	2200      	movs	r2, #0
 802658e:	601a      	str	r2, [r3, #0]
    /* Initialize SysTick timer */
    status = (SYSTIMER_STATUS_t)SysTick_Config((uint32_t)(SYSTIMER_SYSTICK_CLOCK * SYSTIMER_TICK_PERIOD));
 8026590:	f642 60e0 	movw	r0, #12000	; 0x2ee0
 8026594:	f7ff fdf6 	bl	8026184 <SysTick_Config>
 8026598:	4603      	mov	r3, r0
 802659a:	73fb      	strb	r3, [r7, #15]

    if (SYSTIMER_STATUS_FAILURE == status)
 802659c:	7bfb      	ldrb	r3, [r7, #15]
 802659e:	2b01      	cmp	r3, #1
 80265a0:	d015      	beq.n	80265ce <SYSTIMER_Init+0x5e>
    }
    else
    {
#if (UC_FAMILY == XMC4)
      /* setting of First SW Timer period is always and subpriority value for XMC4000 devices */
      NVIC_SetPriority(SysTick_IRQn, NVIC_EncodePriority(
 80265a2:	f7ff fd83 	bl	80260ac <__NVIC_GetPriorityGrouping>
 80265a6:	4603      	mov	r3, r0
 80265a8:	2200      	movs	r2, #0
 80265aa:	213f      	movs	r1, #63	; 0x3f
 80265ac:	4618      	mov	r0, r3
 80265ae:	f7ff fdb5 	bl	802611c <NVIC_EncodePriority>
 80265b2:	4603      	mov	r3, r0
 80265b4:	4619      	mov	r1, r3
 80265b6:	f04f 30ff 	mov.w	r0, #4294967295
 80265ba:	f7ff fd85 	bl	80260c8 <__NVIC_SetPriority>
      NVIC_GetPriorityGrouping(), SYSTIMER_PRIORITY, SYSTIMER_SUBPRIORITY));
#elif (UC_FAMILY == XMC1)
      /* setting of priority value for XMC1000 devices */
      NVIC_SetPriority(SysTick_IRQn, SYSTIMER_PRIORITY);
#endif      
      g_timer_tracker = 0U;
 80265be:	4b07      	ldr	r3, [pc, #28]	; (80265dc <SYSTIMER_Init+0x6c>)
 80265c0:	2200      	movs	r2, #0
 80265c2:	601a      	str	r2, [r3, #0]
      /* Update the Initialization status of the SYSTIMER APP instance */
      handle->init_status = true;
 80265c4:	687b      	ldr	r3, [r7, #4]
 80265c6:	2201      	movs	r2, #1
 80265c8:	701a      	strb	r2, [r3, #0]
      status = SYSTIMER_STATUS_SUCCESS;
 80265ca:	2300      	movs	r3, #0
 80265cc:	73fb      	strb	r3, [r7, #15]
    }
  }

  return (status);
 80265ce:	7bfb      	ldrb	r3, [r7, #15]
}
 80265d0:	4618      	mov	r0, r3
 80265d2:	3710      	adds	r7, #16
 80265d4:	46bd      	mov	sp, r7
 80265d6:	bd80      	pop	{r7, pc}
 80265d8:	1ffea2a0 	.word	0x1ffea2a0
 80265dc:	1ffea2a4 	.word	0x1ffea2a4

080265e0 <SYSTIMER_CreateTimer>:
  uint32_t period,
  SYSTIMER_MODE_t mode,
  SYSTIMER_CALLBACK_t callback,
  void  *args
)
{
 80265e0:	b480      	push	{r7}
 80265e2:	b089      	sub	sp, #36	; 0x24
 80265e4:	af00      	add	r7, sp, #0
 80265e6:	60f8      	str	r0, [r7, #12]
 80265e8:	607a      	str	r2, [r7, #4]
 80265ea:	603b      	str	r3, [r7, #0]
 80265ec:	460b      	mov	r3, r1
 80265ee:	72fb      	strb	r3, [r7, #11]
  uint32_t id = 0U;
 80265f0:	2300      	movs	r3, #0
 80265f2:	61fb      	str	r3, [r7, #28]
  uint32_t count = 0U;
 80265f4:	2300      	movs	r3, #0
 80265f6:	61bb      	str	r3, [r7, #24]
  uint32_t period_ratio = 0U;
 80265f8:	2300      	movs	r3, #0
 80265fa:	617b      	str	r3, [r7, #20]
            ((period >= SYSTIMER_TICK_PERIOD_US) && (period > 0U) && (period <= 0xFFFFFFFFU)));
  XMC_ASSERT("SYSTIMER_CreateTimer: Timer creation failure due to invalid timer mode",
            ((SYSTIMER_MODE_ONE_SHOT == mode) || (SYSTIMER_MODE_PERIODIC == mode)));
  XMC_ASSERT("SYSTIMER_CreateTimer: Can not create software without user callback", (NULL != callback));
  
  if (period < SYSTIMER_TICK_PERIOD_US)
 80265fc:	68fb      	ldr	r3, [r7, #12]
 80265fe:	2b63      	cmp	r3, #99	; 0x63
 8026600:	d802      	bhi.n	8026608 <SYSTIMER_CreateTimer+0x28>
  {
    id = 0U;
 8026602:	2300      	movs	r3, #0
 8026604:	61fb      	str	r3, [r7, #28]
 8026606:	e07c      	b.n	8026702 <SYSTIMER_CreateTimer+0x122>
  }
  else
  {
    for (count = 0U; count < SYSTIMER_CFG_MAX_TMR; count++)
 8026608:	2300      	movs	r3, #0
 802660a:	61bb      	str	r3, [r7, #24]
 802660c:	e076      	b.n	80266fc <SYSTIMER_CreateTimer+0x11c>
    {
      /* Check for free timer ID */
      if (0U == (g_timer_tracker & (1U << count)))
 802660e:	2201      	movs	r2, #1
 8026610:	69bb      	ldr	r3, [r7, #24]
 8026612:	409a      	lsls	r2, r3
 8026614:	4b3e      	ldr	r3, [pc, #248]	; (8026710 <SYSTIMER_CreateTimer+0x130>)
 8026616:	681b      	ldr	r3, [r3, #0]
 8026618:	4013      	ands	r3, r2
 802661a:	2b00      	cmp	r3, #0
 802661c:	d16b      	bne.n	80266f6 <SYSTIMER_CreateTimer+0x116>
      {
        /* If yes, assign ID to this timer */
        g_timer_tracker |= (1U << count);
 802661e:	2201      	movs	r2, #1
 8026620:	69bb      	ldr	r3, [r7, #24]
 8026622:	409a      	lsls	r2, r3
 8026624:	4b3a      	ldr	r3, [pc, #232]	; (8026710 <SYSTIMER_CreateTimer+0x130>)
 8026626:	681b      	ldr	r3, [r3, #0]
 8026628:	4313      	orrs	r3, r2
 802662a:	4a39      	ldr	r2, [pc, #228]	; (8026710 <SYSTIMER_CreateTimer+0x130>)
 802662c:	6013      	str	r3, [r2, #0]
        /* Initialize the timer as per input values */
        g_timer_tbl[count].id     = count;
 802662e:	4939      	ldr	r1, [pc, #228]	; (8026714 <SYSTIMER_CreateTimer+0x134>)
 8026630:	69ba      	ldr	r2, [r7, #24]
 8026632:	4613      	mov	r3, r2
 8026634:	00db      	lsls	r3, r3, #3
 8026636:	4413      	add	r3, r2
 8026638:	009b      	lsls	r3, r3, #2
 802663a:	440b      	add	r3, r1
 802663c:	3314      	adds	r3, #20
 802663e:	69ba      	ldr	r2, [r7, #24]
 8026640:	601a      	str	r2, [r3, #0]
        g_timer_tbl[count].mode   = mode;
 8026642:	4934      	ldr	r1, [pc, #208]	; (8026714 <SYSTIMER_CreateTimer+0x134>)
 8026644:	69ba      	ldr	r2, [r7, #24]
 8026646:	4613      	mov	r3, r2
 8026648:	00db      	lsls	r3, r3, #3
 802664a:	4413      	add	r3, r2
 802664c:	009b      	lsls	r3, r3, #2
 802664e:	440b      	add	r3, r1
 8026650:	330c      	adds	r3, #12
 8026652:	7afa      	ldrb	r2, [r7, #11]
 8026654:	701a      	strb	r2, [r3, #0]
        g_timer_tbl[count].state  = SYSTIMER_STATE_STOPPED;
 8026656:	492f      	ldr	r1, [pc, #188]	; (8026714 <SYSTIMER_CreateTimer+0x134>)
 8026658:	69ba      	ldr	r2, [r7, #24]
 802665a:	4613      	mov	r3, r2
 802665c:	00db      	lsls	r3, r3, #3
 802665e:	4413      	add	r3, r2
 8026660:	009b      	lsls	r3, r3, #2
 8026662:	440b      	add	r3, r1
 8026664:	330d      	adds	r3, #13
 8026666:	2202      	movs	r2, #2
 8026668:	701a      	strb	r2, [r3, #0]
        period_ratio = (uint32_t)(period / SYSTIMER_TICK_PERIOD_US);
 802666a:	68fb      	ldr	r3, [r7, #12]
 802666c:	4a2a      	ldr	r2, [pc, #168]	; (8026718 <SYSTIMER_CreateTimer+0x138>)
 802666e:	fba2 2303 	umull	r2, r3, r2, r3
 8026672:	095b      	lsrs	r3, r3, #5
 8026674:	617b      	str	r3, [r7, #20]
        g_timer_tbl[count].count  = (period_ratio + HW_TIMER_ADDITIONAL_CNT);
 8026676:	697b      	ldr	r3, [r7, #20]
 8026678:	1c59      	adds	r1, r3, #1
 802667a:	4826      	ldr	r0, [pc, #152]	; (8026714 <SYSTIMER_CreateTimer+0x134>)
 802667c:	69ba      	ldr	r2, [r7, #24]
 802667e:	4613      	mov	r3, r2
 8026680:	00db      	lsls	r3, r3, #3
 8026682:	4413      	add	r3, r2
 8026684:	009b      	lsls	r3, r3, #2
 8026686:	4403      	add	r3, r0
 8026688:	3318      	adds	r3, #24
 802668a:	6019      	str	r1, [r3, #0]
        g_timer_tbl[count].reload  = period_ratio;
 802668c:	4921      	ldr	r1, [pc, #132]	; (8026714 <SYSTIMER_CreateTimer+0x134>)
 802668e:	69ba      	ldr	r2, [r7, #24]
 8026690:	4613      	mov	r3, r2
 8026692:	00db      	lsls	r3, r3, #3
 8026694:	4413      	add	r3, r2
 8026696:	009b      	lsls	r3, r3, #2
 8026698:	440b      	add	r3, r1
 802669a:	331c      	adds	r3, #28
 802669c:	697a      	ldr	r2, [r7, #20]
 802669e:	601a      	str	r2, [r3, #0]
        g_timer_tbl[count].callback = callback;
 80266a0:	491c      	ldr	r1, [pc, #112]	; (8026714 <SYSTIMER_CreateTimer+0x134>)
 80266a2:	69ba      	ldr	r2, [r7, #24]
 80266a4:	4613      	mov	r3, r2
 80266a6:	00db      	lsls	r3, r3, #3
 80266a8:	4413      	add	r3, r2
 80266aa:	009b      	lsls	r3, r3, #2
 80266ac:	440b      	add	r3, r1
 80266ae:	3308      	adds	r3, #8
 80266b0:	687a      	ldr	r2, [r7, #4]
 80266b2:	601a      	str	r2, [r3, #0]
        g_timer_tbl[count].args = args;
 80266b4:	4917      	ldr	r1, [pc, #92]	; (8026714 <SYSTIMER_CreateTimer+0x134>)
 80266b6:	69ba      	ldr	r2, [r7, #24]
 80266b8:	4613      	mov	r3, r2
 80266ba:	00db      	lsls	r3, r3, #3
 80266bc:	4413      	add	r3, r2
 80266be:	009b      	lsls	r3, r3, #2
 80266c0:	440b      	add	r3, r1
 80266c2:	3310      	adds	r3, #16
 80266c4:	683a      	ldr	r2, [r7, #0]
 80266c6:	601a      	str	r2, [r3, #0]
        g_timer_tbl[count].prev   = NULL;
 80266c8:	4912      	ldr	r1, [pc, #72]	; (8026714 <SYSTIMER_CreateTimer+0x134>)
 80266ca:	69ba      	ldr	r2, [r7, #24]
 80266cc:	4613      	mov	r3, r2
 80266ce:	00db      	lsls	r3, r3, #3
 80266d0:	4413      	add	r3, r2
 80266d2:	009b      	lsls	r3, r3, #2
 80266d4:	440b      	add	r3, r1
 80266d6:	3304      	adds	r3, #4
 80266d8:	2200      	movs	r2, #0
 80266da:	601a      	str	r2, [r3, #0]
        g_timer_tbl[count].next   = NULL;
 80266dc:	490d      	ldr	r1, [pc, #52]	; (8026714 <SYSTIMER_CreateTimer+0x134>)
 80266de:	69ba      	ldr	r2, [r7, #24]
 80266e0:	4613      	mov	r3, r2
 80266e2:	00db      	lsls	r3, r3, #3
 80266e4:	4413      	add	r3, r2
 80266e6:	009b      	lsls	r3, r3, #2
 80266e8:	440b      	add	r3, r1
 80266ea:	2200      	movs	r2, #0
 80266ec:	601a      	str	r2, [r3, #0]
        id = count + 1U;
 80266ee:	69bb      	ldr	r3, [r7, #24]
 80266f0:	3301      	adds	r3, #1
 80266f2:	61fb      	str	r3, [r7, #28]
        break;
 80266f4:	e005      	b.n	8026702 <SYSTIMER_CreateTimer+0x122>
    for (count = 0U; count < SYSTIMER_CFG_MAX_TMR; count++)
 80266f6:	69bb      	ldr	r3, [r7, #24]
 80266f8:	3301      	adds	r3, #1
 80266fa:	61bb      	str	r3, [r7, #24]
 80266fc:	69bb      	ldr	r3, [r7, #24]
 80266fe:	2b07      	cmp	r3, #7
 8026700:	d985      	bls.n	802660e <SYSTIMER_CreateTimer+0x2e>
      }
    }

  }

  return (id);
 8026702:	69fb      	ldr	r3, [r7, #28]
}  
 8026704:	4618      	mov	r0, r3
 8026706:	3724      	adds	r7, #36	; 0x24
 8026708:	46bd      	mov	sp, r7
 802670a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802670e:	4770      	bx	lr
 8026710:	1ffea2a4 	.word	0x1ffea2a4
 8026714:	1ffea180 	.word	0x1ffea180
 8026718:	51eb851f 	.word	0x51eb851f

0802671c <SYSTIMER_StartTimer>:

/*
 *  API to start the software timer.
 */
SYSTIMER_STATUS_t SYSTIMER_StartTimer(uint32_t id)
{
 802671c:	b580      	push	{r7, lr}
 802671e:	b084      	sub	sp, #16
 8026720:	af00      	add	r7, sp, #0
 8026722:	6078      	str	r0, [r7, #4]
  SYSTIMER_STATUS_t status;
  status = SYSTIMER_STATUS_FAILURE;
 8026724:	2301      	movs	r3, #1
 8026726:	73fb      	strb	r3, [r7, #15]
  XMC_ASSERT("SYSTIMER_StartTimer: Failure in timer restart operation due to invalid timer ID",
            ((id <= SYSTIMER_CFG_MAX_TMR) && (id > 0U)));
  XMC_ASSERT("SYSTIMER_StartTimer: Error during start of software timer", (0U != (g_timer_tracker & (1U << (id - 1U)))));
  
  /* Check if timer is running */
  if (SYSTIMER_STATE_STOPPED == g_timer_tbl[id - 1U].state)
 8026728:	687b      	ldr	r3, [r7, #4]
 802672a:	1e5a      	subs	r2, r3, #1
 802672c:	491a      	ldr	r1, [pc, #104]	; (8026798 <SYSTIMER_StartTimer+0x7c>)
 802672e:	4613      	mov	r3, r2
 8026730:	00db      	lsls	r3, r3, #3
 8026732:	4413      	add	r3, r2
 8026734:	009b      	lsls	r3, r3, #2
 8026736:	440b      	add	r3, r1
 8026738:	330d      	adds	r3, #13
 802673a:	781b      	ldrb	r3, [r3, #0]
 802673c:	2b02      	cmp	r3, #2
 802673e:	d126      	bne.n	802678e <SYSTIMER_StartTimer+0x72>
  {
    g_timer_tbl[id - 1U].count = (g_timer_tbl[id - 1U].reload + HW_TIMER_ADDITIONAL_CNT);
 8026740:	687b      	ldr	r3, [r7, #4]
 8026742:	1e5a      	subs	r2, r3, #1
 8026744:	4914      	ldr	r1, [pc, #80]	; (8026798 <SYSTIMER_StartTimer+0x7c>)
 8026746:	4613      	mov	r3, r2
 8026748:	00db      	lsls	r3, r3, #3
 802674a:	4413      	add	r3, r2
 802674c:	009b      	lsls	r3, r3, #2
 802674e:	440b      	add	r3, r1
 8026750:	331c      	adds	r3, #28
 8026752:	681b      	ldr	r3, [r3, #0]
 8026754:	687a      	ldr	r2, [r7, #4]
 8026756:	3a01      	subs	r2, #1
 8026758:	1c59      	adds	r1, r3, #1
 802675a:	480f      	ldr	r0, [pc, #60]	; (8026798 <SYSTIMER_StartTimer+0x7c>)
 802675c:	4613      	mov	r3, r2
 802675e:	00db      	lsls	r3, r3, #3
 8026760:	4413      	add	r3, r2
 8026762:	009b      	lsls	r3, r3, #2
 8026764:	4403      	add	r3, r0
 8026766:	3318      	adds	r3, #24
 8026768:	6019      	str	r1, [r3, #0]
    /* set timer status as SYSTIMER_STATE_RUNNING */
    g_timer_tbl[id - 1U].state = SYSTIMER_STATE_RUNNING;
 802676a:	687b      	ldr	r3, [r7, #4]
 802676c:	1e5a      	subs	r2, r3, #1
 802676e:	490a      	ldr	r1, [pc, #40]	; (8026798 <SYSTIMER_StartTimer+0x7c>)
 8026770:	4613      	mov	r3, r2
 8026772:	00db      	lsls	r3, r3, #3
 8026774:	4413      	add	r3, r2
 8026776:	009b      	lsls	r3, r3, #2
 8026778:	440b      	add	r3, r1
 802677a:	330d      	adds	r3, #13
 802677c:	2201      	movs	r2, #1
 802677e:	701a      	strb	r2, [r3, #0]
    /* Insert this timer into timer list */
    SYSTIMER_lInsertTimerList((id - 1U));
 8026780:	687b      	ldr	r3, [r7, #4]
 8026782:	3b01      	subs	r3, #1
 8026784:	4618      	mov	r0, r3
 8026786:	f7ff fd1f 	bl	80261c8 <SYSTIMER_lInsertTimerList>
    status = SYSTIMER_STATUS_SUCCESS;
 802678a:	2300      	movs	r3, #0
 802678c:	73fb      	strb	r3, [r7, #15]
  }

  return (status);
 802678e:	7bfb      	ldrb	r3, [r7, #15]
}
 8026790:	4618      	mov	r0, r3
 8026792:	3710      	adds	r7, #16
 8026794:	46bd      	mov	sp, r7
 8026796:	bd80      	pop	{r7, pc}
 8026798:	1ffea180 	.word	0x1ffea180

0802679c <XMC_CCU4_EnableClock>:
{
 802679c:	b480      	push	{r7}
 802679e:	b083      	sub	sp, #12
 80267a0:	af00      	add	r7, sp, #0
 80267a2:	6078      	str	r0, [r7, #4]
 80267a4:	460b      	mov	r3, r1
 80267a6:	70fb      	strb	r3, [r7, #3]
  module->GIDLC = ((uint32_t) 1) << slice_number;
 80267a8:	78fb      	ldrb	r3, [r7, #3]
 80267aa:	2201      	movs	r2, #1
 80267ac:	409a      	lsls	r2, r3
 80267ae:	687b      	ldr	r3, [r7, #4]
 80267b0:	60da      	str	r2, [r3, #12]
}
 80267b2:	bf00      	nop
 80267b4:	370c      	adds	r7, #12
 80267b6:	46bd      	mov	sp, r7
 80267b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80267bc:	4770      	bx	lr

080267be <XMC_CCU4_SLICE_EnableTrap>:
{
 80267be:	b480      	push	{r7}
 80267c0:	b083      	sub	sp, #12
 80267c2:	af00      	add	r7, sp, #0
 80267c4:	6078      	str	r0, [r7, #4]
  slice->TC |= (uint32_t) CCU4_CC4_TC_TRAPE_Msk;
 80267c6:	687b      	ldr	r3, [r7, #4]
 80267c8:	695b      	ldr	r3, [r3, #20]
 80267ca:	f443 3200 	orr.w	r2, r3, #131072	; 0x20000
 80267ce:	687b      	ldr	r3, [r7, #4]
 80267d0:	615a      	str	r2, [r3, #20]
}
 80267d2:	bf00      	nop
 80267d4:	370c      	adds	r7, #12
 80267d6:	46bd      	mov	sp, r7
 80267d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80267dc:	4770      	bx	lr

080267de <XMC_CCU4_SLICE_StartTimer>:
{
 80267de:	b480      	push	{r7}
 80267e0:	b083      	sub	sp, #12
 80267e2:	af00      	add	r7, sp, #0
 80267e4:	6078      	str	r0, [r7, #4]
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
 80267e6:	687b      	ldr	r3, [r7, #4]
 80267e8:	2201      	movs	r2, #1
 80267ea:	60da      	str	r2, [r3, #12]
}
 80267ec:	bf00      	nop
 80267ee:	370c      	adds	r7, #12
 80267f0:	46bd      	mov	sp, r7
 80267f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80267f6:	4770      	bx	lr

080267f8 <XMC_CCU4_SLICE_StopTimer>:
{
 80267f8:	b480      	push	{r7}
 80267fa:	b083      	sub	sp, #12
 80267fc:	af00      	add	r7, sp, #0
 80267fe:	6078      	str	r0, [r7, #4]
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TRBC_Msk;
 8026800:	687b      	ldr	r3, [r7, #4]
 8026802:	2201      	movs	r2, #1
 8026804:	611a      	str	r2, [r3, #16]
}
 8026806:	bf00      	nop
 8026808:	370c      	adds	r7, #12
 802680a:	46bd      	mov	sp, r7
 802680c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026810:	4770      	bx	lr

08026812 <XMC_CCU4_SLICE_ClearTimer>:
{
 8026812:	b480      	push	{r7}
 8026814:	b083      	sub	sp, #12
 8026816:	af00      	add	r7, sp, #0
 8026818:	6078      	str	r0, [r7, #4]
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TCC_Msk;
 802681a:	687b      	ldr	r3, [r7, #4]
 802681c:	2202      	movs	r2, #2
 802681e:	611a      	str	r2, [r3, #16]
}
 8026820:	bf00      	nop
 8026822:	370c      	adds	r7, #12
 8026824:	46bd      	mov	sp, r7
 8026826:	f85d 7b04 	ldr.w	r7, [sp], #4
 802682a:	4770      	bx	lr

0802682c <XMC_CCU4_SLICE_SetTimerPeriodMatch>:
{
 802682c:	b480      	push	{r7}
 802682e:	b083      	sub	sp, #12
 8026830:	af00      	add	r7, sp, #0
 8026832:	6078      	str	r0, [r7, #4]
 8026834:	460b      	mov	r3, r1
 8026836:	807b      	strh	r3, [r7, #2]
  slice->PRS = (uint32_t) period_val;
 8026838:	887a      	ldrh	r2, [r7, #2]
 802683a:	687b      	ldr	r3, [r7, #4]
 802683c:	635a      	str	r2, [r3, #52]	; 0x34
}
 802683e:	bf00      	nop
 8026840:	370c      	adds	r7, #12
 8026842:	46bd      	mov	sp, r7
 8026844:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026848:	4770      	bx	lr

0802684a <XMC_CCU4_SLICE_SetTimerCompareMatch>:
{
 802684a:	b480      	push	{r7}
 802684c:	b083      	sub	sp, #12
 802684e:	af00      	add	r7, sp, #0
 8026850:	6078      	str	r0, [r7, #4]
 8026852:	460b      	mov	r3, r1
 8026854:	807b      	strh	r3, [r7, #2]
  slice->CRS = (uint32_t) compare_val;
 8026856:	887a      	ldrh	r2, [r7, #2]
 8026858:	687b      	ldr	r3, [r7, #4]
 802685a:	63da      	str	r2, [r3, #60]	; 0x3c
}
 802685c:	bf00      	nop
 802685e:	370c      	adds	r7, #12
 8026860:	46bd      	mov	sp, r7
 8026862:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026866:	4770      	bx	lr

08026868 <XMC_CCU4_EnableShadowTransfer>:
{
 8026868:	b480      	push	{r7}
 802686a:	b083      	sub	sp, #12
 802686c:	af00      	add	r7, sp, #0
 802686e:	6078      	str	r0, [r7, #4]
 8026870:	6039      	str	r1, [r7, #0]
  module->GCSS = (uint32_t)shadow_transfer_msk;
 8026872:	687b      	ldr	r3, [r7, #4]
 8026874:	683a      	ldr	r2, [r7, #0]
 8026876:	611a      	str	r2, [r3, #16]
}
 8026878:	bf00      	nop
 802687a:	370c      	adds	r7, #12
 802687c:	46bd      	mov	sp, r7
 802687e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026882:	4770      	bx	lr

08026884 <XMC_CCU4_SLICE_EnableEvent>:
{
 8026884:	b480      	push	{r7}
 8026886:	b083      	sub	sp, #12
 8026888:	af00      	add	r7, sp, #0
 802688a:	6078      	str	r0, [r7, #4]
 802688c:	460b      	mov	r3, r1
 802688e:	70fb      	strb	r3, [r7, #3]
  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
 8026890:	687b      	ldr	r3, [r7, #4]
 8026892:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
 8026896:	78fb      	ldrb	r3, [r7, #3]
 8026898:	2101      	movs	r1, #1
 802689a:	fa01 f303 	lsl.w	r3, r1, r3
 802689e:	431a      	orrs	r2, r3
 80268a0:	687b      	ldr	r3, [r7, #4]
 80268a2:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
}
 80268a6:	bf00      	nop
 80268a8:	370c      	adds	r7, #12
 80268aa:	46bd      	mov	sp, r7
 80268ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80268b0:	4770      	bx	lr

080268b2 <XMC_CCU4_SLICE_ClearEvent>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_EnableEvent()<BR> XMC_CCU4_SLICE_SetEvent()<BR> XMC_CCU4_SLICE_GetEvent().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_ClearEvent(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_IRQ_ID_t event)
{
 80268b2:	b480      	push	{r7}
 80268b4:	b083      	sub	sp, #12
 80268b6:	af00      	add	r7, sp, #0
 80268b8:	6078      	str	r0, [r7, #4]
 80268ba:	460b      	mov	r3, r1
 80268bc:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_CCU4_SLICE_ClearEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_ClearEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  slice->SWR = ((uint32_t) 1) << ((uint32_t) event);
 80268be:	78fb      	ldrb	r3, [r7, #3]
 80268c0:	2201      	movs	r2, #1
 80268c2:	409a      	lsls	r2, r3
 80268c4:	687b      	ldr	r3, [r7, #4]
 80268c6:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
}
 80268ca:	bf00      	nop
 80268cc:	370c      	adds	r7, #12
 80268ce:	46bd      	mov	sp, r7
 80268d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80268d4:	4770      	bx	lr

080268d6 <PWM_CCU4_Init>:
  return version;
}

/* This function initializes the app */
PWM_CCU4_STATUS_t PWM_CCU4_Init(PWM_CCU4_t* handle_ptr)
{
 80268d6:	b580      	push	{r7, lr}
 80268d8:	b086      	sub	sp, #24
 80268da:	af00      	add	r7, sp, #0
 80268dc:	6078      	str	r0, [r7, #4]
  PWM_CCU4_STATUS_t status;
  GLOBAL_CCU4_STATUS_t status_ccu4_global;
  uint32_t frequency_module;
  uint32_t prescalar;

  status = PWM_CCU4_STATUS_FAILURE;
 80268de:	2301      	movs	r3, #1
 80268e0:	75fb      	strb	r3, [r7, #23]
  status_ccu4_global = GLOBAL_CCU4_STATUS_FAILURE;
 80268e2:	2301      	movs	r3, #1
 80268e4:	75bb      	strb	r3, [r7, #22]
  XMC_ASSERT("PWM_CCU4_Init:handle_ptr is NULL", (handle_ptr != NULL));

  if (PWM_CCU4_STATE_UNINITIALIZED == handle_ptr->state)
 80268e6:	687b      	ldr	r3, [r7, #4]
 80268e8:	7f1b      	ldrb	r3, [r3, #28]
 80268ea:	2b00      	cmp	r3, #0
 80268ec:	f040 808a 	bne.w	8026a04 <PWM_CCU4_Init+0x12e>
  {
    /* Initialize consumed Apps */
    status_ccu4_global = GLOBAL_CCU4_Init(handle_ptr->config_ptr->global_ccu4_handle);
 80268f0:	687b      	ldr	r3, [r7, #4]
 80268f2:	681b      	ldr	r3, [r3, #0]
 80268f4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80268f6:	4618      	mov	r0, r3
 80268f8:	f000 fb7f 	bl	8026ffa <GLOBAL_CCU4_Init>
 80268fc:	4603      	mov	r3, r0
 80268fe:	75bb      	strb	r3, [r7, #22]

    /* Initialize CCU4x_CC4y slice */
    if (GLOBAL_CCU4_STATUS_SUCCESS == status_ccu4_global)
 8026900:	7dbb      	ldrb	r3, [r7, #22]
 8026902:	2b00      	cmp	r3, #0
 8026904:	d17a      	bne.n	80269fc <PWM_CCU4_Init+0x126>
    {
      XMC_DEBUG("PWM_CCU4_Init:Initilizing slice");

      /* Configure CCU4x_CC4y slice as timer */
      XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ccu4_cc4_slice_timer_ptr);
 8026906:	687b      	ldr	r3, [r7, #4]
 8026908:	689a      	ldr	r2, [r3, #8]
 802690a:	687b      	ldr	r3, [r7, #4]
 802690c:	681b      	ldr	r3, [r3, #0]
 802690e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8026910:	4619      	mov	r1, r3
 8026912:	4610      	mov	r0, r2
 8026914:	f7fe f9cc 	bl	8024cb0 <XMC_CCU4_SLICE_CompareInit>
      /* Set period match value of the timer  */
      XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->period_value);
 8026918:	687b      	ldr	r3, [r7, #4]
 802691a:	689a      	ldr	r2, [r3, #8]
 802691c:	687b      	ldr	r3, [r7, #4]
 802691e:	681b      	ldr	r3, [r3, #0]
 8026920:	885b      	ldrh	r3, [r3, #2]
 8026922:	4619      	mov	r1, r3
 8026924:	4610      	mov	r0, r2
 8026926:	f7ff ff81 	bl	802682c <XMC_CCU4_SLICE_SetTimerPeriodMatch>

      /* Set timer compare match value for channel 1 */
      XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, (uint16_t) handle_ptr->config_ptr->compare_value);
 802692a:	687b      	ldr	r3, [r7, #4]
 802692c:	689a      	ldr	r2, [r3, #8]
 802692e:	687b      	ldr	r3, [r7, #4]
 8026930:	681b      	ldr	r3, [r3, #0]
 8026932:	889b      	ldrh	r3, [r3, #4]
 8026934:	4619      	mov	r1, r3
 8026936:	4610      	mov	r0, r2
 8026938:	f7ff ff87 	bl	802684a <XMC_CCU4_SLICE_SetTimerCompareMatch>

      if (1U == handle_ptr->config_ptr->ccu4_cc4_slice_timer_ptr->mcm_enable)
 802693c:	687b      	ldr	r3, [r7, #4]
 802693e:	681b      	ldr	r3, [r3, #0]
 8026940:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8026942:	78db      	ldrb	r3, [r3, #3]
 8026944:	f003 0302 	and.w	r3, r3, #2
 8026948:	b2db      	uxtb	r3, r3
 802694a:	2b00      	cmp	r3, #0
 802694c:	d008      	beq.n	8026960 <PWM_CCU4_Init+0x8a>
      {
        XMC_CCU4_SetMultiChannelShadowTransferMode(handle_ptr->ccu4_module_ptr,
 802694e:	687b      	ldr	r3, [r7, #4]
 8026950:	685a      	ldr	r2, [r3, #4]
                                                   (uint32_t) handle_ptr->config_ptr->mcm_shadow_txfr_mode);
 8026952:	687b      	ldr	r3, [r7, #4]
 8026954:	681b      	ldr	r3, [r3, #0]
 8026956:	6b5b      	ldr	r3, [r3, #52]	; 0x34
        XMC_CCU4_SetMultiChannelShadowTransferMode(handle_ptr->ccu4_module_ptr,
 8026958:	4619      	mov	r1, r3
 802695a:	4610      	mov	r0, r2
 802695c:	f7fe f98c 	bl	8024c78 <XMC_CCU4_SetMultiChannelShadowTransferMode>
        XMC_CCU4_SLICE_EnableCascadedShadowTransfer(handle_ptr->ccu4_slice_ptr);
      }
#endif

      /* Transfer value from shadow timer registers to actual timer registers */
      XMC_CCU4_EnableShadowTransfer(handle_ptr->ccu4_module_ptr, handle_ptr->shadow_txfr_msk);
 8026960:	687b      	ldr	r3, [r7, #4]
 8026962:	685a      	ldr	r2, [r3, #4]
 8026964:	687b      	ldr	r3, [r7, #4]
 8026966:	691b      	ldr	r3, [r3, #16]
 8026968:	4619      	mov	r1, r3
 802696a:	4610      	mov	r0, r2
 802696c:	f7ff ff7c 	bl	8026868 <XMC_CCU4_EnableShadowTransfer>
      XMC_CCU4_EnableShadowTransfer(handle_ptr->ccu4_module_ptr, handle_ptr->dither_shadow_txfr_msk);
 8026970:	687b      	ldr	r3, [r7, #4]
 8026972:	685a      	ldr	r2, [r3, #4]
 8026974:	687b      	ldr	r3, [r7, #4]
 8026976:	695b      	ldr	r3, [r3, #20]
 8026978:	4619      	mov	r1, r3
 802697a:	4610      	mov	r0, r2
 802697c:	f7ff ff74 	bl	8026868 <XMC_CCU4_EnableShadowTransfer>

      /* Configure events */
      PWM_CCU4_lConfigure_Events(handle_ptr);
 8026980:	6878      	ldr	r0, [r7, #4]
 8026982:	f000 f8da 	bl	8026b3a <PWM_CCU4_lConfigure_Events>

      /* Enable the interrupts */
      PWM_CCU4_lInit_Interrupt(handle_ptr);
 8026986:	6878      	ldr	r0, [r7, #4]
 8026988:	f000 f843 	bl	8026a12 <PWM_CCU4_lInit_Interrupt>

      /*Initializes the GPIO*/
      if ((bool) true == handle_ptr->config_ptr->gpio_ch_out_enable)
 802698c:	687b      	ldr	r3, [r7, #4]
 802698e:	681b      	ldr	r3, [r3, #0]
 8026990:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8026994:	2b00      	cmp	r3, #0
 8026996:	d00c      	beq.n	80269b2 <PWM_CCU4_Init+0xdc>
      {
        XMC_GPIO_Init(handle_ptr->config_ptr->gpio_ch_out_ptr, handle_ptr->config_ptr->gpio_ch_out_pin,
 8026998:	687b      	ldr	r3, [r7, #4]
 802699a:	681b      	ldr	r3, [r3, #0]
 802699c:	6c18      	ldr	r0, [r3, #64]	; 0x40
 802699e:	687b      	ldr	r3, [r7, #4]
 80269a0:	681b      	ldr	r3, [r3, #0]
 80269a2:	f893 1044 	ldrb.w	r1, [r3, #68]	; 0x44
                      handle_ptr->config_ptr->gpio_ch_out_config_ptr);
 80269a6:	687b      	ldr	r3, [r7, #4]
 80269a8:	681b      	ldr	r3, [r3, #0]
        XMC_GPIO_Init(handle_ptr->config_ptr->gpio_ch_out_ptr, handle_ptr->config_ptr->gpio_ch_out_pin,
 80269aa:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80269ac:	461a      	mov	r2, r3
 80269ae:	f7fc ffed 	bl	802398c <XMC_GPIO_Init>
      }

      frequency_module = handle_ptr->config_ptr->global_ccu4_handle->module_frequency;
 80269b2:	687b      	ldr	r3, [r7, #4]
 80269b4:	681b      	ldr	r3, [r3, #0]
 80269b6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80269b8:	681b      	ldr	r3, [r3, #0]
 80269ba:	613b      	str	r3, [r7, #16]
      prescalar = (uint32_t) handle_ptr->config_ptr->ccu4_cc4_slice_timer_ptr->prescaler_initval;
 80269bc:	687b      	ldr	r3, [r7, #4]
 80269be:	681b      	ldr	r3, [r3, #0]
 80269c0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80269c2:	791b      	ldrb	r3, [r3, #4]
 80269c4:	f3c3 0303 	ubfx	r3, r3, #0, #4
 80269c8:	b2db      	uxtb	r3, r3
 80269ca:	60fb      	str	r3, [r7, #12]
      frequency_module = frequency_module / ((uint32_t) 1 << prescalar);
 80269cc:	693a      	ldr	r2, [r7, #16]
 80269ce:	68fb      	ldr	r3, [r7, #12]
 80269d0:	fa22 f303 	lsr.w	r3, r2, r3
 80269d4:	613b      	str	r3, [r7, #16]
      handle_ptr->frequency_tclk = frequency_module;
 80269d6:	687b      	ldr	r3, [r7, #4]
 80269d8:	693a      	ldr	r2, [r7, #16]
 80269da:	621a      	str	r2, [r3, #32]

      handle_ptr->state = PWM_CCU4_STATE_INITIALIZED;
 80269dc:	687b      	ldr	r3, [r7, #4]
 80269de:	2201      	movs	r2, #1
 80269e0:	771a      	strb	r2, [r3, #28]
      status = PWM_CCU4_STATUS_SUCCESS;
 80269e2:	2300      	movs	r3, #0
 80269e4:	75fb      	strb	r3, [r7, #23]

      /* Start the PWM generation if start at initialization is enabled */
      if ((bool) true == handle_ptr->config_ptr->start_control)
 80269e6:	687b      	ldr	r3, [r7, #4]
 80269e8:	681b      	ldr	r3, [r3, #0]
 80269ea:	781b      	ldrb	r3, [r3, #0]
 80269ec:	2b00      	cmp	r3, #0
 80269ee:	d00b      	beq.n	8026a08 <PWM_CCU4_Init+0x132>
      {
        status = PWM_CCU4_Start(handle_ptr);
 80269f0:	6878      	ldr	r0, [r7, #4]
 80269f2:	f000 f97b 	bl	8026cec <PWM_CCU4_Start>
 80269f6:	4603      	mov	r3, r0
 80269f8:	75fb      	strb	r3, [r7, #23]
 80269fa:	e005      	b.n	8026a08 <PWM_CCU4_Init+0x132>
      }
    }
    else
    {
      handle_ptr->state = PWM_CCU4_STATE_UNINITIALIZED;
 80269fc:	687b      	ldr	r3, [r7, #4]
 80269fe:	2200      	movs	r2, #0
 8026a00:	771a      	strb	r2, [r3, #28]
 8026a02:	e001      	b.n	8026a08 <PWM_CCU4_Init+0x132>
    }

  }
  else
  {
    status = PWM_CCU4_STATUS_ALREADY_INITIALIZED;
 8026a04:	2302      	movs	r3, #2
 8026a06:	75fb      	strb	r3, [r7, #23]
    XMC_DEBUG("PWM_CCU4_Init:PWM_CCU4_STATUS_ALREADY_INITIALIZED");
  }

  return (status);
 8026a08:	7dfb      	ldrb	r3, [r7, #23]
} /* end of PWM_CCU4_Init() api */
 8026a0a:	4618      	mov	r0, r3
 8026a0c:	3718      	adds	r7, #24
 8026a0e:	46bd      	mov	sp, r7
 8026a10:	bd80      	pop	{r7, pc}

08026a12 <PWM_CCU4_lInit_Interrupt>:

static void PWM_CCU4_lInit_Interrupt(PWM_CCU4_t* handle_ptr)
{
 8026a12:	b580      	push	{r7, lr}
 8026a14:	b082      	sub	sp, #8
 8026a16:	af00      	add	r7, sp, #0
 8026a18:	6078      	str	r0, [r7, #4]

  /* Enable events. Bind event to corresponding service request node.Enable Interrupts. The user may choose to 
   disable the interrupts by LLD calls. */
  if ((bool) true == handle_ptr->config_ptr->int_per_match)
 8026a1a:	687b      	ldr	r3, [r7, #4]
 8026a1c:	681b      	ldr	r3, [r3, #0]
 8026a1e:	799b      	ldrb	r3, [r3, #6]
 8026a20:	2b00      	cmp	r3, #0
 8026a22:	d00e      	beq.n	8026a42 <PWM_CCU4_lInit_Interrupt+0x30>
  {
    XMC_DEBUG("PWM_CCU4_Init: Interrupt period match enable");
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH,
 8026a24:	687b      	ldr	r3, [r7, #4]
 8026a26:	6898      	ldr	r0, [r3, #8]
                                    handle_ptr->config_ptr->sr_per_match);
 8026a28:	687b      	ldr	r3, [r7, #4]
 8026a2a:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH,
 8026a2c:	7b5b      	ldrb	r3, [r3, #13]
 8026a2e:	461a      	mov	r2, r3
 8026a30:	2100      	movs	r1, #0
 8026a32:	f7fe fc0b 	bl	802524c <XMC_CCU4_SLICE_SetInterruptNode>
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 8026a36:	687b      	ldr	r3, [r7, #4]
 8026a38:	689b      	ldr	r3, [r3, #8]
 8026a3a:	2100      	movs	r1, #0
 8026a3c:	4618      	mov	r0, r3
 8026a3e:	f7ff ff21 	bl	8026884 <XMC_CCU4_SLICE_EnableEvent>
  }

  if ((bool) true == handle_ptr->config_ptr->int_cmp_match_up)
 8026a42:	687b      	ldr	r3, [r7, #4]
 8026a44:	681b      	ldr	r3, [r3, #0]
 8026a46:	79db      	ldrb	r3, [r3, #7]
 8026a48:	2b00      	cmp	r3, #0
 8026a4a:	d00e      	beq.n	8026a6a <PWM_CCU4_lInit_Interrupt+0x58>
  {
    XMC_DEBUG("PWM_CCU4_Init: Interrupt compare match up enable");
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP,
 8026a4c:	687b      	ldr	r3, [r7, #4]
 8026a4e:	6898      	ldr	r0, [r3, #8]
                                    handle_ptr->config_ptr->sr_cmp_match_up);
 8026a50:	687b      	ldr	r3, [r7, #4]
 8026a52:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP,
 8026a54:	7b9b      	ldrb	r3, [r3, #14]
 8026a56:	461a      	mov	r2, r3
 8026a58:	2102      	movs	r1, #2
 8026a5a:	f7fe fbf7 	bl	802524c <XMC_CCU4_SLICE_SetInterruptNode>
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP);
 8026a5e:	687b      	ldr	r3, [r7, #4]
 8026a60:	689b      	ldr	r3, [r3, #8]
 8026a62:	2102      	movs	r1, #2
 8026a64:	4618      	mov	r0, r3
 8026a66:	f7ff ff0d 	bl	8026884 <XMC_CCU4_SLICE_EnableEvent>
  }

  if ((bool) true == handle_ptr->config_ptr->int_cmp_match_down)
 8026a6a:	687b      	ldr	r3, [r7, #4]
 8026a6c:	681b      	ldr	r3, [r3, #0]
 8026a6e:	7a1b      	ldrb	r3, [r3, #8]
 8026a70:	2b00      	cmp	r3, #0
 8026a72:	d00e      	beq.n	8026a92 <PWM_CCU4_lInit_Interrupt+0x80>
  {
    XMC_DEBUG("PWM_CCU4_Init: Interrupt compare match down enable");
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_DOWN,
 8026a74:	687b      	ldr	r3, [r7, #4]
 8026a76:	6898      	ldr	r0, [r3, #8]
                                    handle_ptr->config_ptr->sr_cmp_match_down);
 8026a78:	687b      	ldr	r3, [r7, #4]
 8026a7a:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_DOWN,
 8026a7c:	7bdb      	ldrb	r3, [r3, #15]
 8026a7e:	461a      	mov	r2, r3
 8026a80:	2103      	movs	r1, #3
 8026a82:	f7fe fbe3 	bl	802524c <XMC_CCU4_SLICE_SetInterruptNode>
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_DOWN);
 8026a86:	687b      	ldr	r3, [r7, #4]
 8026a88:	689b      	ldr	r3, [r3, #8]
 8026a8a:	2103      	movs	r1, #3
 8026a8c:	4618      	mov	r0, r3
 8026a8e:	f7ff fef9 	bl	8026884 <XMC_CCU4_SLICE_EnableEvent>
  }

  if ((bool) true == handle_ptr->config_ptr->int_one_match_down)
 8026a92:	687b      	ldr	r3, [r7, #4]
 8026a94:	681b      	ldr	r3, [r3, #0]
 8026a96:	7a5b      	ldrb	r3, [r3, #9]
 8026a98:	2b00      	cmp	r3, #0
 8026a9a:	d00e      	beq.n	8026aba <PWM_CCU4_lInit_Interrupt+0xa8>
  {
    XMC_DEBUG("PWM_CCU4_Init: Interrupt one match enable");
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_ONE_MATCH,
 8026a9c:	687b      	ldr	r3, [r7, #4]
 8026a9e:	6898      	ldr	r0, [r3, #8]
                                    handle_ptr->config_ptr->sr_one_match_down);
 8026aa0:	687b      	ldr	r3, [r7, #4]
 8026aa2:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_ONE_MATCH,
 8026aa4:	7c1b      	ldrb	r3, [r3, #16]
 8026aa6:	461a      	mov	r2, r3
 8026aa8:	2101      	movs	r1, #1
 8026aaa:	f7fe fbcf 	bl	802524c <XMC_CCU4_SLICE_SetInterruptNode>
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_ONE_MATCH);
 8026aae:	687b      	ldr	r3, [r7, #4]
 8026ab0:	689b      	ldr	r3, [r3, #8]
 8026ab2:	2101      	movs	r1, #1
 8026ab4:	4618      	mov	r0, r3
 8026ab6:	f7ff fee5 	bl	8026884 <XMC_CCU4_SLICE_EnableEvent>
  }

  if ((bool) true == handle_ptr->config_ptr->int_e0)
 8026aba:	687b      	ldr	r3, [r7, #4]
 8026abc:	681b      	ldr	r3, [r3, #0]
 8026abe:	7a9b      	ldrb	r3, [r3, #10]
 8026ac0:	2b00      	cmp	r3, #0
 8026ac2:	d00e      	beq.n	8026ae2 <PWM_CCU4_lInit_Interrupt+0xd0>
  {
    XMC_DEBUG("PWM_CCU4_Init: Interrupt event 0 enable");
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT0,
 8026ac4:	687b      	ldr	r3, [r7, #4]
 8026ac6:	6898      	ldr	r0, [r3, #8]
                                    handle_ptr->config_ptr->sr_e0);
 8026ac8:	687b      	ldr	r3, [r7, #4]
 8026aca:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT0,
 8026acc:	7c5b      	ldrb	r3, [r3, #17]
 8026ace:	461a      	mov	r2, r3
 8026ad0:	2108      	movs	r1, #8
 8026ad2:	f7fe fbbb 	bl	802524c <XMC_CCU4_SLICE_SetInterruptNode>
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT0);
 8026ad6:	687b      	ldr	r3, [r7, #4]
 8026ad8:	689b      	ldr	r3, [r3, #8]
 8026ada:	2108      	movs	r1, #8
 8026adc:	4618      	mov	r0, r3
 8026ade:	f7ff fed1 	bl	8026884 <XMC_CCU4_SLICE_EnableEvent>
  }

  if ((bool) true == handle_ptr->config_ptr->int_e1)
 8026ae2:	687b      	ldr	r3, [r7, #4]
 8026ae4:	681b      	ldr	r3, [r3, #0]
 8026ae6:	7adb      	ldrb	r3, [r3, #11]
 8026ae8:	2b00      	cmp	r3, #0
 8026aea:	d00e      	beq.n	8026b0a <PWM_CCU4_lInit_Interrupt+0xf8>
  {
    XMC_DEBUG("PWM_CCU4_Init: Interrupt event 1 enable");
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT1,
 8026aec:	687b      	ldr	r3, [r7, #4]
 8026aee:	6898      	ldr	r0, [r3, #8]
                                    handle_ptr->config_ptr->sr_e1);
 8026af0:	687b      	ldr	r3, [r7, #4]
 8026af2:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT1,
 8026af4:	7c9b      	ldrb	r3, [r3, #18]
 8026af6:	461a      	mov	r2, r3
 8026af8:	2109      	movs	r1, #9
 8026afa:	f7fe fba7 	bl	802524c <XMC_CCU4_SLICE_SetInterruptNode>
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT1);
 8026afe:	687b      	ldr	r3, [r7, #4]
 8026b00:	689b      	ldr	r3, [r3, #8]
 8026b02:	2109      	movs	r1, #9
 8026b04:	4618      	mov	r0, r3
 8026b06:	f7ff febd 	bl	8026884 <XMC_CCU4_SLICE_EnableEvent>
  }

  if ((bool) true == handle_ptr->config_ptr->int_e2)
 8026b0a:	687b      	ldr	r3, [r7, #4]
 8026b0c:	681b      	ldr	r3, [r3, #0]
 8026b0e:	7b1b      	ldrb	r3, [r3, #12]
 8026b10:	2b00      	cmp	r3, #0
 8026b12:	d00e      	beq.n	8026b32 <PWM_CCU4_lInit_Interrupt+0x120>
  {
    XMC_DEBUG("PWM_CCU4_Init: Interrupt event 2 enable");
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT2,
 8026b14:	687b      	ldr	r3, [r7, #4]
 8026b16:	6898      	ldr	r0, [r3, #8]
                                    handle_ptr->config_ptr->sr_e2);
 8026b18:	687b      	ldr	r3, [r7, #4]
 8026b1a:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT2,
 8026b1c:	7cdb      	ldrb	r3, [r3, #19]
 8026b1e:	461a      	mov	r2, r3
 8026b20:	210a      	movs	r1, #10
 8026b22:	f7fe fb93 	bl	802524c <XMC_CCU4_SLICE_SetInterruptNode>
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT2);
 8026b26:	687b      	ldr	r3, [r7, #4]
 8026b28:	689b      	ldr	r3, [r3, #8]
 8026b2a:	210a      	movs	r1, #10
 8026b2c:	4618      	mov	r0, r3
 8026b2e:	f7ff fea9 	bl	8026884 <XMC_CCU4_SLICE_EnableEvent>
  }
}
 8026b32:	bf00      	nop
 8026b34:	3708      	adds	r7, #8
 8026b36:	46bd      	mov	sp, r7
 8026b38:	bd80      	pop	{r7, pc}

08026b3a <PWM_CCU4_lConfigure_Events>:

static void PWM_CCU4_lConfigure_Events(PWM_CCU4_t* handle_ptr)
{
 8026b3a:	b580      	push	{r7, lr}
 8026b3c:	b082      	sub	sp, #8
 8026b3e:	af00      	add	r7, sp, #0
 8026b40:	6078      	str	r0, [r7, #4]

  /* Configure slice to a external event 0 */
  XMC_CCU4_SLICE_ConfigureEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_EVENT_0,
 8026b42:	687b      	ldr	r3, [r7, #4]
 8026b44:	6898      	ldr	r0, [r3, #8]
                                handle_ptr->config_ptr->event0_config_ptr);
 8026b46:	687b      	ldr	r3, [r7, #4]
 8026b48:	681b      	ldr	r3, [r3, #0]
  XMC_CCU4_SLICE_ConfigureEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_EVENT_0,
 8026b4a:	695b      	ldr	r3, [r3, #20]
 8026b4c:	461a      	mov	r2, r3
 8026b4e:	2101      	movs	r1, #1
 8026b50:	f7fe fae1 	bl	8025116 <XMC_CCU4_SLICE_ConfigureEvent>

  /* Configure slice to a external event 1 */
  XMC_CCU4_SLICE_ConfigureEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_EVENT_1,
 8026b54:	687b      	ldr	r3, [r7, #4]
 8026b56:	6898      	ldr	r0, [r3, #8]
                                handle_ptr->config_ptr->event1_config_ptr);
 8026b58:	687b      	ldr	r3, [r7, #4]
 8026b5a:	681b      	ldr	r3, [r3, #0]
  XMC_CCU4_SLICE_ConfigureEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_EVENT_1,
 8026b5c:	699b      	ldr	r3, [r3, #24]
 8026b5e:	461a      	mov	r2, r3
 8026b60:	2102      	movs	r1, #2
 8026b62:	f7fe fad8 	bl	8025116 <XMC_CCU4_SLICE_ConfigureEvent>

  /* Configure slice to a external event 2 */
  XMC_CCU4_SLICE_ConfigureEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_EVENT_2,
 8026b66:	687b      	ldr	r3, [r7, #4]
 8026b68:	6898      	ldr	r0, [r3, #8]
                                handle_ptr->config_ptr->event2_config_ptr);
 8026b6a:	687b      	ldr	r3, [r7, #4]
 8026b6c:	681b      	ldr	r3, [r3, #0]
  XMC_CCU4_SLICE_ConfigureEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_EVENT_2,
 8026b6e:	69db      	ldr	r3, [r3, #28]
 8026b70:	461a      	mov	r2, r3
 8026b72:	2103      	movs	r1, #3
 8026b74:	f7fe facf 	bl	8025116 <XMC_CCU4_SLICE_ConfigureEvent>

  /* External signal controls start of the timer */
  if (XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_start_event)
 8026b78:	687b      	ldr	r3, [r7, #4]
 8026b7a:	681b      	ldr	r3, [r3, #0]
 8026b7c:	f893 3020 	ldrb.w	r3, [r3, #32]
 8026b80:	2b00      	cmp	r3, #0
 8026b82:	d00c      	beq.n	8026b9e <PWM_CCU4_lConfigure_Events+0x64>
  {
    XMC_CCU4_SLICE_StartConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_start_event,
 8026b84:	687b      	ldr	r3, [r7, #4]
 8026b86:	6898      	ldr	r0, [r3, #8]
 8026b88:	687b      	ldr	r3, [r7, #4]
 8026b8a:	681b      	ldr	r3, [r3, #0]
 8026b8c:	f893 1020 	ldrb.w	r1, [r3, #32]
                               handle_ptr->config_ptr->ext_start_mode);
 8026b90:	687b      	ldr	r3, [r7, #4]
 8026b92:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_StartConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_start_event,
 8026b94:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8026b98:	461a      	mov	r2, r3
 8026b9a:	f7fe f8e7 	bl	8024d6c <XMC_CCU4_SLICE_StartConfig>
  }

  /* External signal can stop the timer */
  if (XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_stop_event)
 8026b9e:	687b      	ldr	r3, [r7, #4]
 8026ba0:	681b      	ldr	r3, [r3, #0]
 8026ba2:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8026ba6:	2b00      	cmp	r3, #0
 8026ba8:	d00c      	beq.n	8026bc4 <PWM_CCU4_lConfigure_Events+0x8a>
  {
    XMC_CCU4_SLICE_StopConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_stop_event,
 8026baa:	687b      	ldr	r3, [r7, #4]
 8026bac:	6898      	ldr	r0, [r3, #8]
 8026bae:	687b      	ldr	r3, [r7, #4]
 8026bb0:	681b      	ldr	r3, [r3, #0]
 8026bb2:	f893 1022 	ldrb.w	r1, [r3, #34]	; 0x22
                              handle_ptr->config_ptr->ext_stop_mode);
 8026bb6:	687b      	ldr	r3, [r7, #4]
 8026bb8:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_StopConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_stop_event,
 8026bba:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
 8026bbe:	461a      	mov	r2, r3
 8026bc0:	f7fe f902 	bl	8024dc8 <XMC_CCU4_SLICE_StopConfig>
  }

  /* External signal can change the timer counting direction */
  if (XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_count_dir_event)
 8026bc4:	687b      	ldr	r3, [r7, #4]
 8026bc6:	681b      	ldr	r3, [r3, #0]
 8026bc8:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8026bcc:	2b00      	cmp	r3, #0
 8026bce:	d009      	beq.n	8026be4 <PWM_CCU4_lConfigure_Events+0xaa>
  {
    XMC_CCU4_SLICE_DirectionConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_count_dir_event);
 8026bd0:	687b      	ldr	r3, [r7, #4]
 8026bd2:	689a      	ldr	r2, [r3, #8]
 8026bd4:	687b      	ldr	r3, [r7, #4]
 8026bd6:	681b      	ldr	r3, [r3, #0]
 8026bd8:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8026bdc:	4619      	mov	r1, r3
 8026bde:	4610      	mov	r0, r2
 8026be0:	f7fe f9ca 	bl	8024f78 <XMC_CCU4_SLICE_DirectionConfig>
  }
  /* External signal can stop the timer and the timer value remains same */
  if (XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_gate_event)
 8026be4:	687b      	ldr	r3, [r7, #4]
 8026be6:	681b      	ldr	r3, [r3, #0]
 8026be8:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8026bec:	2b00      	cmp	r3, #0
 8026bee:	d009      	beq.n	8026c04 <PWM_CCU4_lConfigure_Events+0xca>
  {
    XMC_CCU4_SLICE_GateConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_gate_event);
 8026bf0:	687b      	ldr	r3, [r7, #4]
 8026bf2:	689a      	ldr	r2, [r3, #8]
 8026bf4:	687b      	ldr	r3, [r7, #4]
 8026bf6:	681b      	ldr	r3, [r3, #0]
 8026bf8:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8026bfc:	4619      	mov	r1, r3
 8026bfe:	4610      	mov	r0, r2
 8026c00:	f7fe f984 	bl	8024f0c <XMC_CCU4_SLICE_GateConfig>
  }
  /* Timer increments on external signal */
  if (XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_count_event)
 8026c04:	687b      	ldr	r3, [r7, #4]
 8026c06:	681b      	ldr	r3, [r3, #0]
 8026c08:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 8026c0c:	2b00      	cmp	r3, #0
 8026c0e:	d009      	beq.n	8026c24 <PWM_CCU4_lConfigure_Events+0xea>
  {
    XMC_CCU4_SLICE_CountConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_count_event);
 8026c10:	687b      	ldr	r3, [r7, #4]
 8026c12:	689a      	ldr	r2, [r3, #8]
 8026c14:	687b      	ldr	r3, [r7, #4]
 8026c16:	681b      	ldr	r3, [r3, #0]
 8026c18:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 8026c1c:	4619      	mov	r1, r3
 8026c1e:	4610      	mov	r0, r2
 8026c20:	f7fe f959 	bl	8024ed6 <XMC_CCU4_SLICE_CountConfig>
  }
  /* Timer gets loaded with compare register value or period register value on external signal */
  if (XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_load_event)
 8026c24:	687b      	ldr	r3, [r7, #4]
 8026c26:	681b      	ldr	r3, [r3, #0]
 8026c28:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 8026c2c:	2b00      	cmp	r3, #0
 8026c2e:	d009      	beq.n	8026c44 <PWM_CCU4_lConfigure_Events+0x10a>
  {
    XMC_CCU4_SLICE_LoadConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_load_event);
 8026c30:	687b      	ldr	r3, [r7, #4]
 8026c32:	689a      	ldr	r2, [r3, #8]
 8026c34:	687b      	ldr	r3, [r7, #4]
 8026c36:	681b      	ldr	r3, [r3, #0]
 8026c38:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 8026c3c:	4619      	mov	r1, r3
 8026c3e:	4610      	mov	r0, r2
 8026c40:	f7fe f8ee 	bl	8024e20 <XMC_CCU4_SLICE_LoadConfig>
  }
  /* External signal PWM signal (ST bit) output gets modulated by external signal */
  if (XMC_CCU4_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_mod_event)
 8026c44:	687b      	ldr	r3, [r7, #4]
 8026c46:	681b      	ldr	r3, [r3, #0]
 8026c48:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8026c4c:	2b00      	cmp	r3, #0
 8026c4e:	d00f      	beq.n	8026c70 <PWM_CCU4_lConfigure_Events+0x136>
  {
    XMC_CCU4_SLICE_ModulationConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_mod_event,
 8026c50:	687b      	ldr	r3, [r7, #4]
 8026c52:	6898      	ldr	r0, [r3, #8]
 8026c54:	687b      	ldr	r3, [r7, #4]
 8026c56:	681b      	ldr	r3, [r3, #0]
 8026c58:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
                                    handle_ptr->config_ptr->ext_mod_mode, handle_ptr->config_ptr->ext_mod_sync);
 8026c5c:	687b      	ldr	r3, [r7, #4]
 8026c5e:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_ModulationConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_mod_event,
 8026c60:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
                                    handle_ptr->config_ptr->ext_mod_mode, handle_ptr->config_ptr->ext_mod_sync);
 8026c64:	687b      	ldr	r3, [r7, #4]
 8026c66:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_ModulationConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_mod_event,
 8026c68:	f893 302a 	ldrb.w	r3, [r3, #42]	; 0x2a
 8026c6c:	f7fe f8f3 	bl	8024e56 <XMC_CCU4_SLICE_ModulationConfig>
  }

  /* PWM signal (ST bit) output gets modulated by external signal */
  if (XMC_CCU4_SLICE_EVENT_2 == handle_ptr->config_ptr->ext_trap_event)
 8026c70:	687b      	ldr	r3, [r7, #4]
 8026c72:	681b      	ldr	r3, [r3, #0]
 8026c74:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 8026c78:	2b03      	cmp	r3, #3
 8026c7a:	d117      	bne.n	8026cac <PWM_CCU4_lConfigure_Events+0x172>
  {
    XMC_CCU4_SLICE_TrapConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_trap_exit,
 8026c7c:	687b      	ldr	r3, [r7, #4]
 8026c7e:	6898      	ldr	r0, [r3, #8]
 8026c80:	687b      	ldr	r3, [r7, #4]
 8026c82:	681b      	ldr	r3, [r3, #0]
 8026c84:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
                              handle_ptr->config_ptr->ext_trap_sync);
 8026c88:	687b      	ldr	r3, [r7, #4]
 8026c8a:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_TrapConfig(handle_ptr->ccu4_slice_ptr, handle_ptr->config_ptr->ext_trap_exit,
 8026c8c:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
 8026c90:	461a      	mov	r2, r3
 8026c92:	f7fe f9a4 	bl	8024fde <XMC_CCU4_SLICE_TrapConfig>

    if ((bool) true == handle_ptr->config_ptr->ext_trap_enable)
 8026c96:	687b      	ldr	r3, [r7, #4]
 8026c98:	681b      	ldr	r3, [r3, #0]
 8026c9a:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 8026c9e:	2b00      	cmp	r3, #0
 8026ca0:	d004      	beq.n	8026cac <PWM_CCU4_lConfigure_Events+0x172>
    {
      XMC_CCU4_SLICE_EnableTrap(handle_ptr->ccu4_slice_ptr);
 8026ca2:	687b      	ldr	r3, [r7, #4]
 8026ca4:	689b      	ldr	r3, [r3, #8]
 8026ca6:	4618      	mov	r0, r3
 8026ca8:	f7ff fd89 	bl	80267be <XMC_CCU4_SLICE_EnableTrap>
    }
  }
  if ((XMC_CCU4_SLICE_EVENT_1 == handle_ptr->config_ptr->ext_override_edge_event) && (XMC_CCU4_SLICE_EVENT_2
 8026cac:	687b      	ldr	r3, [r7, #4]
 8026cae:	681b      	ldr	r3, [r3, #0]
 8026cb0:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
 8026cb4:	2b02      	cmp	r3, #2
 8026cb6:	d115      	bne.n	8026ce4 <PWM_CCU4_lConfigure_Events+0x1aa>
      == handle_ptr->config_ptr->ext_override_level_event))
 8026cb8:	687b      	ldr	r3, [r7, #4]
 8026cba:	681b      	ldr	r3, [r3, #0]
 8026cbc:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
  if ((XMC_CCU4_SLICE_EVENT_1 == handle_ptr->config_ptr->ext_override_edge_event) && (XMC_CCU4_SLICE_EVENT_2
 8026cc0:	2b03      	cmp	r3, #3
 8026cc2:	d10f      	bne.n	8026ce4 <PWM_CCU4_lConfigure_Events+0x1aa>
  {
    XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent(handle_ptr->ccu4_slice_ptr,
 8026cc4:	687b      	ldr	r3, [r7, #4]
 8026cc6:	6898      	ldr	r0, [r3, #8]
                                                   handle_ptr->config_ptr->event1_config_ptr,
 8026cc8:	687b      	ldr	r3, [r7, #4]
 8026cca:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent(handle_ptr->ccu4_slice_ptr,
 8026ccc:	6999      	ldr	r1, [r3, #24]
                                                   handle_ptr->config_ptr->event2_config_ptr);
 8026cce:	687b      	ldr	r3, [r7, #4]
 8026cd0:	681b      	ldr	r3, [r3, #0]
    XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent(handle_ptr->ccu4_slice_ptr,
 8026cd2:	69db      	ldr	r3, [r3, #28]
 8026cd4:	461a      	mov	r2, r3
 8026cd6:	f7fe f9bc 	bl	8025052 <XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent>
    XMC_CCU4_SLICE_StatusBitOverrideConfig(handle_ptr->ccu4_slice_ptr);
 8026cda:	687b      	ldr	r3, [r7, #4]
 8026cdc:	689b      	ldr	r3, [r3, #8]
 8026cde:	4618      	mov	r0, r3
 8026ce0:	f7fe f965 	bl	8024fae <XMC_CCU4_SLICE_StatusBitOverrideConfig>
  }

}
 8026ce4:	bf00      	nop
 8026ce6:	3708      	adds	r7, #8
 8026ce8:	46bd      	mov	sp, r7
 8026cea:	bd80      	pop	{r7, pc}

08026cec <PWM_CCU4_Start>:
/**********************************************************************************************************/
/*Starts the CCU4_CC4 slice. This needs to be called even if external start is configured.*/
PWM_CCU4_STATUS_t PWM_CCU4_Start(PWM_CCU4_t* handle_ptr)
{
 8026cec:	b580      	push	{r7, lr}
 8026cee:	b084      	sub	sp, #16
 8026cf0:	af00      	add	r7, sp, #0
 8026cf2:	6078      	str	r0, [r7, #4]
  PWM_CCU4_STATUS_t status;

  status = PWM_CCU4_STATUS_FAILURE;
 8026cf4:	2301      	movs	r3, #1
 8026cf6:	73fb      	strb	r3, [r7, #15]
  XMC_ASSERT("PWM_CCU4_Start:handle_ptr NULL", (handle_ptr != NULL));
  if ((PWM_CCU4_STATE_INITIALIZED == handle_ptr->state) || (PWM_CCU4_STATE_STOPPED == handle_ptr->state))
 8026cf8:	687b      	ldr	r3, [r7, #4]
 8026cfa:	7f1b      	ldrb	r3, [r3, #28]
 8026cfc:	2b01      	cmp	r3, #1
 8026cfe:	d003      	beq.n	8026d08 <PWM_CCU4_Start+0x1c>
 8026d00:	687b      	ldr	r3, [r7, #4]
 8026d02:	7f1b      	ldrb	r3, [r3, #28]
 8026d04:	2b03      	cmp	r3, #3
 8026d06:	d117      	bne.n	8026d38 <PWM_CCU4_Start+0x4c>
  {
    /* clear IDLE mode for the slice; Start timer */
    XMC_CCU4_EnableClock(handle_ptr->ccu4_module_ptr, handle_ptr->slice_number);
 8026d08:	687b      	ldr	r3, [r7, #4]
 8026d0a:	685a      	ldr	r2, [r3, #4]
 8026d0c:	687b      	ldr	r3, [r7, #4]
 8026d0e:	7b5b      	ldrb	r3, [r3, #13]
 8026d10:	4619      	mov	r1, r3
 8026d12:	4610      	mov	r0, r2
 8026d14:	f7ff fd42 	bl	802679c <XMC_CCU4_EnableClock>

    if (XMC_CCU4_SLICE_EVENT_NONE == handle_ptr->config_ptr->ext_start_event)
 8026d18:	687b      	ldr	r3, [r7, #4]
 8026d1a:	681b      	ldr	r3, [r3, #0]
 8026d1c:	f893 3020 	ldrb.w	r3, [r3, #32]
 8026d20:	2b00      	cmp	r3, #0
 8026d22:	d104      	bne.n	8026d2e <PWM_CCU4_Start+0x42>
    {
      XMC_CCU4_SLICE_StartTimer(handle_ptr->ccu4_slice_ptr);
 8026d24:	687b      	ldr	r3, [r7, #4]
 8026d26:	689b      	ldr	r3, [r3, #8]
 8026d28:	4618      	mov	r0, r3
 8026d2a:	f7ff fd58 	bl	80267de <XMC_CCU4_SLICE_StartTimer>
    }

    handle_ptr->state = PWM_CCU4_STATE_RUNNING;
 8026d2e:	687b      	ldr	r3, [r7, #4]
 8026d30:	2202      	movs	r2, #2
 8026d32:	771a      	strb	r2, [r3, #28]
    status = PWM_CCU4_STATUS_SUCCESS;
 8026d34:	2300      	movs	r3, #0
 8026d36:	73fb      	strb	r3, [r7, #15]
    XMC_DEBUG("PWM_CCU4_Start:start PWM");
  }
  return (status);
 8026d38:	7bfb      	ldrb	r3, [r7, #15]
} /* end of PWM_CCU4_Start() api */
 8026d3a:	4618      	mov	r0, r3
 8026d3c:	3710      	adds	r7, #16
 8026d3e:	46bd      	mov	sp, r7
 8026d40:	bd80      	pop	{r7, pc}

08026d42 <PWM_CCU4_Stop>:
/**********************************************************************************************************/
/*Stops the CCU4_CC4 slice. */
PWM_CCU4_STATUS_t PWM_CCU4_Stop(PWM_CCU4_t* handle_ptr)
{
 8026d42:	b580      	push	{r7, lr}
 8026d44:	b084      	sub	sp, #16
 8026d46:	af00      	add	r7, sp, #0
 8026d48:	6078      	str	r0, [r7, #4]
  PWM_CCU4_STATUS_t status;

  status = PWM_CCU4_STATUS_FAILURE;
 8026d4a:	2301      	movs	r3, #1
 8026d4c:	73fb      	strb	r3, [r7, #15]
  XMC_ASSERT("PWM_CCU4_Stop:handle_ptr NULL", (handle_ptr != NULL));
  if (PWM_CCU4_STATE_UNINITIALIZED != handle_ptr->state)
 8026d4e:	687b      	ldr	r3, [r7, #4]
 8026d50:	7f1b      	ldrb	r3, [r3, #28]
 8026d52:	2b00      	cmp	r3, #0
 8026d54:	d00e      	beq.n	8026d74 <PWM_CCU4_Stop+0x32>
  {
    XMC_CCU4_SLICE_StopTimer(handle_ptr->ccu4_slice_ptr);
 8026d56:	687b      	ldr	r3, [r7, #4]
 8026d58:	689b      	ldr	r3, [r3, #8]
 8026d5a:	4618      	mov	r0, r3
 8026d5c:	f7ff fd4c 	bl	80267f8 <XMC_CCU4_SLICE_StopTimer>
    XMC_CCU4_SLICE_ClearTimer(handle_ptr->ccu4_slice_ptr);
 8026d60:	687b      	ldr	r3, [r7, #4]
 8026d62:	689b      	ldr	r3, [r3, #8]
 8026d64:	4618      	mov	r0, r3
 8026d66:	f7ff fd54 	bl	8026812 <XMC_CCU4_SLICE_ClearTimer>

    handle_ptr->state = PWM_CCU4_STATE_STOPPED;
 8026d6a:	687b      	ldr	r3, [r7, #4]
 8026d6c:	2203      	movs	r2, #3
 8026d6e:	771a      	strb	r2, [r3, #28]
    status = PWM_CCU4_STATUS_SUCCESS;
 8026d70:	2300      	movs	r3, #0
 8026d72:	73fb      	strb	r3, [r7, #15]
    XMC_DEBUG("PWM_CCU4_Stop:stop PWM");
  }
  return (status);
 8026d74:	7bfb      	ldrb	r3, [r7, #15]

} /* end of PWM_CCU4_Stop() api */
 8026d76:	4618      	mov	r0, r3
 8026d78:	3710      	adds	r7, #16
 8026d7a:	46bd      	mov	sp, r7
 8026d7c:	bd80      	pop	{r7, pc}
	...

08026d80 <PWM_CCU4_SetFreqAndDutyCycle>:

/**********************************************************************************************************/

/*Sets the frequency and duty cycle for CCU4_CC4 slice Symmetric Mode. */
PWM_CCU4_STATUS_t PWM_CCU4_SetFreqAndDutyCycle(PWM_CCU4_t* handle_ptr, uint32_t pwm_freq_hz, uint32_t duty)
{
 8026d80:	b580      	push	{r7, lr}
 8026d82:	b088      	sub	sp, #32
 8026d84:	af00      	add	r7, sp, #0
 8026d86:	60f8      	str	r0, [r7, #12]
 8026d88:	60b9      	str	r1, [r7, #8]
 8026d8a:	607a      	str	r2, [r7, #4]
  PWM_CCU4_STATUS_t status;
  uint32_t frequency_tclk;
  uint32_t period;
  uint32_t compare;

  status = PWM_CCU4_STATUS_FAILURE;
 8026d8c:	2301      	movs	r3, #1
 8026d8e:	77fb      	strb	r3, [r7, #31]
  frequency_tclk = 0U;
 8026d90:	2300      	movs	r3, #0
 8026d92:	617b      	str	r3, [r7, #20]
  XMC_ASSERT("PWM_CCU4_SetFreqAndDutyCycle:handle_ptr NULL", (handle_ptr != NULL));
  if (PWM_CCU4_STATE_UNINITIALIZED != handle_ptr->state)
 8026d94:	68fb      	ldr	r3, [r7, #12]
 8026d96:	7f1b      	ldrb	r3, [r3, #28]
 8026d98:	2b00      	cmp	r3, #0
 8026d9a:	d04d      	beq.n	8026e38 <PWM_CCU4_SetFreqAndDutyCycle+0xb8>
  {
    if (0U == pwm_freq_hz)
 8026d9c:	68bb      	ldr	r3, [r7, #8]
 8026d9e:	2b00      	cmp	r3, #0
 8026da0:	d04a      	beq.n	8026e38 <PWM_CCU4_SetFreqAndDutyCycle+0xb8>
    {
      XMC_DEBUG("PWM_CCU4_SetFreqAndDutyCycleSymmetric:cannot set frequency 0Hz");
    }
    else if (duty > PWM_CCU4_SYM_DUTY_MAX)
 8026da2:	687b      	ldr	r3, [r7, #4]
 8026da4:	f242 7210 	movw	r2, #10000	; 0x2710
 8026da8:	4293      	cmp	r3, r2
 8026daa:	d845      	bhi.n	8026e38 <PWM_CCU4_SetFreqAndDutyCycle+0xb8>
    {
      XMC_DEBUG("PWM_CCU4_SetFreqAndDutyCycle:duty > 100%%");
    }
    else
    {
      frequency_tclk = handle_ptr->frequency_tclk;
 8026dac:	68fb      	ldr	r3, [r7, #12]
 8026dae:	6a1b      	ldr	r3, [r3, #32]
 8026db0:	617b      	str	r3, [r7, #20]
      period = frequency_tclk / pwm_freq_hz;
 8026db2:	697a      	ldr	r2, [r7, #20]
 8026db4:	68bb      	ldr	r3, [r7, #8]
 8026db6:	fbb2 f3f3 	udiv	r3, r2, r3
 8026dba:	61bb      	str	r3, [r7, #24]

      if ((uint32_t) XMC_CCU4_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu4_cc4_slice_timer_ptr->timer_mode)
 8026dbc:	68fb      	ldr	r3, [r7, #12]
 8026dbe:	681b      	ldr	r3, [r3, #0]
 8026dc0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8026dc2:	781b      	ldrb	r3, [r3, #0]
 8026dc4:	f003 0301 	and.w	r3, r3, #1
 8026dc8:	b2db      	uxtb	r3, r3
 8026dca:	2b00      	cmp	r3, #0
 8026dcc:	d002      	beq.n	8026dd4 <PWM_CCU4_SetFreqAndDutyCycle+0x54>
      {
        period = period >> 1U;/*divide by 2*/
 8026dce:	69bb      	ldr	r3, [r7, #24]
 8026dd0:	085b      	lsrs	r3, r3, #1
 8026dd2:	61bb      	str	r3, [r7, #24]
      }

      if ((period != 0U) && (period <= PWM_CCU4_MAX_TIMER_COUNT))
 8026dd4:	69bb      	ldr	r3, [r7, #24]
 8026dd6:	2b00      	cmp	r3, #0
 8026dd8:	d02e      	beq.n	8026e38 <PWM_CCU4_SetFreqAndDutyCycle+0xb8>
 8026dda:	69bb      	ldr	r3, [r7, #24]
 8026ddc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8026de0:	d22a      	bcs.n	8026e38 <PWM_CCU4_SetFreqAndDutyCycle+0xb8>
      {
        /*Calculate the current duty cycle in no-timer concatenation mode*/
        compare = ((period * (PWM_CCU4_DUTY_FULL_SCALE - duty)) / PWM_CCU4_DUTY_FULL_SCALE);
 8026de2:	687b      	ldr	r3, [r7, #4]
 8026de4:	f5c3 531c 	rsb	r3, r3, #9984	; 0x2700
 8026de8:	3310      	adds	r3, #16
 8026dea:	69ba      	ldr	r2, [r7, #24]
 8026dec:	fb02 f303 	mul.w	r3, r2, r3
 8026df0:	4a14      	ldr	r2, [pc, #80]	; (8026e44 <PWM_CCU4_SetFreqAndDutyCycle+0xc4>)
 8026df2:	fba2 2303 	umull	r2, r3, r2, r3
 8026df6:	0b5b      	lsrs	r3, r3, #13
 8026df8:	613b      	str	r3, [r7, #16]

        XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, (uint16_t)(period - 1U));
 8026dfa:	68fb      	ldr	r3, [r7, #12]
 8026dfc:	689a      	ldr	r2, [r3, #8]
 8026dfe:	69bb      	ldr	r3, [r7, #24]
 8026e00:	b29b      	uxth	r3, r3
 8026e02:	3b01      	subs	r3, #1
 8026e04:	b29b      	uxth	r3, r3
 8026e06:	4619      	mov	r1, r3
 8026e08:	4610      	mov	r0, r2
 8026e0a:	f7ff fd0f 	bl	802682c <XMC_CCU4_SLICE_SetTimerPeriodMatch>
        XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, (uint16_t) compare);
 8026e0e:	68fb      	ldr	r3, [r7, #12]
 8026e10:	689b      	ldr	r3, [r3, #8]
 8026e12:	693a      	ldr	r2, [r7, #16]
 8026e14:	b292      	uxth	r2, r2
 8026e16:	4611      	mov	r1, r2
 8026e18:	4618      	mov	r0, r3
 8026e1a:	f7ff fd16 	bl	802684a <XMC_CCU4_SLICE_SetTimerCompareMatch>

        XMC_CCU4_EnableShadowTransfer(handle_ptr->ccu4_module_ptr, handle_ptr->shadow_txfr_msk);
 8026e1e:	68fb      	ldr	r3, [r7, #12]
 8026e20:	685a      	ldr	r2, [r3, #4]
 8026e22:	68fb      	ldr	r3, [r7, #12]
 8026e24:	691b      	ldr	r3, [r3, #16]
 8026e26:	4619      	mov	r1, r3
 8026e28:	4610      	mov	r0, r2
 8026e2a:	f7ff fd1d 	bl	8026868 <XMC_CCU4_EnableShadowTransfer>

        handle_ptr->sym_duty = duty;
 8026e2e:	68fb      	ldr	r3, [r7, #12]
 8026e30:	687a      	ldr	r2, [r7, #4]
 8026e32:	625a      	str	r2, [r3, #36]	; 0x24

        XMC_DEBUG("PWM_CCU4_SetFreqAndDutyCycle:frequency set");
        status = PWM_CCU4_STATUS_SUCCESS;
 8026e34:	2300      	movs	r3, #0
 8026e36:	77fb      	strb	r3, [r7, #31]
      }
    }
  }
  return (status);
 8026e38:	7ffb      	ldrb	r3, [r7, #31]

}/* end of PWM_CCU4_SetFreqAndDutyCycle() api */
 8026e3a:	4618      	mov	r0, r3
 8026e3c:	3720      	adds	r7, #32
 8026e3e:	46bd      	mov	sp, r7
 8026e40:	bd80      	pop	{r7, pc}
 8026e42:	bf00      	nop
 8026e44:	d1b71759 	.word	0xd1b71759

08026e48 <PWM_CCU4_ClearEvent>:

/**********************************************************************************************************/

/*Acknowledges the interrupt of  CCU4_CC4 slice. */
void PWM_CCU4_ClearEvent(PWM_CCU4_t* handle_ptr, XMC_CCU4_SLICE_IRQ_ID_t pwm_interrupt)
{
 8026e48:	b580      	push	{r7, lr}
 8026e4a:	b082      	sub	sp, #8
 8026e4c:	af00      	add	r7, sp, #0
 8026e4e:	6078      	str	r0, [r7, #4]
 8026e50:	460b      	mov	r3, r1
 8026e52:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("PWM_CCU4_ClearEvent:handle_ptr NULL", (handle_ptr != NULL));
  XMC_CCU4_SLICE_ClearEvent(handle_ptr->ccu4_slice_ptr, pwm_interrupt);
 8026e54:	687b      	ldr	r3, [r7, #4]
 8026e56:	689b      	ldr	r3, [r3, #8]
 8026e58:	78fa      	ldrb	r2, [r7, #3]
 8026e5a:	4611      	mov	r1, r2
 8026e5c:	4618      	mov	r0, r3
 8026e5e:	f7ff fd28 	bl	80268b2 <XMC_CCU4_SLICE_ClearEvent>
  XMC_DEBUG("PWM_CCU4_ClearEvent:Acknowledge Interrupt");
} /* end of PWM_CCU4_ClearEvent() api */
 8026e62:	bf00      	nop
 8026e64:	3708      	adds	r7, #8
 8026e66:	46bd      	mov	sp, r7
 8026e68:	bd80      	pop	{r7, pc}
	...

08026e6c <__NVIC_GetPriorityGrouping>:
{
 8026e6c:	b480      	push	{r7}
 8026e6e:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8026e70:	4b04      	ldr	r3, [pc, #16]	; (8026e84 <__NVIC_GetPriorityGrouping+0x18>)
 8026e72:	68db      	ldr	r3, [r3, #12]
 8026e74:	0a1b      	lsrs	r3, r3, #8
 8026e76:	f003 0307 	and.w	r3, r3, #7
}
 8026e7a:	4618      	mov	r0, r3
 8026e7c:	46bd      	mov	sp, r7
 8026e7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026e82:	4770      	bx	lr
 8026e84:	e000ed00 	.word	0xe000ed00

08026e88 <__NVIC_EnableIRQ>:
{
 8026e88:	b480      	push	{r7}
 8026e8a:	b083      	sub	sp, #12
 8026e8c:	af00      	add	r7, sp, #0
 8026e8e:	4603      	mov	r3, r0
 8026e90:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8026e92:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8026e96:	2b00      	cmp	r3, #0
 8026e98:	db0b      	blt.n	8026eb2 <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8026e9a:	79fb      	ldrb	r3, [r7, #7]
 8026e9c:	f003 021f 	and.w	r2, r3, #31
 8026ea0:	4907      	ldr	r1, [pc, #28]	; (8026ec0 <__NVIC_EnableIRQ+0x38>)
 8026ea2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8026ea6:	095b      	lsrs	r3, r3, #5
 8026ea8:	2001      	movs	r0, #1
 8026eaa:	fa00 f202 	lsl.w	r2, r0, r2
 8026eae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 8026eb2:	bf00      	nop
 8026eb4:	370c      	adds	r7, #12
 8026eb6:	46bd      	mov	sp, r7
 8026eb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026ebc:	4770      	bx	lr
 8026ebe:	bf00      	nop
 8026ec0:	e000e100 	.word	0xe000e100

08026ec4 <__NVIC_SetPriority>:
{
 8026ec4:	b480      	push	{r7}
 8026ec6:	b083      	sub	sp, #12
 8026ec8:	af00      	add	r7, sp, #0
 8026eca:	4603      	mov	r3, r0
 8026ecc:	6039      	str	r1, [r7, #0]
 8026ece:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8026ed0:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8026ed4:	2b00      	cmp	r3, #0
 8026ed6:	db0a      	blt.n	8026eee <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8026ed8:	683b      	ldr	r3, [r7, #0]
 8026eda:	b2da      	uxtb	r2, r3
 8026edc:	490c      	ldr	r1, [pc, #48]	; (8026f10 <__NVIC_SetPriority+0x4c>)
 8026ede:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8026ee2:	0092      	lsls	r2, r2, #2
 8026ee4:	b2d2      	uxtb	r2, r2
 8026ee6:	440b      	add	r3, r1
 8026ee8:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 8026eec:	e00a      	b.n	8026f04 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8026eee:	683b      	ldr	r3, [r7, #0]
 8026ef0:	b2da      	uxtb	r2, r3
 8026ef2:	4908      	ldr	r1, [pc, #32]	; (8026f14 <__NVIC_SetPriority+0x50>)
 8026ef4:	79fb      	ldrb	r3, [r7, #7]
 8026ef6:	f003 030f 	and.w	r3, r3, #15
 8026efa:	3b04      	subs	r3, #4
 8026efc:	0092      	lsls	r2, r2, #2
 8026efe:	b2d2      	uxtb	r2, r2
 8026f00:	440b      	add	r3, r1
 8026f02:	761a      	strb	r2, [r3, #24]
}
 8026f04:	bf00      	nop
 8026f06:	370c      	adds	r7, #12
 8026f08:	46bd      	mov	sp, r7
 8026f0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026f0e:	4770      	bx	lr
 8026f10:	e000e100 	.word	0xe000e100
 8026f14:	e000ed00 	.word	0xe000ed00

08026f18 <NVIC_EncodePriority>:
{
 8026f18:	b480      	push	{r7}
 8026f1a:	b089      	sub	sp, #36	; 0x24
 8026f1c:	af00      	add	r7, sp, #0
 8026f1e:	60f8      	str	r0, [r7, #12]
 8026f20:	60b9      	str	r1, [r7, #8]
 8026f22:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8026f24:	68fb      	ldr	r3, [r7, #12]
 8026f26:	f003 0307 	and.w	r3, r3, #7
 8026f2a:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8026f2c:	69fb      	ldr	r3, [r7, #28]
 8026f2e:	f1c3 0307 	rsb	r3, r3, #7
 8026f32:	2b06      	cmp	r3, #6
 8026f34:	bf28      	it	cs
 8026f36:	2306      	movcs	r3, #6
 8026f38:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8026f3a:	69fb      	ldr	r3, [r7, #28]
 8026f3c:	3306      	adds	r3, #6
 8026f3e:	2b06      	cmp	r3, #6
 8026f40:	d902      	bls.n	8026f48 <NVIC_EncodePriority+0x30>
 8026f42:	69fb      	ldr	r3, [r7, #28]
 8026f44:	3b01      	subs	r3, #1
 8026f46:	e000      	b.n	8026f4a <NVIC_EncodePriority+0x32>
 8026f48:	2300      	movs	r3, #0
 8026f4a:	617b      	str	r3, [r7, #20]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8026f4c:	f04f 32ff 	mov.w	r2, #4294967295
 8026f50:	69bb      	ldr	r3, [r7, #24]
 8026f52:	fa02 f303 	lsl.w	r3, r2, r3
 8026f56:	43da      	mvns	r2, r3
 8026f58:	68bb      	ldr	r3, [r7, #8]
 8026f5a:	401a      	ands	r2, r3
 8026f5c:	697b      	ldr	r3, [r7, #20]
 8026f5e:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8026f60:	f04f 31ff 	mov.w	r1, #4294967295
 8026f64:	697b      	ldr	r3, [r7, #20]
 8026f66:	fa01 f303 	lsl.w	r3, r1, r3
 8026f6a:	43d9      	mvns	r1, r3
 8026f6c:	687b      	ldr	r3, [r7, #4]
 8026f6e:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8026f70:	4313      	orrs	r3, r2
}
 8026f72:	4618      	mov	r0, r3
 8026f74:	3724      	adds	r7, #36	; 0x24
 8026f76:	46bd      	mov	sp, r7
 8026f78:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026f7c:	4770      	bx	lr

08026f7e <INTERRUPT_Enable>:
 *    return 0;
 *  }
 * @endcode<BR> </p>
 */
__STATIC_INLINE void INTERRUPT_Enable(const INTERRUPT_t *const handler)
{
 8026f7e:	b580      	push	{r7, lr}
 8026f80:	b082      	sub	sp, #8
 8026f82:	af00      	add	r7, sp, #0
 8026f84:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("Handler NULL", (handler != NULL));
  NVIC_EnableIRQ(handler->node);
 8026f86:	687b      	ldr	r3, [r7, #4]
 8026f88:	f993 3000 	ldrsb.w	r3, [r3]
 8026f8c:	4618      	mov	r0, r3
 8026f8e:	f7ff ff7b 	bl	8026e88 <__NVIC_EnableIRQ>
}
 8026f92:	bf00      	nop
 8026f94:	3708      	adds	r7, #8
 8026f96:	46bd      	mov	sp, r7
 8026f98:	bd80      	pop	{r7, pc}

08026f9a <INTERRUPT_Init>:

/*
 * API to initialize the INTERRUPT APP
 */
INTERRUPT_STATUS_t INTERRUPT_Init(const INTERRUPT_t *const handler)
{
 8026f9a:	b590      	push	{r4, r7, lr}
 8026f9c:	b083      	sub	sp, #12
 8026f9e:	af00      	add	r7, sp, #0
 8026fa0:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("INTERRUPT_Init:HandlePtr NULL", (handler != NULL));
  
#if(UC_FAMILY == XMC4)

  NVIC_SetPriority(handler->node,
 8026fa2:	687b      	ldr	r3, [r7, #4]
 8026fa4:	f993 4000 	ldrsb.w	r4, [r3]
 8026fa8:	f7ff ff60 	bl	8026e6c <__NVIC_GetPriorityGrouping>
                   NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
                                       handler->priority,
 8026fac:	687b      	ldr	r3, [r7, #4]
 8026fae:	785b      	ldrb	r3, [r3, #1]
  NVIC_SetPriority(handler->node,
 8026fb0:	4619      	mov	r1, r3
                                       handler->subpriority));
 8026fb2:	687b      	ldr	r3, [r7, #4]
 8026fb4:	789b      	ldrb	r3, [r3, #2]
  NVIC_SetPriority(handler->node,
 8026fb6:	461a      	mov	r2, r3
 8026fb8:	f7ff ffae 	bl	8026f18 <NVIC_EncodePriority>
 8026fbc:	4603      	mov	r3, r0
 8026fbe:	4619      	mov	r1, r3
 8026fc0:	4620      	mov	r0, r4
 8026fc2:	f7ff ff7f 	bl	8026ec4 <__NVIC_SetPriority>
  if (handler->enable_at_init == true)
 8026fc6:	687b      	ldr	r3, [r7, #4]
 8026fc8:	78db      	ldrb	r3, [r3, #3]
 8026fca:	2b00      	cmp	r3, #0
 8026fcc:	d002      	beq.n	8026fd4 <INTERRUPT_Init+0x3a>
  {
    INTERRUPT_Enable(handler);
 8026fce:	6878      	ldr	r0, [r7, #4]
 8026fd0:	f7ff ffd5 	bl	8026f7e <INTERRUPT_Enable>
  {
    INTERRUPT_Enable(handler);
  }
#endif

  return (INTERRUPT_STATUS_SUCCESS);
 8026fd4:	2300      	movs	r3, #0
}
 8026fd6:	4618      	mov	r0, r3
 8026fd8:	370c      	adds	r7, #12
 8026fda:	46bd      	mov	sp, r7
 8026fdc:	bd90      	pop	{r4, r7, pc}

08026fde <XMC_CCU4_StartPrescaler>:
{
 8026fde:	b480      	push	{r7}
 8026fe0:	b083      	sub	sp, #12
 8026fe2:	af00      	add	r7, sp, #0
 8026fe4:	6078      	str	r0, [r7, #4]
  module->GIDLC = (uint32_t) CCU4_GIDLC_SPRB_Msk;
 8026fe6:	687b      	ldr	r3, [r7, #4]
 8026fe8:	f44f 7280 	mov.w	r2, #256	; 0x100
 8026fec:	60da      	str	r2, [r3, #12]
}
 8026fee:	bf00      	nop
 8026ff0:	370c      	adds	r7, #12
 8026ff2:	46bd      	mov	sp, r7
 8026ff4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026ff8:	4770      	bx	lr

08026ffa <GLOBAL_CCU4_Init>:
  return version;
}

/* Initializes the slice with the generated configuration */
GLOBAL_CCU4_STATUS_t GLOBAL_CCU4_Init(GLOBAL_CCU4_t* handle)
{
 8026ffa:	b580      	push	{r7, lr}
 8026ffc:	b082      	sub	sp, #8
 8026ffe:	af00      	add	r7, sp, #0
 8027000:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("GLOBAL_CCU4_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
 8027002:	687b      	ldr	r3, [r7, #4]
 8027004:	7b5b      	ldrb	r3, [r3, #13]
 8027006:	f083 0301 	eor.w	r3, r3, #1
 802700a:	b2db      	uxtb	r3, r3
 802700c:	2b00      	cmp	r3, #0
 802700e:	d00f      	beq.n	8027030 <GLOBAL_CCU4_Init+0x36>
  {
    /* Enable CCU4 module */
    XMC_CCU4_Init(handle->module_ptr,handle->mcs_action);
 8027010:	687b      	ldr	r3, [r7, #4]
 8027012:	689a      	ldr	r2, [r3, #8]
 8027014:	687b      	ldr	r3, [r7, #4]
 8027016:	7b1b      	ldrb	r3, [r3, #12]
 8027018:	4619      	mov	r1, r3
 802701a:	4610      	mov	r0, r2
 802701c:	f7fd fe0d 	bl	8024c3a <XMC_CCU4_Init>
    /* Start the prescaler */
    XMC_CCU4_StartPrescaler(handle->module_ptr);
 8027020:	687b      	ldr	r3, [r7, #4]
 8027022:	689b      	ldr	r3, [r3, #8]
 8027024:	4618      	mov	r0, r3
 8027026:	f7ff ffda 	bl	8026fde <XMC_CCU4_StartPrescaler>
    /* Restricts multiple initializations */
    handle->is_initialized = true;
 802702a:	687b      	ldr	r3, [r7, #4]
 802702c:	2201      	movs	r2, #1
 802702e:	735a      	strb	r2, [r3, #13]
  }

  return (GLOBAL_CCU4_STATUS_SUCCESS);
 8027030:	2300      	movs	r3, #0
}
 8027032:	4618      	mov	r0, r3
 8027034:	3708      	adds	r7, #8
 8027036:	46bd      	mov	sp, r7
 8027038:	bd80      	pop	{r7, pc}

0802703a <GLOBAL_CAN_Init>:
  return (version);
}

/*  Function to initialize the CAN Peripheral module clock.  */
GLOBAL_CAN_STATUS_t GLOBAL_CAN_Init(GLOBAL_CAN_t *handle)
{
 802703a:	b580      	push	{r7, lr}
 802703c:	b084      	sub	sp, #16
 802703e:	af00      	add	r7, sp, #0
 8027040:	6078      	str	r0, [r7, #4]
  GLOBAL_CAN_STATUS_t status = GLOBAL_CAN_STATUS_SUCCESS;
 8027042:	2300      	movs	r3, #0
 8027044:	73fb      	strb	r3, [r7, #15]

  XMC_ASSERT("GLOBAL_CAN_Init: handle null", handle != NULL);

  if (handle->init_status != true)
 8027046:	687b      	ldr	r3, [r7, #4]
 8027048:	7a5b      	ldrb	r3, [r3, #9]
 802704a:	f083 0301 	eor.w	r3, r3, #1
 802704e:	b2db      	uxtb	r3, r3
 8027050:	2b00      	cmp	r3, #0
 8027052:	d00d      	beq.n	8027070 <GLOBAL_CAN_Init+0x36>
  {
#if defined(MULTICAN_PLUS)
    XMC_CAN_InitEx(handle->canglobal_ptr, (XMC_CAN_CANCLKSRC_t)handle->can_clock_src, handle->can_frequency);
 8027054:	687b      	ldr	r3, [r7, #4]
 8027056:	6858      	ldr	r0, [r3, #4]
 8027058:	687b      	ldr	r3, [r7, #4]
 802705a:	7a19      	ldrb	r1, [r3, #8]
 802705c:	687b      	ldr	r3, [r7, #4]
 802705e:	681b      	ldr	r3, [r3, #0]
 8027060:	461a      	mov	r2, r3
 8027062:	f7fd fb6c 	bl	802473e <XMC_CAN_InitEx>
#else
    XMC_CAN_InitEx(handle->canglobal_ptr, XMC_CAN_CANCLKSRC_FPERI, handle->can_frequency);
#endif
    handle->init_status = true;
 8027066:	687b      	ldr	r3, [r7, #4]
 8027068:	2201      	movs	r2, #1
 802706a:	725a      	strb	r2, [r3, #9]
    status = GLOBAL_CAN_STATUS_SUCCESS;
 802706c:	2300      	movs	r3, #0
 802706e:	73fb      	strb	r3, [r7, #15]
  }
  return (status);
 8027070:	7bfb      	ldrb	r3, [r7, #15]

}
 8027072:	4618      	mov	r0, r3
 8027074:	3710      	adds	r7, #16
 8027076:	46bd      	mov	sp, r7
 8027078:	bd80      	pop	{r7, pc}

0802707a <XMC_VADC_GLOBAL_DisablePostCalibration>:
{
 802707a:	b480      	push	{r7}
 802707c:	b083      	sub	sp, #12
 802707e:	af00      	add	r7, sp, #0
 8027080:	6078      	str	r0, [r7, #4]
 8027082:	6039      	str	r1, [r7, #0]
  global_ptr->GLOBCFG |= (uint32_t)((uint32_t)1 << ((uint32_t)VADC_GLOBCFG_DPCAL0_Pos + group_number));
 8027084:	687b      	ldr	r3, [r7, #4]
 8027086:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 802708a:	683b      	ldr	r3, [r7, #0]
 802708c:	3310      	adds	r3, #16
 802708e:	2101      	movs	r1, #1
 8027090:	fa01 f303 	lsl.w	r3, r1, r3
 8027094:	431a      	orrs	r2, r3
 8027096:	687b      	ldr	r3, [r7, #4]
 8027098:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
}
 802709c:	bf00      	nop
 802709e:	370c      	adds	r7, #12
 80270a0:	46bd      	mov	sp, r7
 80270a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80270a6:	4770      	bx	lr

080270a8 <GLOBAL_ADC_Init>:
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/**
 * This function initializes all instances of the ADC Global APP and low level app.
 */
GLOBAL_ADC_STATUS_t GLOBAL_ADC_Init(GLOBAL_ADC_t *const handle_ptr)
{
 80270a8:	b580      	push	{r7, lr}
 80270aa:	b084      	sub	sp, #16
 80270ac:	af00      	add	r7, sp, #0
 80270ae:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("GLOBAL_ADC_Init:Invalid handle_ptr", (handle_ptr != NULL));
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  uint32_t group_index;
#endif

  if (GLOBAL_ADC_UNINITIALIZED == handle_ptr->init_state)
 80270b0:	687b      	ldr	r3, [r7, #4]
 80270b2:	7e1b      	ldrb	r3, [r3, #24]
 80270b4:	2b02      	cmp	r3, #2
 80270b6:	d148      	bne.n	802714a <GLOBAL_ADC_Init+0xa2>
  {  
    /* Initialize an instance of Global hardware */
    XMC_VADC_GLOBAL_Init(handle_ptr->module_ptr, handle_ptr->global_config_handle);
 80270b8:	687b      	ldr	r3, [r7, #4]
 80270ba:	695a      	ldr	r2, [r3, #20]
 80270bc:	687b      	ldr	r3, [r7, #4]
 80270be:	691b      	ldr	r3, [r3, #16]
 80270c0:	4619      	mov	r1, r3
 80270c2:	4610      	mov	r0, r2
 80270c4:	f7fe fd07 	bl	8025ad6 <XMC_VADC_GLOBAL_Init>

    /* Initialize all the Groups */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
    for(group_index = (uint32_t)0; group_index < XMC_VADC_MAXIMUM_NUM_GROUPS; group_index++)
 80270c8:	2300      	movs	r3, #0
 80270ca:	60fb      	str	r3, [r7, #12]
 80270cc:	e02e      	b.n	802712c <GLOBAL_ADC_Init+0x84>
    {
      /*Initialize Group*/
      XMC_VADC_GROUP_Init(handle_ptr->group_ptrs_array[group_index]->group_handle,
 80270ce:	687b      	ldr	r3, [r7, #4]
 80270d0:	68fa      	ldr	r2, [r7, #12]
 80270d2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80270d6:	6818      	ldr	r0, [r3, #0]
    		            handle_ptr->group_ptrs_array[group_index]->group_config_handle);
 80270d8:	687b      	ldr	r3, [r7, #4]
 80270da:	68fa      	ldr	r2, [r7, #12]
 80270dc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
      XMC_VADC_GROUP_Init(handle_ptr->group_ptrs_array[group_index]->group_handle,
 80270e0:	685b      	ldr	r3, [r3, #4]
 80270e2:	4619      	mov	r1, r3
 80270e4:	f7fe fda1 	bl	8025c2a <XMC_VADC_GROUP_Init>

      /* Switch on the converter of the Group[group_index]*/
      XMC_VADC_GROUP_SetPowerMode(handle_ptr->group_ptrs_array[group_index]->group_handle,
 80270e8:	687b      	ldr	r3, [r7, #4]
 80270ea:	68fa      	ldr	r2, [r7, #12]
 80270ec:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80270f0:	681b      	ldr	r3, [r3, #0]
 80270f2:	2103      	movs	r1, #3
 80270f4:	4618      	mov	r0, r3
 80270f6:	f7fe fe29 	bl	8025d4c <XMC_VADC_GROUP_SetPowerMode>
                                  XMC_VADC_GROUP_POWERMODE_NORMAL);

      /* Disable the post calibration option for the respective group*/
      if ((bool)false == handle_ptr->group_ptrs_array[group_index]->post_calibration)
 80270fa:	687b      	ldr	r3, [r7, #4]
 80270fc:	68fa      	ldr	r2, [r7, #12]
 80270fe:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8027102:	7a1b      	ldrb	r3, [r3, #8]
 8027104:	f083 0301 	eor.w	r3, r3, #1
 8027108:	b2db      	uxtb	r3, r3
 802710a:	2b00      	cmp	r3, #0
 802710c:	d005      	beq.n	802711a <GLOBAL_ADC_Init+0x72>
      {
        XMC_VADC_GLOBAL_DisablePostCalibration(handle_ptr->module_ptr,group_index);
 802710e:	687b      	ldr	r3, [r7, #4]
 8027110:	695b      	ldr	r3, [r3, #20]
 8027112:	68f9      	ldr	r1, [r7, #12]
 8027114:	4618      	mov	r0, r3
 8027116:	f7ff ffb0 	bl	802707a <XMC_VADC_GLOBAL_DisablePostCalibration>

#if(XMC_VADC_SHS_AVAILABLE == 1U)
      XMC_VADC_GLOBAL_SHS_EnableAcceleratedMode(handle_ptr->global_shs_ptr, (XMC_VADC_GROUP_INDEX_t)group_index);
#endif

      handle_ptr->group_ptrs_array[group_index]->state = GLOBAL_ADC_SUCCESS;
 802711a:	687b      	ldr	r3, [r7, #4]
 802711c:	68fa      	ldr	r2, [r7, #12]
 802711e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8027122:	2200      	movs	r2, #0
 8027124:	725a      	strb	r2, [r3, #9]
    for(group_index = (uint32_t)0; group_index < XMC_VADC_MAXIMUM_NUM_GROUPS; group_index++)
 8027126:	68fb      	ldr	r3, [r7, #12]
 8027128:	3301      	adds	r3, #1
 802712a:	60fb      	str	r3, [r7, #12]
 802712c:	68fb      	ldr	r3, [r7, #12]
 802712e:	2b03      	cmp	r3, #3
 8027130:	d9cd      	bls.n	80270ce <GLOBAL_ADC_Init+0x26>
#endif
#endif /* _XMC_VADC_GROUP_AVAILABLE_ */
#if(XMC_VADC_SHS_AVAILABLE == 1U)
    XMC_VADC_GLOBAL_SHS_SetAnalogReference(handle_ptr->global_shs_ptr, GLOBAL_ADC_AREF_VALUE);
#endif
    if((bool)true == handle_ptr->enable_startup_calibration)
 8027132:	687b      	ldr	r3, [r7, #4]
 8027134:	7e5b      	ldrb	r3, [r3, #25]
 8027136:	2b00      	cmp	r3, #0
 8027138:	d004      	beq.n	8027144 <GLOBAL_ADC_Init+0x9c>
    {
    	XMC_VADC_GLOBAL_StartupCalibration(handle_ptr->module_ptr);
 802713a:	687b      	ldr	r3, [r7, #4]
 802713c:	695b      	ldr	r3, [r3, #20]
 802713e:	4618      	mov	r0, r3
 8027140:	f7fe fd1a 	bl	8025b78 <XMC_VADC_GLOBAL_StartupCalibration>
    }
    handle_ptr->init_state = GLOBAL_ADC_SUCCESS;
 8027144:	687b      	ldr	r3, [r7, #4]
 8027146:	2200      	movs	r2, #0
 8027148:	761a      	strb	r2, [r3, #24]
  }
  return (handle_ptr->init_state);
 802714a:	687b      	ldr	r3, [r7, #4]
 802714c:	7e1b      	ldrb	r3, [r3, #24]
}
 802714e:	4618      	mov	r0, r3
 8027150:	3710      	adds	r7, #16
 8027152:	46bd      	mov	sp, r7
 8027154:	bd80      	pop	{r7, pc}

08027156 <DIGITAL_IO_Init>:
* @param handler Pointer pointing to APP data structure.
* @return DIGITAL_IO_STATUS_t DIGITAL_IO APP status.
*/

DIGITAL_IO_STATUS_t DIGITAL_IO_Init(const DIGITAL_IO_t *const handler)
{
 8027156:	b580      	push	{r7, lr}
 8027158:	b082      	sub	sp, #8
 802715a:	af00      	add	r7, sp, #0
 802715c:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_Init: handler null pointer", handler != NULL);

  /* Initializes input / output characteristics */
  XMC_GPIO_Init(handler->gpio_port, handler->gpio_pin, &handler->gpio_config);
 802715e:	687b      	ldr	r3, [r7, #4]
 8027160:	6818      	ldr	r0, [r3, #0]
 8027162:	687b      	ldr	r3, [r7, #4]
 8027164:	7c19      	ldrb	r1, [r3, #16]
 8027166:	687b      	ldr	r3, [r7, #4]
 8027168:	3304      	adds	r3, #4
 802716a:	461a      	mov	r2, r3
 802716c:	f7fc fc0e 	bl	802398c <XMC_GPIO_Init>

  /*Configure hardware port control*/
  XMC_GPIO_SetHardwareControl(handler->gpio_port, handler->gpio_pin, handler->hwctrl);
 8027170:	687b      	ldr	r3, [r7, #4]
 8027172:	6818      	ldr	r0, [r3, #0]
 8027174:	687b      	ldr	r3, [r7, #4]
 8027176:	7c19      	ldrb	r1, [r3, #16]
 8027178:	687b      	ldr	r3, [r7, #4]
 802717a:	7c5b      	ldrb	r3, [r3, #17]
 802717c:	461a      	mov	r2, r3
 802717e:	f7fe fb4b 	bl	8025818 <XMC_GPIO_SetHardwareControl>

  return (DIGITAL_IO_STATUS_OK);
 8027182:	2300      	movs	r3, #0
}
 8027184:	4618      	mov	r0, r3
 8027186:	3708      	adds	r7, #8
 8027188:	46bd      	mov	sp, r7
 802718a:	bd80      	pop	{r7, pc}

0802718c <__NVIC_SetPriorityGrouping>:
{
 802718c:	b480      	push	{r7}
 802718e:	b085      	sub	sp, #20
 8027190:	af00      	add	r7, sp, #0
 8027192:	6078      	str	r0, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8027194:	687b      	ldr	r3, [r7, #4]
 8027196:	f003 0307 	and.w	r3, r3, #7
 802719a:	60fb      	str	r3, [r7, #12]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 802719c:	4b0c      	ldr	r3, [pc, #48]	; (80271d0 <__NVIC_SetPriorityGrouping+0x44>)
 802719e:	68db      	ldr	r3, [r3, #12]
 80271a0:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80271a2:	68ba      	ldr	r2, [r7, #8]
 80271a4:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 80271a8:	4013      	ands	r3, r2
 80271aa:	60bb      	str	r3, [r7, #8]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80271ac:	68fb      	ldr	r3, [r7, #12]
 80271ae:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80271b0:	68bb      	ldr	r3, [r7, #8]
 80271b2:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 80271b4:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80271b8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80271bc:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 80271be:	4a04      	ldr	r2, [pc, #16]	; (80271d0 <__NVIC_SetPriorityGrouping+0x44>)
 80271c0:	68bb      	ldr	r3, [r7, #8]
 80271c2:	60d3      	str	r3, [r2, #12]
}
 80271c4:	bf00      	nop
 80271c6:	3714      	adds	r7, #20
 80271c8:	46bd      	mov	sp, r7
 80271ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80271ce:	4770      	bx	lr
 80271d0:	e000ed00 	.word	0xe000ed00

080271d4 <SystemCoreSetup>:
  .initialized = false
};	


void SystemCoreSetup(void)
{
 80271d4:	b580      	push	{r7, lr}
 80271d6:	b082      	sub	sp, #8
 80271d8:	af00      	add	r7, sp, #0
  uint32_t temp;

  NVIC_SetPriorityGrouping(1U);
 80271da:	2001      	movs	r0, #1
 80271dc:	f7ff ffd6 	bl	802718c <__NVIC_SetPriorityGrouping>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80271e0:	b672      	cpsid	i
}
 80271e2:	bf00      	nop
	
  /* relocate vector table */
  __disable_irq();

#if !defined(__TASKING__)
  SCB->VTOR = (uint32_t)(&__Vectors);
 80271e4:	4b22      	ldr	r3, [pc, #136]	; (8027270 <SystemCoreSetup+0x9c>)
 80271e6:	4a23      	ldr	r2, [pc, #140]	; (8027274 <SystemCoreSetup+0xa0>)
 80271e8:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80271ea:	f3bf 8f4f 	dsb	sy
}
 80271ee:	bf00      	nop
  __ASM volatile ("cpsie i" : : : "memory");
 80271f0:	b662      	cpsie	i
}
 80271f2:	bf00      	nop

  __DSB();
  __enable_irq();
	
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */
 80271f4:	4b1e      	ldr	r3, [pc, #120]	; (8027270 <SystemCoreSetup+0x9c>)
 80271f6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80271fa:	4a1d      	ldr	r2, [pc, #116]	; (8027270 <SystemCoreSetup+0x9c>)
 80271fc:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8027200:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
				 (3UL << 11*2)  );               /* set CP11 Full Access */
#endif
  /* Set flash wait states */
  temp = FLASH0->FCON;
 8027204:	4b1c      	ldr	r3, [pc, #112]	; (8027278 <SystemCoreSetup+0xa4>)
 8027206:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 802720a:	695b      	ldr	r3, [r3, #20]
 802720c:	607b      	str	r3, [r7, #4]
  temp &= ~FLASH_FCON_WSPFLASH_Msk;
 802720e:	687b      	ldr	r3, [r7, #4]
 8027210:	f023 030f 	bic.w	r3, r3, #15
 8027214:	607b      	str	r3, [r7, #4]
  temp |= PMU_FLASH_WS;
 8027216:	687b      	ldr	r3, [r7, #4]
 8027218:	f043 0304 	orr.w	r3, r3, #4
 802721c:	607b      	str	r3, [r7, #4]
  FLASH0->FCON = temp;
 802721e:	4b16      	ldr	r3, [pc, #88]	; (8027278 <SystemCoreSetup+0xa4>)
 8027220:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8027224:	461a      	mov	r2, r3
 8027226:	687b      	ldr	r3, [r7, #4]
 8027228:	6153      	str	r3, [r2, #20]


  /* Disable divide by zero trap */
  SCB->CCR &= ~SCB_CCR_DIV_0_TRP_Msk; 
 802722a:	4b11      	ldr	r3, [pc, #68]	; (8027270 <SystemCoreSetup+0x9c>)
 802722c:	695b      	ldr	r3, [r3, #20]
 802722e:	4a10      	ldr	r2, [pc, #64]	; (8027270 <SystemCoreSetup+0x9c>)
 8027230:	f023 0310 	bic.w	r3, r3, #16
 8027234:	6153      	str	r3, [r2, #20]

  /* Disable unaligned memory access trap */
  SCB->CCR &= ~SCB_CCR_UNALIGN_TRP_Msk; 
 8027236:	4b0e      	ldr	r3, [pc, #56]	; (8027270 <SystemCoreSetup+0x9c>)
 8027238:	695b      	ldr	r3, [r3, #20]
 802723a:	4a0d      	ldr	r2, [pc, #52]	; (8027270 <SystemCoreSetup+0x9c>)
 802723c:	f023 0308 	bic.w	r3, r3, #8
 8027240:	6153      	str	r3, [r2, #20]

  /* Disable memory management fault */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 8027242:	4b0b      	ldr	r3, [pc, #44]	; (8027270 <SystemCoreSetup+0x9c>)
 8027244:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8027246:	4a0a      	ldr	r2, [pc, #40]	; (8027270 <SystemCoreSetup+0x9c>)
 8027248:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 802724c:	6253      	str	r3, [r2, #36]	; 0x24

  /* Disable bus fault */
  SCB->SHCSR &= ~SCB_SHCSR_BUSFAULTENA_Msk;
 802724e:	4b08      	ldr	r3, [pc, #32]	; (8027270 <SystemCoreSetup+0x9c>)
 8027250:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8027252:	4a07      	ldr	r2, [pc, #28]	; (8027270 <SystemCoreSetup+0x9c>)
 8027254:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8027258:	6253      	str	r3, [r2, #36]	; 0x24

  /* Disable usage fault */
  SCB->SHCSR &= ~SCB_SHCSR_USGFAULTENA_Msk;
 802725a:	4b05      	ldr	r3, [pc, #20]	; (8027270 <SystemCoreSetup+0x9c>)
 802725c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802725e:	4a04      	ldr	r2, [pc, #16]	; (8027270 <SystemCoreSetup+0x9c>)
 8027260:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8027264:	6253      	str	r3, [r2, #36]	; 0x24
}
 8027266:	bf00      	nop
 8027268:	3708      	adds	r7, #8
 802726a:	46bd      	mov	sp, r7
 802726c:	bd80      	pop	{r7, pc}
 802726e:	bf00      	nop
 8027270:	e000ed00 	.word	0xe000ed00
 8027274:	08020400 	.word	0x08020400
 8027278:	58001000 	.word	0x58001000

0802727c <CLOCK_XMC4_Init>:

/*
 * API to initialize the CLOCK_XMC4 APP TRAP events
 */
CLOCK_XMC4_STATUS_t CLOCK_XMC4_Init(CLOCK_XMC4_t *handle)
{
 802727c:	b480      	push	{r7}
 802727e:	b085      	sub	sp, #20
 8027280:	af00      	add	r7, sp, #0
 8027282:	6078      	str	r0, [r7, #4]
  CLOCK_XMC4_STATUS_t status = CLOCK_XMC4_STATUS_SUCCESS;
 8027284:	2300      	movs	r3, #0
 8027286:	73fb      	strb	r3, [r7, #15]

  XMC_ASSERT("CLOCK_XMC4 APP handle function pointer uninitialized", (handle != NULL));

  handle->init_status = true;
 8027288:	687b      	ldr	r3, [r7, #4]
 802728a:	2201      	movs	r2, #1
 802728c:	701a      	strb	r2, [r3, #0]

  return (status);
 802728e:	7bfb      	ldrb	r3, [r7, #15]
}
 8027290:	4618      	mov	r0, r3
 8027292:	3714      	adds	r7, #20
 8027294:	46bd      	mov	sp, r7
 8027296:	f85d 7b04 	ldr.w	r7, [sp], #4
 802729a:	4770      	bx	lr

0802729c <OSCHP_GetFrequency>:

#ifdef CLOCK_XMC4_OSCHP_ENABLED
/*  API to retrieve high precision external oscillator frequency */
uint32_t OSCHP_GetFrequency(void)
{
 802729c:	b480      	push	{r7}
 802729e:	af00      	add	r7, sp, #0
  return (CLOCK_XMC4_OSCHP_FREQUENCY);
 80272a0:	4b02      	ldr	r3, [pc, #8]	; (80272ac <OSCHP_GetFrequency+0x10>)
}
 80272a2:	4618      	mov	r0, r3
 80272a4:	46bd      	mov	sp, r7
 80272a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80272aa:	4770      	bx	lr
 80272ac:	007a1200 	.word	0x007a1200

080272b0 <SystemCoreClockSetup>:
* @note   -
* @param  None
* @retval None
*/
void SystemCoreClockSetup(void)
{
 80272b0:	b5b0      	push	{r4, r5, r7, lr}
 80272b2:	b086      	sub	sp, #24
 80272b4:	af00      	add	r7, sp, #0
  /* Local data structure for initializing the clock functional block */
  const XMC_SCU_CLOCK_CONFIG_t CLOCK_XMC4_0_CONFIG =
 80272b6:	4b13      	ldr	r3, [pc, #76]	; (8027304 <SystemCoreClockSetup+0x54>)
 80272b8:	1d3c      	adds	r4, r7, #4
 80272ba:	461d      	mov	r5, r3
 80272bc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80272be:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80272c0:	682b      	ldr	r3, [r5, #0]
 80272c2:	6023      	str	r3, [r4, #0]
#endif
    /* Peripheral Clock Divider Value */
    .fperipheral_clkdiv = 1U
  };
  /* Initialize the SCU clock */
  XMC_SCU_CLOCK_Init(&CLOCK_XMC4_0_CONFIG);
 80272c4:	1d3b      	adds	r3, r7, #4
 80272c6:	4618      	mov	r0, r3
 80272c8:	f7fc fc62 	bl	8023b90 <XMC_SCU_CLOCK_Init>
  /* RTC source clock */
  XMC_SCU_HIB_SetRtcClockSource(XMC_SCU_HIB_RTCCLKSRC_OSI);
 80272cc:	2000      	movs	r0, #0
 80272ce:	f7fc fd5b 	bl	8023d88 <XMC_SCU_HIB_SetRtcClockSource>
  
#ifdef CLOCK_XMC4_USBCLK_ENABLED  
  /* USB/SDMMC source clock */
  XMC_SCU_CLOCK_SetUsbClockSource(XMC_SCU_CLOCK_USBCLKSRC_USBPLL);
 80272d2:	2000      	movs	r0, #0
 80272d4:	f7fc fd0e 	bl	8023cf4 <XMC_SCU_CLOCK_SetUsbClockSource>
  /* USB/SDMMC divider setting */
  XMC_SCU_CLOCK_SetUsbClockDivider(4U);
 80272d8:	2004      	movs	r0, #4
 80272da:	f7fc fdcd 	bl	8023e78 <XMC_SCU_CLOCK_SetUsbClockDivider>
#endif
  /* Start USB PLL */
  XMC_SCU_CLOCK_EnableUsbPll();
 80272de:	f7fc fe3b 	bl	8023f58 <XMC_SCU_CLOCK_EnableUsbPll>
  XMC_SCU_CLOCK_StartUsbPll(1U, 48U);
 80272e2:	2130      	movs	r1, #48	; 0x30
 80272e4:	2001      	movs	r0, #1
 80272e6:	f7fc fe49 	bl	8023f7c <XMC_SCU_CLOCK_StartUsbPll>

#ifdef CLOCK_XMC4_WDTCLK_ENABLED    
  /* WDT source clock */
  XMC_SCU_CLOCK_SetWdtClockSource(XMC_SCU_CLOCK_WDTCLKSRC_OFI);
 80272ea:	2000      	movs	r0, #0
 80272ec:	f7fc fd16 	bl	8023d1c <XMC_SCU_CLOCK_SetWdtClockSource>
  /* WDT divider setting */
  XMC_SCU_CLOCK_SetWdtClockDivider(1U);
 80272f0:	2001      	movs	r0, #1
 80272f2:	f7fc fded 	bl	8023ed0 <XMC_SCU_CLOCK_SetWdtClockDivider>
#endif

#ifdef CLOCK_XMC4_EBUCLK_ENABLED 
  /* EBU divider setting */
  XMC_SCU_CLOCK_SetEbuClockDivider(1U);
 80272f6:	2001      	movs	r0, #1
 80272f8:	f7fc fdd4 	bl	8023ea4 <XMC_SCU_CLOCK_SetEbuClockDivider>
#endif

}
 80272fc:	bf00      	nop
 80272fe:	3718      	adds	r7, #24
 8027300:	46bd      	mov	sp, r7
 8027302:	bdb0      	pop	{r4, r5, r7, pc}
 8027304:	080288b8 	.word	0x080288b8

08027308 <XMC_CAN_NODE_SetEventNodePointer>:
{
 8027308:	b480      	push	{r7}
 802730a:	b085      	sub	sp, #20
 802730c:	af00      	add	r7, sp, #0
 802730e:	60f8      	str	r0, [r7, #12]
 8027310:	460b      	mov	r3, r1
 8027312:	607a      	str	r2, [r7, #4]
 8027314:	72fb      	strb	r3, [r7, #11]
  can_node->NIPR = (uint32_t)((can_node->NIPR) & ~(uint32_t)(CAN_NODE_NIPR_Msk << (uint32_t)ptr_event)) | (service_request << (uint32_t)ptr_event);
 8027316:	68fb      	ldr	r3, [r7, #12]
 8027318:	689a      	ldr	r2, [r3, #8]
 802731a:	7afb      	ldrb	r3, [r7, #11]
 802731c:	2107      	movs	r1, #7
 802731e:	fa01 f303 	lsl.w	r3, r1, r3
 8027322:	43db      	mvns	r3, r3
 8027324:	401a      	ands	r2, r3
 8027326:	7afb      	ldrb	r3, [r7, #11]
 8027328:	6879      	ldr	r1, [r7, #4]
 802732a:	fa01 f303 	lsl.w	r3, r1, r3
 802732e:	431a      	orrs	r2, r3
 8027330:	68fb      	ldr	r3, [r7, #12]
 8027332:	609a      	str	r2, [r3, #8]
}
 8027334:	bf00      	nop
 8027336:	3714      	adds	r7, #20
 8027338:	46bd      	mov	sp, r7
 802733a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802733e:	4770      	bx	lr

08027340 <XMC_CAN_NODE_SetReceiveInput>:
{
 8027340:	b480      	push	{r7}
 8027342:	b083      	sub	sp, #12
 8027344:	af00      	add	r7, sp, #0
 8027346:	6078      	str	r0, [r7, #4]
 8027348:	460b      	mov	r3, r1
 802734a:	70fb      	strb	r3, [r7, #3]
  can_node->NPCR = ((can_node->NPCR) & ~(uint32_t)(CAN_NODE_NPCR_RXSEL_Msk)) |
 802734c:	687b      	ldr	r3, [r7, #4]
 802734e:	68db      	ldr	r3, [r3, #12]
 8027350:	f023 0207 	bic.w	r2, r3, #7
                   (((uint32_t)input << CAN_NODE_NPCR_RXSEL_Pos) & (uint32_t)CAN_NODE_NPCR_RXSEL_Msk);
 8027354:	78fb      	ldrb	r3, [r7, #3]
 8027356:	f003 0307 	and.w	r3, r3, #7
  can_node->NPCR = ((can_node->NPCR) & ~(uint32_t)(CAN_NODE_NPCR_RXSEL_Msk)) |
 802735a:	431a      	orrs	r2, r3
 802735c:	687b      	ldr	r3, [r7, #4]
 802735e:	60da      	str	r2, [r3, #12]
}
 8027360:	bf00      	nop
 8027362:	370c      	adds	r7, #12
 8027364:	46bd      	mov	sp, r7
 8027366:	f85d 7b04 	ldr.w	r7, [sp], #4
 802736a:	4770      	bx	lr

0802736c <XMC_CAN_NODE_EnableLoopBack>:
{
 802736c:	b480      	push	{r7}
 802736e:	b083      	sub	sp, #12
 8027370:	af00      	add	r7, sp, #0
 8027372:	6078      	str	r0, [r7, #4]
  can_node->NPCR |= (uint32_t)CAN_NODE_NPCR_LBM_Msk;
 8027374:	687b      	ldr	r3, [r7, #4]
 8027376:	68db      	ldr	r3, [r3, #12]
 8027378:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 802737c:	687b      	ldr	r3, [r7, #4]
 802737e:	60da      	str	r2, [r3, #12]
}
 8027380:	bf00      	nop
 8027382:	370c      	adds	r7, #12
 8027384:	46bd      	mov	sp, r7
 8027386:	f85d 7b04 	ldr.w	r7, [sp], #4
 802738a:	4770      	bx	lr

0802738c <XMC_CAN_NODE_EnableConfigurationChange>:
{
 802738c:	b480      	push	{r7}
 802738e:	b083      	sub	sp, #12
 8027390:	af00      	add	r7, sp, #0
 8027392:	6078      	str	r0, [r7, #4]
  can_node->NCR |= (uint32_t)CAN_NODE_NCR_CCE_Msk;
 8027394:	687b      	ldr	r3, [r7, #4]
 8027396:	681b      	ldr	r3, [r3, #0]
 8027398:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 802739c:	687b      	ldr	r3, [r7, #4]
 802739e:	601a      	str	r2, [r3, #0]
}
 80273a0:	bf00      	nop
 80273a2:	370c      	adds	r7, #12
 80273a4:	46bd      	mov	sp, r7
 80273a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80273aa:	4770      	bx	lr

080273ac <XMC_CAN_NODE_DisableConfigurationChange>:
{
 80273ac:	b480      	push	{r7}
 80273ae:	b083      	sub	sp, #12
 80273b0:	af00      	add	r7, sp, #0
 80273b2:	6078      	str	r0, [r7, #4]
  can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_CCE_Msk;
 80273b4:	687b      	ldr	r3, [r7, #4]
 80273b6:	681b      	ldr	r3, [r3, #0]
 80273b8:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 80273bc:	687b      	ldr	r3, [r7, #4]
 80273be:	601a      	str	r2, [r3, #0]
}
 80273c0:	bf00      	nop
 80273c2:	370c      	adds	r7, #12
 80273c4:	46bd      	mov	sp, r7
 80273c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80273ca:	4770      	bx	lr

080273cc <XMC_CAN_NODE_SetInitBit>:
 * XMC_CAN_NODE_ResetInitBit()
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_SetInitBit(XMC_CAN_NODE_t *const can_node)
{
 80273cc:	b480      	push	{r7}
 80273ce:	b083      	sub	sp, #12
 80273d0:	af00      	add	r7, sp, #0
 80273d2:	6078      	str	r0, [r7, #4]
  can_node->NCR |= (uint32_t)CAN_NODE_NCR_INIT_Msk;
 80273d4:	687b      	ldr	r3, [r7, #4]
 80273d6:	681b      	ldr	r3, [r3, #0]
 80273d8:	f043 0201 	orr.w	r2, r3, #1
 80273dc:	687b      	ldr	r3, [r7, #4]
 80273de:	601a      	str	r2, [r3, #0]
}
 80273e0:	bf00      	nop
 80273e2:	370c      	adds	r7, #12
 80273e4:	46bd      	mov	sp, r7
 80273e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80273ea:	4770      	bx	lr

080273ec <XMC_CAN_NODE_ResetInitBit>:
 * \par<b>Related API's:</b><br>
 * XMC_CAN_NODE_SetInitBit()
 *
 */
__STATIC_INLINE void XMC_CAN_NODE_ResetInitBit(XMC_CAN_NODE_t *const can_node)
{
 80273ec:	b480      	push	{r7}
 80273ee:	b083      	sub	sp, #12
 80273f0:	af00      	add	r7, sp, #0
 80273f2:	6078      	str	r0, [r7, #4]
  can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_INIT_Msk;
 80273f4:	687b      	ldr	r3, [r7, #4]
 80273f6:	681b      	ldr	r3, [r3, #0]
 80273f8:	f023 0201 	bic.w	r2, r3, #1
 80273fc:	687b      	ldr	r3, [r7, #4]
 80273fe:	601a      	str	r2, [r3, #0]
}
 8027400:	bf00      	nop
 8027402:	370c      	adds	r7, #12
 8027404:	46bd      	mov	sp, r7
 8027406:	f85d 7b04 	ldr.w	r7, [sp], #4
 802740a:	4770      	bx	lr

0802740c <XMC_CAN_NODE_ReSetAnalyzerMode>:
 * XMC_CAN_NODE_SetAnalyzerMode()
 *
 */

__STATIC_INLINE void XMC_CAN_NODE_ReSetAnalyzerMode(XMC_CAN_NODE_t *const can_node)
{
 802740c:	b480      	push	{r7}
 802740e:	b083      	sub	sp, #12
 8027410:	af00      	add	r7, sp, #0
 8027412:	6078      	str	r0, [r7, #4]
  can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_CALM_Msk;
 8027414:	687b      	ldr	r3, [r7, #4]
 8027416:	681b      	ldr	r3, [r3, #0]
 8027418:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 802741c:	687b      	ldr	r3, [r7, #4]
 802741e:	601a      	str	r2, [r3, #0]
}
 8027420:	bf00      	nop
 8027422:	370c      	adds	r7, #12
 8027424:	46bd      	mov	sp, r7
 8027426:	f85d 7b04 	ldr.w	r7, [sp], #4
 802742a:	4770      	bx	lr

0802742c <XMC_CAN_MO_SetEventNodePointer>:
 */

__STATIC_INLINE void XMC_CAN_MO_SetEventNodePointer(const XMC_CAN_MO_t *const can_mo,
    const XMC_CAN_MO_POINTER_EVENT_t can_mo_ptr_int,
    const uint32_t service_request)
{
 802742c:	b480      	push	{r7}
 802742e:	b085      	sub	sp, #20
 8027430:	af00      	add	r7, sp, #0
 8027432:	60f8      	str	r0, [r7, #12]
 8027434:	460b      	mov	r3, r1
 8027436:	607a      	str	r2, [r7, #4]
 8027438:	72fb      	strb	r3, [r7, #11]
  can_mo->can_mo_ptr->MOIPR = ((can_mo->can_mo_ptr->MOIPR ) & ~(uint32_t)((uint32_t)CAN_MO_MOIPR_Msk << (uint32_t)can_mo_ptr_int)) |
 802743a:	68fb      	ldr	r3, [r7, #12]
 802743c:	681b      	ldr	r3, [r3, #0]
 802743e:	689a      	ldr	r2, [r3, #8]
 8027440:	7afb      	ldrb	r3, [r7, #11]
 8027442:	2107      	movs	r1, #7
 8027444:	fa01 f303 	lsl.w	r3, r1, r3
 8027448:	43db      	mvns	r3, r3
 802744a:	ea02 0103 	and.w	r1, r2, r3
                              (service_request << (uint32_t)can_mo_ptr_int);
 802744e:	7afb      	ldrb	r3, [r7, #11]
 8027450:	687a      	ldr	r2, [r7, #4]
 8027452:	409a      	lsls	r2, r3
  can_mo->can_mo_ptr->MOIPR = ((can_mo->can_mo_ptr->MOIPR ) & ~(uint32_t)((uint32_t)CAN_MO_MOIPR_Msk << (uint32_t)can_mo_ptr_int)) |
 8027454:	68fb      	ldr	r3, [r7, #12]
 8027456:	681b      	ldr	r3, [r3, #0]
 8027458:	430a      	orrs	r2, r1
 802745a:	609a      	str	r2, [r3, #8]
}
 802745c:	bf00      	nop
 802745e:	3714      	adds	r7, #20
 8027460:	46bd      	mov	sp, r7
 8027462:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027466:	4770      	bx	lr

08027468 <XMC_CAN_MO_EnableEvent>:
 *
 */

__STATIC_INLINE void XMC_CAN_MO_EnableEvent(const XMC_CAN_MO_t *const can_mo,
    const uint32_t event)
{
 8027468:	b480      	push	{r7}
 802746a:	b083      	sub	sp, #12
 802746c:	af00      	add	r7, sp, #0
 802746e:	6078      	str	r0, [r7, #4]
 8027470:	6039      	str	r1, [r7, #0]
  can_mo->can_mo_ptr->MOFCR |= event;
 8027472:	687b      	ldr	r3, [r7, #4]
 8027474:	681b      	ldr	r3, [r3, #0]
 8027476:	6819      	ldr	r1, [r3, #0]
 8027478:	687b      	ldr	r3, [r7, #4]
 802747a:	681b      	ldr	r3, [r3, #0]
 802747c:	683a      	ldr	r2, [r7, #0]
 802747e:	430a      	orrs	r2, r1
 8027480:	601a      	str	r2, [r3, #0]
}
 8027482:	bf00      	nop
 8027484:	370c      	adds	r7, #12
 8027486:	46bd      	mov	sp, r7
 8027488:	f85d 7b04 	ldr.w	r7, [sp], #4
 802748c:	4770      	bx	lr

0802748e <CAN_NODE_MO_EnableTxEvent>:
 *   return (1);
 * }
 * @endcode
 */
__STATIC_INLINE void CAN_NODE_MO_EnableTxEvent(const CAN_NODE_LMO_t *const can_lmo)
{
 802748e:	b580      	push	{r7, lr}
 8027490:	b082      	sub	sp, #8
 8027492:	af00      	add	r7, sp, #0
 8027494:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("CAN_NODE_MO_EnableTxEvent: null pointer", can_lmo != NULL);
  XMC_CAN_MO_EnableEvent(can_lmo->mo_ptr,XMC_CAN_MO_EVENT_TRANSMIT);
 8027496:	687b      	ldr	r3, [r7, #4]
 8027498:	681b      	ldr	r3, [r3, #0]
 802749a:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 802749e:	4618      	mov	r0, r3
 80274a0:	f7ff ffe2 	bl	8027468 <XMC_CAN_MO_EnableEvent>
}
 80274a4:	bf00      	nop
 80274a6:	3708      	adds	r7, #8
 80274a8:	46bd      	mov	sp, r7
 80274aa:	bd80      	pop	{r7, pc}

080274ac <CAN_NODE_MO_EnableRxEvent>:
 *   return (1);
 * }
 * @endcode
 */
__STATIC_INLINE void CAN_NODE_MO_EnableRxEvent(const CAN_NODE_LMO_t *const can_lmo)
{
 80274ac:	b580      	push	{r7, lr}
 80274ae:	b082      	sub	sp, #8
 80274b0:	af00      	add	r7, sp, #0
 80274b2:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("CAN_NODE_MO_EnableRxEvent: null pointer", can_lmo != NULL);
  XMC_CAN_MO_EnableEvent(can_lmo->mo_ptr,XMC_CAN_MO_EVENT_RECEIVE);
 80274b4:	687b      	ldr	r3, [r7, #4]
 80274b6:	681b      	ldr	r3, [r3, #0]
 80274b8:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 80274bc:	4618      	mov	r0, r3
 80274be:	f7ff ffd3 	bl	8027468 <XMC_CAN_MO_EnableEvent>
}
 80274c2:	bf00      	nop
 80274c4:	3708      	adds	r7, #8
 80274c6:	46bd      	mov	sp, r7
 80274c8:	bd80      	pop	{r7, pc}

080274ca <CAN_NODE_SetNodeEvents>:
  * @param  handle is a pointer pointing to APP data structure.
  * @return None
  */

static void CAN_NODE_SetNodeEvents(const CAN_NODE_t *handle)
{
 80274ca:	b580      	push	{r7, lr}
 80274cc:	b084      	sub	sp, #16
 80274ce:	af00      	add	r7, sp, #0
 80274d0:	6078      	str	r0, [r7, #4]
  uint32_t lnode_event = 0U;
 80274d2:	2300      	movs	r3, #0
 80274d4:	60fb      	str	r3, [r7, #12]

  XMC_ASSERT("CAN_NODE_lInit: handle null", handle != NULL);

  CAN_NODE_SetNodePointer(handle); /* set node service pointer */
 80274d6:	6878      	ldr	r0, [r7, #4]
 80274d8:	f000 f831 	bl	802753e <CAN_NODE_SetNodePointer>

  if (handle->txok_event_enable == true)
 80274dc:	687b      	ldr	r3, [r7, #4]
 80274de:	f893 30a4 	ldrb.w	r3, [r3, #164]	; 0xa4
 80274e2:	2b00      	cmp	r3, #0
 80274e4:	d003      	beq.n	80274ee <CAN_NODE_SetNodeEvents+0x24>
  {
    lnode_event |= XMC_CAN_NODE_EVENT_TX_INT;
 80274e6:	68fb      	ldr	r3, [r7, #12]
 80274e8:	f043 0302 	orr.w	r3, r3, #2
 80274ec:	60fb      	str	r3, [r7, #12]
  }
  if (handle->lec_event_enable == true)
 80274ee:	687b      	ldr	r3, [r7, #4]
 80274f0:	f893 30a3 	ldrb.w	r3, [r3, #163]	; 0xa3
 80274f4:	2b00      	cmp	r3, #0
 80274f6:	d003      	beq.n	8027500 <CAN_NODE_SetNodeEvents+0x36>
  {
    lnode_event |= XMC_CAN_NODE_EVENT_LEC;
 80274f8:	68fb      	ldr	r3, [r7, #12]
 80274fa:	f043 0304 	orr.w	r3, r3, #4
 80274fe:	60fb      	str	r3, [r7, #12]
  }
  if (handle->alert_event_enable == true)
 8027500:	687b      	ldr	r3, [r7, #4]
 8027502:	f893 30a5 	ldrb.w	r3, [r3, #165]	; 0xa5
 8027506:	2b00      	cmp	r3, #0
 8027508:	d003      	beq.n	8027512 <CAN_NODE_SetNodeEvents+0x48>
  {
    lnode_event |= XMC_CAN_NODE_EVENT_ALERT;
 802750a:	68fb      	ldr	r3, [r7, #12]
 802750c:	f043 0308 	orr.w	r3, r3, #8
 8027510:	60fb      	str	r3, [r7, #12]
  }
  XMC_CAN_NODE_EnableEvent(handle->node_ptr, (XMC_CAN_NODE_EVENT_t)lnode_event);
 8027512:	687b      	ldr	r3, [r7, #4]
 8027514:	685b      	ldr	r3, [r3, #4]
 8027516:	68f9      	ldr	r1, [r7, #12]
 8027518:	4618      	mov	r0, r3
 802751a:	f7fd faee 	bl	8024afa <XMC_CAN_NODE_EnableEvent>

  if (handle->framecount_event_enable == true)
 802751e:	687b      	ldr	r3, [r7, #4]
 8027520:	f893 30a6 	ldrb.w	r3, [r3, #166]	; 0xa6
 8027524:	2b00      	cmp	r3, #0
 8027526:	d006      	beq.n	8027536 <CAN_NODE_SetNodeEvents+0x6c>
  {
    XMC_CAN_NODE_EnableEvent(handle->node_ptr, XMC_CAN_NODE_EVENT_CFCIE);
 8027528:	687b      	ldr	r3, [r7, #4]
 802752a:	685b      	ldr	r3, [r3, #4]
 802752c:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8027530:	4618      	mov	r0, r3
 8027532:	f7fd fae2 	bl	8024afa <XMC_CAN_NODE_EnableEvent>
  }

}
 8027536:	bf00      	nop
 8027538:	3710      	adds	r7, #16
 802753a:	46bd      	mov	sp, r7
 802753c:	bd80      	pop	{r7, pc}

0802753e <CAN_NODE_SetNodePointer>:
  * @brief  Function to set the Node event pointer
  *
  */

static void CAN_NODE_SetNodePointer(const CAN_NODE_t *handle)
{
 802753e:	b580      	push	{r7, lr}
 8027540:	b082      	sub	sp, #8
 8027542:	af00      	add	r7, sp, #0
 8027544:	6078      	str	r0, [r7, #4]

  XMC_ASSERT("CAN_NODE_SetNodePointer: handle null", handle != NULL);

  /* Configured the node event pointer for the alert event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_ALERT,
 8027546:	687b      	ldr	r3, [r7, #4]
 8027548:	6858      	ldr	r0, [r3, #4]
                                                        handle->node_sr_ptr->alert_event_sr);
 802754a:	687b      	ldr	r3, [r7, #4]
 802754c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8027550:	781b      	ldrb	r3, [r3, #0]
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_ALERT,
 8027552:	461a      	mov	r2, r3
 8027554:	2100      	movs	r1, #0
 8027556:	f7ff fed7 	bl	8027308 <XMC_CAN_NODE_SetEventNodePointer>
  /* Configured the node event pointer for the LEC event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_LEC,
 802755a:	687b      	ldr	r3, [r7, #4]
 802755c:	6858      	ldr	r0, [r3, #4]
                                                         handle->node_sr_ptr->lec_event_sr);
 802755e:	687b      	ldr	r3, [r7, #4]
 8027560:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8027564:	785b      	ldrb	r3, [r3, #1]
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_LEC,
 8027566:	461a      	mov	r2, r3
 8027568:	2104      	movs	r1, #4
 802756a:	f7ff fecd 	bl	8027308 <XMC_CAN_NODE_SetEventNodePointer>
  /* Configured the node event pointer for the TXOK event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_TRANSFER_OK,
 802756e:	687b      	ldr	r3, [r7, #4]
 8027570:	6858      	ldr	r0, [r3, #4]
                                                               handle->node_sr_ptr->txok_event_sr);
 8027572:	687b      	ldr	r3, [r7, #4]
 8027574:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8027578:	789b      	ldrb	r3, [r3, #2]
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_TRANSFER_OK,
 802757a:	461a      	mov	r2, r3
 802757c:	2108      	movs	r1, #8
 802757e:	f7ff fec3 	bl	8027308 <XMC_CAN_NODE_SetEventNodePointer>
  /* Configured the node event pointer for the Frame counter event with the service request number */
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_FRAME_COUNTER,
 8027582:	687b      	ldr	r3, [r7, #4]
 8027584:	6858      	ldr	r0, [r3, #4]
                                                             handle->node_sr_ptr->framecount_event_sr);
 8027586:	687b      	ldr	r3, [r7, #4]
 8027588:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 802758c:	78db      	ldrb	r3, [r3, #3]
  XMC_CAN_NODE_SetEventNodePointer(handle->node_ptr, XMC_CAN_NODE_POINTER_EVENT_FRAME_COUNTER,
 802758e:	461a      	mov	r2, r3
 8027590:	210c      	movs	r1, #12
 8027592:	f7ff feb9 	bl	8027308 <XMC_CAN_NODE_SetEventNodePointer>

}
 8027596:	bf00      	nop
 8027598:	3708      	adds	r7, #8
 802759a:	46bd      	mov	sp, r7
 802759c:	bd80      	pop	{r7, pc}

0802759e <CAN_NODE_MO_Init>:
  XMC_CAN_NODE_NominalBitTimeConfigure(can_node, can_bit_time);
}

/*  Function to initialize the CAN MO based on UI configuration. */
void CAN_NODE_MO_Init(const CAN_NODE_LMO_t *lmo_ptr)
{
 802759e:	b580      	push	{r7, lr}
 80275a0:	b082      	sub	sp, #8
 80275a2:	af00      	add	r7, sp, #0
 80275a4:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("CAN_NODE_MO_Init: lmo_ptr null", lmo_ptr != NULL);

  XMC_CAN_MO_Config(lmo_ptr->mo_ptr);
 80275a6:	687b      	ldr	r3, [r7, #4]
 80275a8:	681b      	ldr	r3, [r3, #0]
 80275aa:	4618      	mov	r0, r3
 80275ac:	f7fd f908 	bl	80247c0 <XMC_CAN_MO_Config>

  if (lmo_ptr->tx_event_enable == true)
 80275b0:	687b      	ldr	r3, [r7, #4]
 80275b2:	79db      	ldrb	r3, [r3, #7]
 80275b4:	2b00      	cmp	r3, #0
 80275b6:	d00a      	beq.n	80275ce <CAN_NODE_MO_Init+0x30>
  {
    XMC_CAN_MO_SetEventNodePointer(lmo_ptr->mo_ptr, XMC_CAN_MO_POINTER_EVENT_TRANSMIT, lmo_ptr->tx_sr);
 80275b8:	687b      	ldr	r3, [r7, #4]
 80275ba:	6818      	ldr	r0, [r3, #0]
 80275bc:	687b      	ldr	r3, [r7, #4]
 80275be:	795b      	ldrb	r3, [r3, #5]
 80275c0:	461a      	mov	r2, r3
 80275c2:	2104      	movs	r1, #4
 80275c4:	f7ff ff32 	bl	802742c <XMC_CAN_MO_SetEventNodePointer>
    CAN_NODE_MO_EnableTxEvent(lmo_ptr);
 80275c8:	6878      	ldr	r0, [r7, #4]
 80275ca:	f7ff ff60 	bl	802748e <CAN_NODE_MO_EnableTxEvent>
  }
  if (lmo_ptr->rx_event_enable == true)
 80275ce:	687b      	ldr	r3, [r7, #4]
 80275d0:	7a1b      	ldrb	r3, [r3, #8]
 80275d2:	2b00      	cmp	r3, #0
 80275d4:	d00a      	beq.n	80275ec <CAN_NODE_MO_Init+0x4e>
  {
    XMC_CAN_MO_SetEventNodePointer(lmo_ptr->mo_ptr, XMC_CAN_MO_POINTER_EVENT_RECEIVE, lmo_ptr->rx_sr);
 80275d6:	687b      	ldr	r3, [r7, #4]
 80275d8:	6818      	ldr	r0, [r3, #0]
 80275da:	687b      	ldr	r3, [r7, #4]
 80275dc:	799b      	ldrb	r3, [r3, #6]
 80275de:	461a      	mov	r2, r3
 80275e0:	2100      	movs	r1, #0
 80275e2:	f7ff ff23 	bl	802742c <XMC_CAN_MO_SetEventNodePointer>
    CAN_NODE_MO_EnableRxEvent(lmo_ptr);
 80275e6:	6878      	ldr	r0, [r7, #4]
 80275e8:	f7ff ff60 	bl	80274ac <CAN_NODE_MO_EnableRxEvent>
  }

}
 80275ec:	bf00      	nop
 80275ee:	3708      	adds	r7, #8
 80275f0:	46bd      	mov	sp, r7
 80275f2:	bd80      	pop	{r7, pc}

080275f4 <CAN_NODE_MO_Receive>:
  return (status);
}

/* Function to read the received CAN message from the selected message object. */
CAN_NODE_STATUS_t CAN_NODE_MO_Receive( CAN_NODE_LMO_t *lmo_ptr)
{
 80275f4:	b580      	push	{r7, lr}
 80275f6:	b084      	sub	sp, #16
 80275f8:	af00      	add	r7, sp, #0
 80275fa:	6078      	str	r0, [r7, #4]
  CAN_NODE_STATUS_t status = CAN_NODE_STATUS_SUCCESS;
 80275fc:	2300      	movs	r3, #0
 80275fe:	73fb      	strb	r3, [r7, #15]
  XMC_ASSERT("CAN_NODE_MO_Receive: lmo_ptr null", lmo_ptr != NULL);

  status = (CAN_NODE_STATUS_t)XMC_CAN_MO_Receive(lmo_ptr->mo_ptr);
 8027600:	687b      	ldr	r3, [r7, #4]
 8027602:	681b      	ldr	r3, [r3, #0]
 8027604:	4618      	mov	r0, r3
 8027606:	f7fd f9af 	bl	8024968 <XMC_CAN_MO_Receive>
 802760a:	4603      	mov	r3, r0
 802760c:	73fb      	strb	r3, [r7, #15]
  return (status);
 802760e:	7bfb      	ldrb	r3, [r7, #15]
}
 8027610:	4618      	mov	r0, r3
 8027612:	3710      	adds	r7, #16
 8027614:	46bd      	mov	sp, r7
 8027616:	bd80      	pop	{r7, pc}

08027618 <CAN_NODE_Init>:
/*  Function to initialize the CAN node by configuring the baud rate, can bus type (External or internal)
 *  and message objects.
 */

CAN_NODE_STATUS_t CAN_NODE_Init(const CAN_NODE_t* handle)
{
 8027618:	b580      	push	{r7, lr}
 802761a:	b086      	sub	sp, #24
 802761c:	af00      	add	r7, sp, #0
 802761e:	6078      	str	r0, [r7, #4]
  CAN_NODE_STATUS_t status = CAN_NODE_STATUS_SUCCESS;
 8027620:	2300      	movs	r3, #0
 8027622:	75fb      	strb	r3, [r7, #23]
  uint32_t loop_count;
  const CAN_NODE_LMO_t *lmo_ptr;

  XMC_ASSERT("CAN_NODE_Init: handle null", handle != NULL);

  const CAN_NODE_GPIO_t *const lgpio_ptr = handle->gpio_out;
 8027624:	687b      	ldr	r3, [r7, #4]
 8027626:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 802762a:	60fb      	str	r3, [r7, #12]

  /* Initialize the GLOBAL_CAN APP */
  status  = (CAN_NODE_STATUS_t)GLOBAL_CAN_Init(handle->global_ptr);
 802762c:	687b      	ldr	r3, [r7, #4]
 802762e:	681b      	ldr	r3, [r3, #0]
 8027630:	4618      	mov	r0, r3
 8027632:	f7ff fd02 	bl	802703a <GLOBAL_CAN_Init>
 8027636:	4603      	mov	r3, r0
 8027638:	75fb      	strb	r3, [r7, #23]

  if (status == CAN_NODE_STATUS_SUCCESS)
 802763a:	7dfb      	ldrb	r3, [r7, #23]
 802763c:	2b00      	cmp	r3, #0
 802763e:	f040 8081 	bne.w	8027744 <CAN_NODE_Init+0x12c>
  {
    /* Initialize the GUI configured values for baud rate to NBTR Reg */
    if (XMC_CAN_NODE_NominalBitTimeConfigureEx(handle->node_ptr, handle->baudrate_config) == XMC_CAN_STATUS_SUCCESS)
 8027642:	687b      	ldr	r3, [r7, #4]
 8027644:	685a      	ldr	r2, [r3, #4]
 8027646:	687b      	ldr	r3, [r7, #4]
 8027648:	689b      	ldr	r3, [r3, #8]
 802764a:	4619      	mov	r1, r3
 802764c:	4610      	mov	r0, r2
 802764e:	f7fc ff4d 	bl	80244ec <XMC_CAN_NODE_NominalBitTimeConfigureEx>
 8027652:	4603      	mov	r3, r0
 8027654:	2b00      	cmp	r3, #0
 8027656:	d172      	bne.n	802773e <CAN_NODE_Init+0x126>
    {
      /* set CCE and INIT bit NCR for node configuration */

      XMC_CAN_NODE_EnableConfigurationChange(handle->node_ptr);
 8027658:	687b      	ldr	r3, [r7, #4]
 802765a:	685b      	ldr	r3, [r3, #4]
 802765c:	4618      	mov	r0, r3
 802765e:	f7ff fe95 	bl	802738c <XMC_CAN_NODE_EnableConfigurationChange>
      XMC_CAN_NODE_SetInitBit(handle->node_ptr);
 8027662:	687b      	ldr	r3, [r7, #4]
 8027664:	685b      	ldr	r3, [r3, #4]
 8027666:	4618      	mov	r0, r3
 8027668:	f7ff feb0 	bl	80273cc <XMC_CAN_NODE_SetInitBit>
      XMC_CAN_NODE_ReSetAnalyzerMode(handle->node_ptr);
 802766c:	687b      	ldr	r3, [r7, #4]
 802766e:	685b      	ldr	r3, [r3, #4]
 8027670:	4618      	mov	r0, r3
 8027672:	f7ff fecb 	bl	802740c <XMC_CAN_NODE_ReSetAnalyzerMode>

      if (handle->loopback_enable == true) /* Loop back mode enabled */
 8027676:	687b      	ldr	r3, [r7, #4]
 8027678:	f893 30a7 	ldrb.w	r3, [r3, #167]	; 0xa7
 802767c:	2b00      	cmp	r3, #0
 802767e:	d005      	beq.n	802768c <CAN_NODE_Init+0x74>
      {
        XMC_CAN_NODE_EnableLoopBack(handle->node_ptr);
 8027680:	687b      	ldr	r3, [r7, #4]
 8027682:	685b      	ldr	r3, [r3, #4]
 8027684:	4618      	mov	r0, r3
 8027686:	f7ff fe71 	bl	802736c <XMC_CAN_NODE_EnableLoopBack>
 802768a:	e016      	b.n	80276ba <CAN_NODE_Init+0xa2>
      }
      else
      {
        XMC_GPIO_Init(handle->gpio_in->port, handle->gpio_in->pin, handle->gpio_in_config);
 802768c:	687b      	ldr	r3, [r7, #4]
 802768e:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8027692:	6818      	ldr	r0, [r3, #0]
 8027694:	687b      	ldr	r3, [r7, #4]
 8027696:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 802769a:	7919      	ldrb	r1, [r3, #4]
 802769c:	687b      	ldr	r3, [r7, #4]
 802769e:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 80276a2:	461a      	mov	r2, r3
 80276a4:	f7fc f972 	bl	802398c <XMC_GPIO_Init>
        XMC_CAN_NODE_SetReceiveInput(handle->node_ptr, handle->rx_signal);
 80276a8:	687b      	ldr	r3, [r7, #4]
 80276aa:	685a      	ldr	r2, [r3, #4]
 80276ac:	687b      	ldr	r3, [r7, #4]
 80276ae:	f893 30a0 	ldrb.w	r3, [r3, #160]	; 0xa0
 80276b2:	4619      	mov	r1, r3
 80276b4:	4610      	mov	r0, r2
 80276b6:	f7ff fe43 	bl	8027340 <XMC_CAN_NODE_SetReceiveInput>
      }
      CAN_NODE_SetNodeEvents(handle); /* API to enable node events */
 80276ba:	6878      	ldr	r0, [r7, #4]
 80276bc:	f7ff ff05 	bl	80274ca <CAN_NODE_SetNodeEvents>

      for (loop_count = 0U; loop_count < handle->mo_count; loop_count++)
 80276c0:	2300      	movs	r3, #0
 80276c2:	613b      	str	r3, [r7, #16]
 80276c4:	e017      	b.n	80276f6 <CAN_NODE_Init+0xde>
      {
        lmo_ptr = handle->lmobj_ptr[loop_count];
 80276c6:	687a      	ldr	r2, [r7, #4]
 80276c8:	693b      	ldr	r3, [r7, #16]
 80276ca:	3302      	adds	r3, #2
 80276cc:	009b      	lsls	r3, r3, #2
 80276ce:	4413      	add	r3, r2
 80276d0:	685b      	ldr	r3, [r3, #4]
 80276d2:	60bb      	str	r3, [r7, #8]
        XMC_CAN_AllocateMOtoNodeList(handle->global_ptr->canglobal_ptr, handle->node_num, lmo_ptr->number);
 80276d4:	687b      	ldr	r3, [r7, #4]
 80276d6:	681b      	ldr	r3, [r3, #0]
 80276d8:	6858      	ldr	r0, [r3, #4]
 80276da:	687b      	ldr	r3, [r7, #4]
 80276dc:	f893 10a1 	ldrb.w	r1, [r3, #161]	; 0xa1
 80276e0:	68bb      	ldr	r3, [r7, #8]
 80276e2:	791b      	ldrb	r3, [r3, #4]
 80276e4:	461a      	mov	r2, r3
 80276e6:	f7fc ffab 	bl	8024640 <XMC_CAN_AllocateMOtoNodeList>
        CAN_NODE_MO_Init(lmo_ptr);
 80276ea:	68b8      	ldr	r0, [r7, #8]
 80276ec:	f7ff ff57 	bl	802759e <CAN_NODE_MO_Init>
      for (loop_count = 0U; loop_count < handle->mo_count; loop_count++)
 80276f0:	693b      	ldr	r3, [r7, #16]
 80276f2:	3301      	adds	r3, #1
 80276f4:	613b      	str	r3, [r7, #16]
 80276f6:	687b      	ldr	r3, [r7, #4]
 80276f8:	f893 30a2 	ldrb.w	r3, [r3, #162]	; 0xa2
 80276fc:	461a      	mov	r2, r3
 80276fe:	693b      	ldr	r3, [r7, #16]
 8027700:	4293      	cmp	r3, r2
 8027702:	d3e0      	bcc.n	80276c6 <CAN_NODE_Init+0xae>
      }
      /* reset CCE and INIT bit NCR for node configuration */
      XMC_CAN_NODE_DisableConfigurationChange(handle->node_ptr);
 8027704:	687b      	ldr	r3, [r7, #4]
 8027706:	685b      	ldr	r3, [r3, #4]
 8027708:	4618      	mov	r0, r3
 802770a:	f7ff fe4f 	bl	80273ac <XMC_CAN_NODE_DisableConfigurationChange>
      XMC_CAN_NODE_ResetInitBit(handle->node_ptr);
 802770e:	687b      	ldr	r3, [r7, #4]
 8027710:	685b      	ldr	r3, [r3, #4]
 8027712:	4618      	mov	r0, r3
 8027714:	f7ff fe6a 	bl	80273ec <XMC_CAN_NODE_ResetInitBit>
      if (handle->loopback_enable == false)
 8027718:	687b      	ldr	r3, [r7, #4]
 802771a:	f893 30a7 	ldrb.w	r3, [r3, #167]	; 0xa7
 802771e:	f083 0301 	eor.w	r3, r3, #1
 8027722:	b2db      	uxtb	r3, r3
 8027724:	2b00      	cmp	r3, #0
 8027726:	d00f      	beq.n	8027748 <CAN_NODE_Init+0x130>
      {
        /* CAN transmit pin configuration */
        XMC_GPIO_Init(lgpio_ptr->port, lgpio_ptr->pin, handle->gpio_out_config);
 8027728:	68fb      	ldr	r3, [r7, #12]
 802772a:	6818      	ldr	r0, [r3, #0]
 802772c:	68fb      	ldr	r3, [r7, #12]
 802772e:	7919      	ldrb	r1, [r3, #4]
 8027730:	687b      	ldr	r3, [r7, #4]
 8027732:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8027736:	461a      	mov	r2, r3
 8027738:	f7fc f928 	bl	802398c <XMC_GPIO_Init>
 802773c:	e004      	b.n	8027748 <CAN_NODE_Init+0x130>
      }
    }
    else
    {
      status = CAN_NODE_STATUS_FAILURE;
 802773e:	2301      	movs	r3, #1
 8027740:	75fb      	strb	r3, [r7, #23]
 8027742:	e001      	b.n	8027748 <CAN_NODE_Init+0x130>
    }
  }
  else
  {
    status = CAN_NODE_STATUS_FAILURE;
 8027744:	2301      	movs	r3, #1
 8027746:	75fb      	strb	r3, [r7, #23]
  }

  return (status);
 8027748:	7dfb      	ldrb	r3, [r7, #23]
}
 802774a:	4618      	mov	r0, r3
 802774c:	3718      	adds	r7, #24
 802774e:	46bd      	mov	sp, r7
 8027750:	bd80      	pop	{r7, pc}

08027752 <BUS_IO_Init>:
* @param handle_ptr Pointer pointing to APP data structure.
* @return BUS_IO_STATUS_t BUS_IO APP status.
*/

BUS_IO_STATUS_t BUS_IO_Init(BUS_IO_t *const handle_ptr)
{
 8027752:	b580      	push	{r7, lr}
 8027754:	b084      	sub	sp, #16
 8027756:	af00      	add	r7, sp, #0
 8027758:	6078      	str	r0, [r7, #4]
  uint8_t i;

  XMC_ASSERT("BUS_IO_Init: handle_ptr null pointer", handle_ptr != NULL);

  if ((bool)false == handle_ptr->initialized)
 802775a:	687b      	ldr	r3, [r7, #4]
 802775c:	7c5b      	ldrb	r3, [r3, #17]
 802775e:	f083 0301 	eor.w	r3, r3, #1
 8027762:	b2db      	uxtb	r3, r3
 8027764:	2b00      	cmp	r3, #0
 8027766:	d01e      	beq.n	80277a6 <BUS_IO_Init+0x54>
  {
    /* Iterate the list of pins initializing the pin according to the gpio_config */
    for (i = 0U; i < handle_ptr->number_of_pins; i++)
 8027768:	2300      	movs	r3, #0
 802776a:	73fb      	strb	r3, [r7, #15]
 802776c:	e013      	b.n	8027796 <BUS_IO_Init+0x44>
    {
      /* Initializes input / output characteristics */
      XMC_GPIO_Init(handle_ptr->pin_array[i].gpio_port, handle_ptr->pin_array[i].gpio_pin, &handle_ptr->gpio_config);
 802776e:	687b      	ldr	r3, [r7, #4]
 8027770:	681a      	ldr	r2, [r3, #0]
 8027772:	7bfb      	ldrb	r3, [r7, #15]
 8027774:	00db      	lsls	r3, r3, #3
 8027776:	4413      	add	r3, r2
 8027778:	6818      	ldr	r0, [r3, #0]
 802777a:	687b      	ldr	r3, [r7, #4]
 802777c:	681a      	ldr	r2, [r3, #0]
 802777e:	7bfb      	ldrb	r3, [r7, #15]
 8027780:	00db      	lsls	r3, r3, #3
 8027782:	4413      	add	r3, r2
 8027784:	7919      	ldrb	r1, [r3, #4]
 8027786:	687b      	ldr	r3, [r7, #4]
 8027788:	3304      	adds	r3, #4
 802778a:	461a      	mov	r2, r3
 802778c:	f7fc f8fe 	bl	802398c <XMC_GPIO_Init>
    for (i = 0U; i < handle_ptr->number_of_pins; i++)
 8027790:	7bfb      	ldrb	r3, [r7, #15]
 8027792:	3301      	adds	r3, #1
 8027794:	73fb      	strb	r3, [r7, #15]
 8027796:	687b      	ldr	r3, [r7, #4]
 8027798:	7c1b      	ldrb	r3, [r3, #16]
 802779a:	7bfa      	ldrb	r2, [r7, #15]
 802779c:	429a      	cmp	r2, r3
 802779e:	d3e6      	bcc.n	802776e <BUS_IO_Init+0x1c>
    }
    handle_ptr->initialized = (bool)true;
 80277a0:	687b      	ldr	r3, [r7, #4]
 80277a2:	2201      	movs	r2, #1
 80277a4:	745a      	strb	r2, [r3, #17]
  }
  return (BUS_IO_STATUS_OK);
 80277a6:	2300      	movs	r3, #0
}
 80277a8:	4618      	mov	r0, r3
 80277aa:	3710      	adds	r7, #16
 80277ac:	46bd      	mov	sp, r7
 80277ae:	bd80      	pop	{r7, pc}

080277b0 <ANALOG_IO_Init>:
 * Input Parameter  : Handler Pointer pointing to APP data structure.
 * Output Parameter : ANALOG_IO_STATUS_t (ANALOG_IO APP initialization status).
 */

ANALOG_IO_STATUS_t ANALOG_IO_Init(const ANALOG_IO_t *const handle)
{
 80277b0:	b580      	push	{r7, lr}
 80277b2:	b082      	sub	sp, #8
 80277b4:	af00      	add	r7, sp, #0
 80277b6:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("ANALOG_IO_Init: Passed handler is a null pointer", handler != NULL);
  if (*(handle->state) == ANALOG_IO_STATE_NOT_INITIALIZED)
 80277b8:	687b      	ldr	r3, [r7, #4]
 80277ba:	685b      	ldr	r3, [r3, #4]
 80277bc:	781b      	ldrb	r3, [r3, #0]
 80277be:	2b00      	cmp	r3, #0
 80277c0:	d10a      	bne.n	80277d8 <ANALOG_IO_Init+0x28>
  {
    if (handle->config_ptr != NULL)
 80277c2:	687b      	ldr	r3, [r7, #4]
 80277c4:	681b      	ldr	r3, [r3, #0]
 80277c6:	2b00      	cmp	r3, #0
 80277c8:	d002      	beq.n	80277d0 <ANALOG_IO_Init+0x20>
    {
      /* Instance specific initialization function call*/
      handle->config_ptr();
 80277ca:	687b      	ldr	r3, [r7, #4]
 80277cc:	681b      	ldr	r3, [r3, #0]
 80277ce:	4798      	blx	r3
    }
    /* Set the state variable to initialized state*/
    *(handle->state) = ANALOG_IO_STATE_INITIALIZED;
 80277d0:	687b      	ldr	r3, [r7, #4]
 80277d2:	685b      	ldr	r3, [r3, #4]
 80277d4:	2201      	movs	r2, #1
 80277d6:	701a      	strb	r2, [r3, #0]
  }
  return (ANALOG_IO_STATUS_OK);
 80277d8:	2300      	movs	r3, #0
}
 80277da:	4618      	mov	r0, r3
 80277dc:	3708      	adds	r7, #8
 80277de:	46bd      	mov	sp, r7
 80277e0:	bd80      	pop	{r7, pc}
	...

080277e4 <__NVIC_GetPriorityGrouping>:
{
 80277e4:	b480      	push	{r7}
 80277e6:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80277e8:	4b04      	ldr	r3, [pc, #16]	; (80277fc <__NVIC_GetPriorityGrouping+0x18>)
 80277ea:	68db      	ldr	r3, [r3, #12]
 80277ec:	0a1b      	lsrs	r3, r3, #8
 80277ee:	f003 0307 	and.w	r3, r3, #7
}
 80277f2:	4618      	mov	r0, r3
 80277f4:	46bd      	mov	sp, r7
 80277f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80277fa:	4770      	bx	lr
 80277fc:	e000ed00 	.word	0xe000ed00

08027800 <__NVIC_EnableIRQ>:
{
 8027800:	b480      	push	{r7}
 8027802:	b083      	sub	sp, #12
 8027804:	af00      	add	r7, sp, #0
 8027806:	4603      	mov	r3, r0
 8027808:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 802780a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802780e:	2b00      	cmp	r3, #0
 8027810:	db0b      	blt.n	802782a <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8027812:	79fb      	ldrb	r3, [r7, #7]
 8027814:	f003 021f 	and.w	r2, r3, #31
 8027818:	4907      	ldr	r1, [pc, #28]	; (8027838 <__NVIC_EnableIRQ+0x38>)
 802781a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802781e:	095b      	lsrs	r3, r3, #5
 8027820:	2001      	movs	r0, #1
 8027822:	fa00 f202 	lsl.w	r2, r0, r2
 8027826:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 802782a:	bf00      	nop
 802782c:	370c      	adds	r7, #12
 802782e:	46bd      	mov	sp, r7
 8027830:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027834:	4770      	bx	lr
 8027836:	bf00      	nop
 8027838:	e000e100 	.word	0xe000e100

0802783c <__NVIC_SetPriority>:
{
 802783c:	b480      	push	{r7}
 802783e:	b083      	sub	sp, #12
 8027840:	af00      	add	r7, sp, #0
 8027842:	4603      	mov	r3, r0
 8027844:	6039      	str	r1, [r7, #0]
 8027846:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8027848:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802784c:	2b00      	cmp	r3, #0
 802784e:	db0a      	blt.n	8027866 <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8027850:	683b      	ldr	r3, [r7, #0]
 8027852:	b2da      	uxtb	r2, r3
 8027854:	490c      	ldr	r1, [pc, #48]	; (8027888 <__NVIC_SetPriority+0x4c>)
 8027856:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802785a:	0092      	lsls	r2, r2, #2
 802785c:	b2d2      	uxtb	r2, r2
 802785e:	440b      	add	r3, r1
 8027860:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 8027864:	e00a      	b.n	802787c <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8027866:	683b      	ldr	r3, [r7, #0]
 8027868:	b2da      	uxtb	r2, r3
 802786a:	4908      	ldr	r1, [pc, #32]	; (802788c <__NVIC_SetPriority+0x50>)
 802786c:	79fb      	ldrb	r3, [r7, #7]
 802786e:	f003 030f 	and.w	r3, r3, #15
 8027872:	3b04      	subs	r3, #4
 8027874:	0092      	lsls	r2, r2, #2
 8027876:	b2d2      	uxtb	r2, r2
 8027878:	440b      	add	r3, r1
 802787a:	761a      	strb	r2, [r3, #24]
}
 802787c:	bf00      	nop
 802787e:	370c      	adds	r7, #12
 8027880:	46bd      	mov	sp, r7
 8027882:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027886:	4770      	bx	lr
 8027888:	e000e100 	.word	0xe000e100
 802788c:	e000ed00 	.word	0xe000ed00

08027890 <NVIC_EncodePriority>:
{
 8027890:	b480      	push	{r7}
 8027892:	b089      	sub	sp, #36	; 0x24
 8027894:	af00      	add	r7, sp, #0
 8027896:	60f8      	str	r0, [r7, #12]
 8027898:	60b9      	str	r1, [r7, #8]
 802789a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 802789c:	68fb      	ldr	r3, [r7, #12]
 802789e:	f003 0307 	and.w	r3, r3, #7
 80278a2:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80278a4:	69fb      	ldr	r3, [r7, #28]
 80278a6:	f1c3 0307 	rsb	r3, r3, #7
 80278aa:	2b06      	cmp	r3, #6
 80278ac:	bf28      	it	cs
 80278ae:	2306      	movcs	r3, #6
 80278b0:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80278b2:	69fb      	ldr	r3, [r7, #28]
 80278b4:	3306      	adds	r3, #6
 80278b6:	2b06      	cmp	r3, #6
 80278b8:	d902      	bls.n	80278c0 <NVIC_EncodePriority+0x30>
 80278ba:	69fb      	ldr	r3, [r7, #28]
 80278bc:	3b01      	subs	r3, #1
 80278be:	e000      	b.n	80278c2 <NVIC_EncodePriority+0x32>
 80278c0:	2300      	movs	r3, #0
 80278c2:	617b      	str	r3, [r7, #20]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80278c4:	f04f 32ff 	mov.w	r2, #4294967295
 80278c8:	69bb      	ldr	r3, [r7, #24]
 80278ca:	fa02 f303 	lsl.w	r3, r2, r3
 80278ce:	43da      	mvns	r2, r3
 80278d0:	68bb      	ldr	r3, [r7, #8]
 80278d2:	401a      	ands	r2, r3
 80278d4:	697b      	ldr	r3, [r7, #20]
 80278d6:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80278d8:	f04f 31ff 	mov.w	r1, #4294967295
 80278dc:	697b      	ldr	r3, [r7, #20]
 80278de:	fa01 f303 	lsl.w	r3, r1, r3
 80278e2:	43d9      	mvns	r1, r3
 80278e4:	687b      	ldr	r3, [r7, #4]
 80278e6:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80278e8:	4313      	orrs	r3, r2
}
 80278ea:	4618      	mov	r0, r3
 80278ec:	3724      	adds	r7, #36	; 0x24
 80278ee:	46bd      	mov	sp, r7
 80278f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80278f4:	4770      	bx	lr

080278f6 <XMC_VADC_GLOBAL_BackgroundTriggerConversion>:
{
 80278f6:	b480      	push	{r7}
 80278f8:	b083      	sub	sp, #12
 80278fa:	af00      	add	r7, sp, #0
 80278fc:	6078      	str	r0, [r7, #4]
  global_ptr->BRSMR |= (uint32_t)VADC_BRSMR_LDEV_Msk;
 80278fe:	687b      	ldr	r3, [r7, #4]
 8027900:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
 8027904:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 8027908:	687b      	ldr	r3, [r7, #4]
 802790a:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
}
 802790e:	bf00      	nop
 8027910:	370c      	adds	r7, #12
 8027912:	46bd      	mov	sp, r7
 8027914:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027918:	4770      	bx	lr

0802791a <XMC_VADC_GLOBAL_BackgroundAddChannelToSequence>:
{
 802791a:	b480      	push	{r7}
 802791c:	b085      	sub	sp, #20
 802791e:	af00      	add	r7, sp, #0
 8027920:	60f8      	str	r0, [r7, #12]
 8027922:	60b9      	str	r1, [r7, #8]
 8027924:	607a      	str	r2, [r7, #4]
  global_ptr->BRSSEL[grp_num] |= (uint32_t)((uint32_t)1 << ch_num);
 8027926:	68fb      	ldr	r3, [r7, #12]
 8027928:	68ba      	ldr	r2, [r7, #8]
 802792a:	3260      	adds	r2, #96	; 0x60
 802792c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8027930:	2101      	movs	r1, #1
 8027932:	687b      	ldr	r3, [r7, #4]
 8027934:	fa01 f303 	lsl.w	r3, r1, r3
 8027938:	ea42 0103 	orr.w	r1, r2, r3
 802793c:	68fb      	ldr	r3, [r7, #12]
 802793e:	68ba      	ldr	r2, [r7, #8]
 8027940:	3260      	adds	r2, #96	; 0x60
 8027942:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8027946:	bf00      	nop
 8027948:	3714      	adds	r7, #20
 802794a:	46bd      	mov	sp, r7
 802794c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027950:	4770      	bx	lr

08027952 <XMC_VADC_GROUP_ResultInit>:
{
 8027952:	b480      	push	{r7}
 8027954:	b085      	sub	sp, #20
 8027956:	af00      	add	r7, sp, #0
 8027958:	60f8      	str	r0, [r7, #12]
 802795a:	60b9      	str	r1, [r7, #8]
 802795c:	607a      	str	r2, [r7, #4]
  group_ptr->RCR[res_reg_num] = config->g_rcr;
 802795e:	687b      	ldr	r3, [r7, #4]
 8027960:	6819      	ldr	r1, [r3, #0]
 8027962:	68fb      	ldr	r3, [r7, #12]
 8027964:	68ba      	ldr	r2, [r7, #8]
 8027966:	32a0      	adds	r2, #160	; 0xa0
 8027968:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 802796c:	bf00      	nop
 802796e:	3714      	adds	r7, #20
 8027970:	46bd      	mov	sp, r7
 8027972:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027976:	4770      	bx	lr

08027978 <XMC_VADC_GROUP_GetResult>:
{
 8027978:	b480      	push	{r7}
 802797a:	b083      	sub	sp, #12
 802797c:	af00      	add	r7, sp, #0
 802797e:	6078      	str	r0, [r7, #4]
 8027980:	6039      	str	r1, [r7, #0]
  return ((XMC_VADC_RESULT_SIZE_t)group_ptr->RES[res_reg]);
 8027982:	687b      	ldr	r3, [r7, #4]
 8027984:	683a      	ldr	r2, [r7, #0]
 8027986:	32c0      	adds	r2, #192	; 0xc0
 8027988:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802798c:	b29b      	uxth	r3, r3
}
 802798e:	4618      	mov	r0, r3
 8027990:	370c      	adds	r7, #12
 8027992:	46bd      	mov	sp, r7
 8027994:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027998:	4770      	bx	lr

0802799a <ADC_MEASUREMENT_Init>:
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Initialization routine to call ADC LLD API's */
ADC_MEASUREMENT_STATUS_t ADC_MEASUREMENT_Init(ADC_MEASUREMENT_t *const handle_ptr)
{
 802799a:	b590      	push	{r4, r7, lr}
 802799c:	b085      	sub	sp, #20
 802799e:	af00      	add	r7, sp, #0
 80279a0:	6078      	str	r0, [r7, #4]
  uint8_t j;
  ADC_MEASUREMENT_STATUS_t status;

  XMC_ASSERT("ADC_MEASUREMENT_Init:Invalid handle_ptr", (handle_ptr != NULL));

  if (ADC_MEASUREMENT_STATUS_UNINITIALIZED == handle_ptr->init_state)
 80279a2:	687b      	ldr	r3, [r7, #4]
 80279a4:	7e1b      	ldrb	r3, [r3, #24]
 80279a6:	2b02      	cmp	r3, #2
 80279a8:	f040 809e 	bne.w	8027ae8 <ADC_MEASUREMENT_Init+0x14e>
  {
    /* Call the function to initialise Clock and ADC global functional units*/
    status = (ADC_MEASUREMENT_STATUS_t) GLOBAL_ADC_Init(handle_ptr->global_handle);
 80279ac:	687b      	ldr	r3, [r7, #4]
 80279ae:	68db      	ldr	r3, [r3, #12]
 80279b0:	4618      	mov	r0, r3
 80279b2:	f7ff fb79 	bl	80270a8 <GLOBAL_ADC_Init>
 80279b6:	4603      	mov	r3, r0
 80279b8:	73bb      	strb	r3, [r7, #14]
  
    /*Initialize the Global Conversion class 0*/
    XMC_VADC_GLOBAL_InputClassInit(handle_ptr->global_handle->module_ptr,*handle_ptr->iclass_config_handle,
 80279ba:	687b      	ldr	r3, [r7, #4]
 80279bc:	68db      	ldr	r3, [r3, #12]
 80279be:	6958      	ldr	r0, [r3, #20]
 80279c0:	687b      	ldr	r3, [r7, #4]
 80279c2:	6899      	ldr	r1, [r3, #8]
 80279c4:	2300      	movs	r3, #0
 80279c6:	2200      	movs	r2, #0
 80279c8:	6809      	ldr	r1, [r1, #0]
 80279ca:	f7fe f8af 	bl	8025b2c <XMC_VADC_GLOBAL_InputClassInit>
    XMC_VADC_GLOBAL_InputClassInit(handle_ptr->global_handle->module_ptr,*handle_ptr->iclass_config_handle,
                                      XMC_VADC_GROUP_CONV_STD,ADC_MEASUREMENT_ICLASS_NUM_XMC11);
#endif
  
    /* Initialize the Background Scan hardware */
    XMC_VADC_GLOBAL_BackgroundInit(handle_ptr->global_handle->module_ptr, handle_ptr->backgnd_config_handle);
 80279ce:	687b      	ldr	r3, [r7, #4]
 80279d0:	68db      	ldr	r3, [r3, #12]
 80279d2:	695a      	ldr	r2, [r3, #20]
 80279d4:	687b      	ldr	r3, [r7, #4]
 80279d6:	685b      	ldr	r3, [r3, #4]
 80279d8:	4619      	mov	r1, r3
 80279da:	4610      	mov	r0, r2
 80279dc:	f7fe f9fc 	bl	8025dd8 <XMC_VADC_GLOBAL_BackgroundInit>
#if (XMC_VADC_GROUP_AVAILABLE == 0U)
    /* Initialize the global result register */
    XMC_VADC_GLOBAL_ResultInit(handle_ptr->global_handle->module_ptr,handle_ptr->array->res_handle);
#endif

    for (j = (uint8_t)0; j < (uint8_t)ADC_MEASUREMENT_MAXCHANNELS; j++)
 80279e0:	2300      	movs	r3, #0
 80279e2:	73fb      	strb	r3, [r7, #15]
 80279e4:	e039      	b.n	8027a5a <ADC_MEASUREMENT_Init+0xc0>
    {
      indexed = handle_ptr->array->channel_array[j];
 80279e6:	687b      	ldr	r3, [r7, #4]
 80279e8:	681b      	ldr	r3, [r3, #0]
 80279ea:	7bfa      	ldrb	r2, [r7, #15]
 80279ec:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80279f0:	60bb      	str	r3, [r7, #8]
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
      /* Initialize for configured channels*/
      XMC_VADC_GROUP_ChannelInit(indexed->group_handle,(uint32_t)indexed->ch_num, indexed->ch_handle);
 80279f2:	68bb      	ldr	r3, [r7, #8]
 80279f4:	6898      	ldr	r0, [r3, #8]
 80279f6:	68bb      	ldr	r3, [r7, #8]
 80279f8:	7c5b      	ldrb	r3, [r3, #17]
 80279fa:	4619      	mov	r1, r3
 80279fc:	68bb      	ldr	r3, [r7, #8]
 80279fe:	681b      	ldr	r3, [r3, #0]
 8027a00:	461a      	mov	r2, r3
 8027a02:	f7fe fab7 	bl	8025f74 <XMC_VADC_GROUP_ChannelInit>
  
      /* Initialize for configured result registers */
      XMC_VADC_GROUP_ResultInit(indexed->group_handle, (uint32_t)indexed->ch_handle->result_reg_number,
 8027a06:	68bb      	ldr	r3, [r7, #8]
 8027a08:	6898      	ldr	r0, [r3, #8]
 8027a0a:	68bb      	ldr	r3, [r7, #8]
 8027a0c:	681b      	ldr	r3, [r3, #0]
 8027a0e:	789b      	ldrb	r3, [r3, #2]
 8027a10:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8027a14:	b2db      	uxtb	r3, r3
 8027a16:	4619      	mov	r1, r3
                                indexed->res_handle);
 8027a18:	68bb      	ldr	r3, [r7, #8]
 8027a1a:	685b      	ldr	r3, [r3, #4]
      XMC_VADC_GROUP_ResultInit(indexed->group_handle, (uint32_t)indexed->ch_handle->result_reg_number,
 8027a1c:	461a      	mov	r2, r3
 8027a1e:	f7ff ff98 	bl	8027952 <XMC_VADC_GROUP_ResultInit>
#endif
      /* Add all channels into the Background Request Source Channel Select Register */
      XMC_VADC_GLOBAL_BackgroundAddChannelToSequence(handle_ptr->global_handle->module_ptr,
 8027a22:	687b      	ldr	r3, [r7, #4]
 8027a24:	68db      	ldr	r3, [r3, #12]
 8027a26:	6958      	ldr	r0, [r3, #20]
                                                     (uint32_t)indexed->group_index, (uint32_t)indexed->ch_num);
 8027a28:	68bb      	ldr	r3, [r7, #8]
 8027a2a:	7c1b      	ldrb	r3, [r3, #16]
      XMC_VADC_GLOBAL_BackgroundAddChannelToSequence(handle_ptr->global_handle->module_ptr,
 8027a2c:	4619      	mov	r1, r3
                                                     (uint32_t)indexed->group_index, (uint32_t)indexed->ch_num);
 8027a2e:	68bb      	ldr	r3, [r7, #8]
 8027a30:	7c5b      	ldrb	r3, [r3, #17]
      XMC_VADC_GLOBAL_BackgroundAddChannelToSequence(handle_ptr->global_handle->module_ptr,
 8027a32:	461a      	mov	r2, r3
 8027a34:	f7ff ff71 	bl	802791a <XMC_VADC_GLOBAL_BackgroundAddChannelToSequence>

#ifdef ADC_MEASUREMENT_ANALOG_IO_USED
      /* ANALOG_IO initialization for the channel*/
      if(indexed->analog_io_config != NULL)
 8027a38:	68bb      	ldr	r3, [r7, #8]
 8027a3a:	68db      	ldr	r3, [r3, #12]
 8027a3c:	2b00      	cmp	r3, #0
 8027a3e:	d009      	beq.n	8027a54 <ADC_MEASUREMENT_Init+0xba>
      {
        status |= (ADC_MEASUREMENT_STATUS_t) ANALOG_IO_Init(indexed->analog_io_config);
 8027a40:	68bb      	ldr	r3, [r7, #8]
 8027a42:	68db      	ldr	r3, [r3, #12]
 8027a44:	4618      	mov	r0, r3
 8027a46:	f7ff feb3 	bl	80277b0 <ANALOG_IO_Init>
 8027a4a:	4603      	mov	r3, r0
 8027a4c:	461a      	mov	r2, r3
 8027a4e:	7bbb      	ldrb	r3, [r7, #14]
 8027a50:	4313      	orrs	r3, r2
 8027a52:	73bb      	strb	r3, [r7, #14]
    for (j = (uint8_t)0; j < (uint8_t)ADC_MEASUREMENT_MAXCHANNELS; j++)
 8027a54:	7bfb      	ldrb	r3, [r7, #15]
 8027a56:	3301      	adds	r3, #1
 8027a58:	73fb      	strb	r3, [r7, #15]
 8027a5a:	7bfb      	ldrb	r3, [r7, #15]
 8027a5c:	2b02      	cmp	r3, #2
 8027a5e:	d9c2      	bls.n	80279e6 <ADC_MEASUREMENT_Init+0x4c>
      }
#endif
    }
#if(UC_SERIES != XMC11)
    if ((handle_ptr->backgnd_config_handle->req_src_interrupt) && (handle_ptr->req_src_intr_handle != NULL ))
 8027a60:	687b      	ldr	r3, [r7, #4]
 8027a62:	685b      	ldr	r3, [r3, #4]
 8027a64:	7a1b      	ldrb	r3, [r3, #8]
 8027a66:	f003 0308 	and.w	r3, r3, #8
 8027a6a:	b2db      	uxtb	r3, r3
 8027a6c:	2b00      	cmp	r3, #0
 8027a6e:	d027      	beq.n	8027ac0 <ADC_MEASUREMENT_Init+0x126>
 8027a70:	687b      	ldr	r3, [r7, #4]
 8027a72:	691b      	ldr	r3, [r3, #16]
 8027a74:	2b00      	cmp	r3, #0
 8027a76:	d023      	beq.n	8027ac0 <ADC_MEASUREMENT_Init+0x126>
    {
#if (UC_FAMILY == XMC1)
      NVIC_SetPriority((IRQn_Type)handle_ptr->req_src_intr_handle->node_id,
                        handle_ptr->req_src_intr_handle->priority);
#else
      NVIC_SetPriority((IRQn_Type)handle_ptr->req_src_intr_handle->node_id,
 8027a78:	687b      	ldr	r3, [r7, #4]
 8027a7a:	691b      	ldr	r3, [r3, #16]
 8027a7c:	681b      	ldr	r3, [r3, #0]
 8027a7e:	b25c      	sxtb	r4, r3
 8027a80:	f7ff feb0 	bl	80277e4 <__NVIC_GetPriorityGrouping>
                        NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
                        handle_ptr->req_src_intr_handle->priority, handle_ptr->req_src_intr_handle->sub_priority));
 8027a84:	687b      	ldr	r3, [r7, #4]
 8027a86:	691b      	ldr	r3, [r3, #16]
      NVIC_SetPriority((IRQn_Type)handle_ptr->req_src_intr_handle->node_id,
 8027a88:	6859      	ldr	r1, [r3, #4]
                        handle_ptr->req_src_intr_handle->priority, handle_ptr->req_src_intr_handle->sub_priority));
 8027a8a:	687b      	ldr	r3, [r7, #4]
 8027a8c:	691b      	ldr	r3, [r3, #16]
      NVIC_SetPriority((IRQn_Type)handle_ptr->req_src_intr_handle->node_id,
 8027a8e:	689b      	ldr	r3, [r3, #8]
 8027a90:	461a      	mov	r2, r3
 8027a92:	f7ff fefd 	bl	8027890 <NVIC_EncodePriority>
 8027a96:	4603      	mov	r3, r0
 8027a98:	4619      	mov	r1, r3
 8027a9a:	4620      	mov	r0, r4
 8027a9c:	f7ff fece 	bl	802783c <__NVIC_SetPriority>
#endif
      /* Connect background Request Source Event to NVIC node */
      XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode(handle_ptr->global_handle->module_ptr,
 8027aa0:	687b      	ldr	r3, [r7, #4]
 8027aa2:	68db      	ldr	r3, [r3, #12]
 8027aa4:	695a      	ldr	r2, [r3, #20]
                                                 (XMC_VADC_SR_t) handle_ptr->srv_req_node);
 8027aa6:	687b      	ldr	r3, [r7, #4]
 8027aa8:	7e5b      	ldrb	r3, [r3, #25]
      XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode(handle_ptr->global_handle->module_ptr,
 8027aaa:	4619      	mov	r1, r3
 8027aac:	4610      	mov	r0, r2
 8027aae:	f7fe f897 	bl	8025be0 <XMC_VADC_GLOBAL_BackgroundSetReqSrcEventInterruptNode>
    
      /* Enable Background Scan Request source IRQ */
      NVIC_EnableIRQ((IRQn_Type)handle_ptr->req_src_intr_handle->node_id);
 8027ab2:	687b      	ldr	r3, [r7, #4]
 8027ab4:	691b      	ldr	r3, [r3, #16]
 8027ab6:	681b      	ldr	r3, [r3, #0]
 8027ab8:	b25b      	sxtb	r3, r3
 8027aba:	4618      	mov	r0, r3
 8027abc:	f7ff fea0 	bl	8027800 <__NVIC_EnableIRQ>
    /* Enable Background Scan Request source IRQ */
    NVIC_EnableIRQ((IRQn_Type)handle_ptr->result_intr_handle->node_id);
#endif
#endif
    /* Mux Configuration is done*/
    if (handle_ptr->mux_config != NULL)
 8027ac0:	687b      	ldr	r3, [r7, #4]
 8027ac2:	695b      	ldr	r3, [r3, #20]
 8027ac4:	2b00      	cmp	r3, #0
 8027ac6:	d002      	beq.n	8027ace <ADC_MEASUREMENT_Init+0x134>
    {
      (handle_ptr->mux_config)();
 8027ac8:	687b      	ldr	r3, [r7, #4]
 8027aca:	695b      	ldr	r3, [r3, #20]
 8027acc:	4798      	blx	r3
    }
  
    if (handle_ptr->start_conversion != (bool)false)
 8027ace:	687b      	ldr	r3, [r7, #4]
 8027ad0:	7e9b      	ldrb	r3, [r3, #26]
 8027ad2:	2b00      	cmp	r3, #0
 8027ad4:	d005      	beq.n	8027ae2 <ADC_MEASUREMENT_Init+0x148>
    {
      /* Start conversion manually using load event trigger*/
      XMC_VADC_GLOBAL_BackgroundTriggerConversion(handle_ptr->global_handle->module_ptr);
 8027ad6:	687b      	ldr	r3, [r7, #4]
 8027ad8:	68db      	ldr	r3, [r3, #12]
 8027ada:	695b      	ldr	r3, [r3, #20]
 8027adc:	4618      	mov	r0, r3
 8027ade:	f7ff ff0a 	bl	80278f6 <XMC_VADC_GLOBAL_BackgroundTriggerConversion>
    }
    handle_ptr->init_state = status;
 8027ae2:	687b      	ldr	r3, [r7, #4]
 8027ae4:	7bba      	ldrb	r2, [r7, #14]
 8027ae6:	761a      	strb	r2, [r3, #24]
  }
  return (handle_ptr->init_state);
 8027ae8:	687b      	ldr	r3, [r7, #4]
 8027aea:	7e1b      	ldrb	r3, [r3, #24]
}
 8027aec:	4618      	mov	r0, r3
 8027aee:	3714      	adds	r7, #20
 8027af0:	46bd      	mov	sp, r7
 8027af2:	bd90      	pop	{r4, r7, pc}

08027af4 <ADC_MEASUREMENT_GetResult>:
}
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
#if(XMC_VADC_GROUP_AVAILABLE == 1U)
/* This API will get the result of a conversion for a specific channel*/
XMC_VADC_RESULT_SIZE_t ADC_MEASUREMENT_GetResult(ADC_MEASUREMENT_CHANNEL_t *const handle_ptr)
{
 8027af4:	b580      	push	{r7, lr}
 8027af6:	b084      	sub	sp, #16
 8027af8:	af00      	add	r7, sp, #0
 8027afa:	6078      	str	r0, [r7, #4]
  XMC_VADC_RESULT_SIZE_t result;

  XMC_ASSERT("ADC_MEASUREMENT_GetResult:Invalid handle_ptr", (handle_ptr != NULL));

  result = XMC_VADC_GROUP_GetResult(handle_ptr->group_handle, handle_ptr->ch_handle->result_reg_number);
 8027afc:	687b      	ldr	r3, [r7, #4]
 8027afe:	689a      	ldr	r2, [r3, #8]
 8027b00:	687b      	ldr	r3, [r7, #4]
 8027b02:	681b      	ldr	r3, [r3, #0]
 8027b04:	789b      	ldrb	r3, [r3, #2]
 8027b06:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8027b0a:	b2db      	uxtb	r3, r3
 8027b0c:	4619      	mov	r1, r3
 8027b0e:	4610      	mov	r0, r2
 8027b10:	f7ff ff32 	bl	8027978 <XMC_VADC_GROUP_GetResult>
 8027b14:	4603      	mov	r3, r0
 8027b16:	81fb      	strh	r3, [r7, #14]

  return (result);
 8027b18:	89fb      	ldrh	r3, [r7, #14]
}
 8027b1a:	4618      	mov	r0, r3
 8027b1c:	3710      	adds	r7, #16
 8027b1e:	46bd      	mov	sp, r7
 8027b20:	bd80      	pop	{r7, pc}
	...

08027b24 <DAVE_Init>:
 * @param[in]  None
 *
 * @return  DAVE_STATUS_t <BR>
 ******************************************************************************/
__WEAK DAVE_STATUS_t DAVE_Init(void)
{
 8027b24:	b580      	push	{r7, lr}
 8027b26:	b082      	sub	sp, #8
 8027b28:	af00      	add	r7, sp, #0
  DAVE_STATUS_t init_status;
  
  init_status = DAVE_STATUS_SUCCESS;
 8027b2a:	2300      	movs	r3, #0
 8027b2c:	71fb      	strb	r3, [r7, #7]
     /** @Initialization of APPs Init Functions */
     init_status = (DAVE_STATUS_t)CLOCK_XMC4_Init(&CLOCK_XMC4_0);
 8027b2e:	48aa      	ldr	r0, [pc, #680]	; (8027dd8 <DAVE_Init+0x2b4>)
 8027b30:	f7ff fba4 	bl	802727c <CLOCK_XMC4_Init>
 8027b34:	4603      	mov	r3, r0
 8027b36:	71fb      	strb	r3, [r7, #7]

  if (init_status == DAVE_STATUS_SUCCESS)
 8027b38:	79fb      	ldrb	r3, [r7, #7]
 8027b3a:	2b00      	cmp	r3, #0
 8027b3c:	d104      	bne.n	8027b48 <DAVE_Init+0x24>
  {
	 /**  Initialization of DIGITAL_IO APP instance SERVICE_BUT */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&SERVICE_BUT); 
 8027b3e:	48a7      	ldr	r0, [pc, #668]	; (8027ddc <DAVE_Init+0x2b8>)
 8027b40:	f7ff fb09 	bl	8027156 <DIGITAL_IO_Init>
 8027b44:	4603      	mov	r3, r0
 8027b46:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027b48:	79fb      	ldrb	r3, [r7, #7]
 8027b4a:	2b00      	cmp	r3, #0
 8027b4c:	d104      	bne.n	8027b58 <DAVE_Init+0x34>
  {
	 /**  Initialization of DIGITAL_IO APP instance STATUS_LED_G */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&STATUS_LED_G); 
 8027b4e:	48a4      	ldr	r0, [pc, #656]	; (8027de0 <DAVE_Init+0x2bc>)
 8027b50:	f7ff fb01 	bl	8027156 <DIGITAL_IO_Init>
 8027b54:	4603      	mov	r3, r0
 8027b56:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027b58:	79fb      	ldrb	r3, [r7, #7]
 8027b5a:	2b00      	cmp	r3, #0
 8027b5c:	d104      	bne.n	8027b68 <DAVE_Init+0x44>
  {
	 /**  Initialization of DIGITAL_IO APP instance STATUS_LED_Y */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&STATUS_LED_Y); 
 8027b5e:	48a1      	ldr	r0, [pc, #644]	; (8027de4 <DAVE_Init+0x2c0>)
 8027b60:	f7ff faf9 	bl	8027156 <DIGITAL_IO_Init>
 8027b64:	4603      	mov	r3, r0
 8027b66:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027b68:	79fb      	ldrb	r3, [r7, #7]
 8027b6a:	2b00      	cmp	r3, #0
 8027b6c:	d104      	bne.n	8027b78 <DAVE_Init+0x54>
  {
	 /**  Initialization of DIGITAL_IO APP instance STATUS_LED_R */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&STATUS_LED_R); 
 8027b6e:	489e      	ldr	r0, [pc, #632]	; (8027de8 <DAVE_Init+0x2c4>)
 8027b70:	f7ff faf1 	bl	8027156 <DIGITAL_IO_Init>
 8027b74:	4603      	mov	r3, r0
 8027b76:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027b78:	79fb      	ldrb	r3, [r7, #7]
 8027b7a:	2b00      	cmp	r3, #0
 8027b7c:	d104      	bne.n	8027b88 <DAVE_Init+0x64>
  {
	 /**  Initialization of SYSTIMER APP instance SYSTIMER_0 */
	 init_status = (DAVE_STATUS_t)SYSTIMER_Init(&SYSTIMER_0); 
 8027b7e:	489b      	ldr	r0, [pc, #620]	; (8027dec <DAVE_Init+0x2c8>)
 8027b80:	f7fe fcf6 	bl	8026570 <SYSTIMER_Init>
 8027b84:	4603      	mov	r3, r0
 8027b86:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027b88:	79fb      	ldrb	r3, [r7, #7]
 8027b8a:	2b00      	cmp	r3, #0
 8027b8c:	d104      	bne.n	8027b98 <DAVE_Init+0x74>
  {
	 /**  Initialization of CAN_NODE APP instance CAN_INT */
	 init_status = (DAVE_STATUS_t)CAN_NODE_Init(&CAN_INT); 
 8027b8e:	4898      	ldr	r0, [pc, #608]	; (8027df0 <DAVE_Init+0x2cc>)
 8027b90:	f7ff fd42 	bl	8027618 <CAN_NODE_Init>
 8027b94:	4603      	mov	r3, r0
 8027b96:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027b98:	79fb      	ldrb	r3, [r7, #7]
 8027b9a:	2b00      	cmp	r3, #0
 8027b9c:	d104      	bne.n	8027ba8 <DAVE_Init+0x84>
  {
	 /**  Initialization of INTERRUPT APP instance CAN_INT_RESET_INT */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CAN_INT_RESET_INT); 
 8027b9e:	4895      	ldr	r0, [pc, #596]	; (8027df4 <DAVE_Init+0x2d0>)
 8027ba0:	f7ff f9fb 	bl	8026f9a <INTERRUPT_Init>
 8027ba4:	4603      	mov	r3, r0
 8027ba6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027ba8:	79fb      	ldrb	r3, [r7, #7]
 8027baa:	2b00      	cmp	r3, #0
 8027bac:	d104      	bne.n	8027bb8 <DAVE_Init+0x94>
  {
	 /**  Initialization of ADC_MEASUREMENT APP instance ADC_MEASUREMENT_0 */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_Init(&ADC_MEASUREMENT_0); 
 8027bae:	4892      	ldr	r0, [pc, #584]	; (8027df8 <DAVE_Init+0x2d4>)
 8027bb0:	f7ff fef3 	bl	802799a <ADC_MEASUREMENT_Init>
 8027bb4:	4603      	mov	r3, r0
 8027bb6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027bb8:	79fb      	ldrb	r3, [r7, #7]
 8027bba:	2b00      	cmp	r3, #0
 8027bbc:	d104      	bne.n	8027bc8 <DAVE_Init+0xa4>
  {
	 /**  Initialization of PWM_CCU4 APP instance BUZZ_PWM */
	 init_status = (DAVE_STATUS_t)PWM_CCU4_Init(&BUZZ_PWM); 
 8027bbe:	488f      	ldr	r0, [pc, #572]	; (8027dfc <DAVE_Init+0x2d8>)
 8027bc0:	f7fe fe89 	bl	80268d6 <PWM_CCU4_Init>
 8027bc4:	4603      	mov	r3, r0
 8027bc6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027bc8:	79fb      	ldrb	r3, [r7, #7]
 8027bca:	2b00      	cmp	r3, #0
 8027bcc:	d104      	bne.n	8027bd8 <DAVE_Init+0xb4>
  {
	 /**  Initialization of PWM_CCU4 APP instance CLUTCH_PWM */
	 init_status = (DAVE_STATUS_t)PWM_CCU4_Init(&CLUTCH_PWM); 
 8027bce:	488c      	ldr	r0, [pc, #560]	; (8027e00 <DAVE_Init+0x2dc>)
 8027bd0:	f7fe fe81 	bl	80268d6 <PWM_CCU4_Init>
 8027bd4:	4603      	mov	r3, r0
 8027bd6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027bd8:	79fb      	ldrb	r3, [r7, #7]
 8027bda:	2b00      	cmp	r3, #0
 8027bdc:	d104      	bne.n	8027be8 <DAVE_Init+0xc4>
  {
	 /**  Initialization of INTERRUPT APP instance BUZZ_INT_CMP */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&BUZZ_INT_CMP); 
 8027bde:	4889      	ldr	r0, [pc, #548]	; (8027e04 <DAVE_Init+0x2e0>)
 8027be0:	f7ff f9db 	bl	8026f9a <INTERRUPT_Init>
 8027be4:	4603      	mov	r3, r0
 8027be6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027be8:	79fb      	ldrb	r3, [r7, #7]
 8027bea:	2b00      	cmp	r3, #0
 8027bec:	d104      	bne.n	8027bf8 <DAVE_Init+0xd4>
  {
	 /**  Initialization of INTERRUPT APP instance BUZZ_INT_OVF */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&BUZZ_INT_OVF); 
 8027bee:	4886      	ldr	r0, [pc, #536]	; (8027e08 <DAVE_Init+0x2e4>)
 8027bf0:	f7ff f9d3 	bl	8026f9a <INTERRUPT_Init>
 8027bf4:	4603      	mov	r3, r0
 8027bf6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027bf8:	79fb      	ldrb	r3, [r7, #7]
 8027bfa:	2b00      	cmp	r3, #0
 8027bfc:	d104      	bne.n	8027c08 <DAVE_Init+0xe4>
  {
	 /**  Initialization of INTERRUPT APP instance CLUTCH_INT_CMP */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CLUTCH_INT_CMP); 
 8027bfe:	4883      	ldr	r0, [pc, #524]	; (8027e0c <DAVE_Init+0x2e8>)
 8027c00:	f7ff f9cb 	bl	8026f9a <INTERRUPT_Init>
 8027c04:	4603      	mov	r3, r0
 8027c06:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027c08:	79fb      	ldrb	r3, [r7, #7]
 8027c0a:	2b00      	cmp	r3, #0
 8027c0c:	d104      	bne.n	8027c18 <DAVE_Init+0xf4>
  {
	 /**  Initialization of INTERRUPT APP instance CLUTCH_INT_OVF */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CLUTCH_INT_OVF); 
 8027c0e:	4880      	ldr	r0, [pc, #512]	; (8027e10 <DAVE_Init+0x2ec>)
 8027c10:	f7ff f9c3 	bl	8026f9a <INTERRUPT_Init>
 8027c14:	4603      	mov	r3, r0
 8027c16:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027c18:	79fb      	ldrb	r3, [r7, #7]
 8027c1a:	2b00      	cmp	r3, #0
 8027c1c:	d104      	bne.n	8027c28 <DAVE_Init+0x104>
  {
	 /**  Initialization of INTERRUPT APP instance CAN_EXT_DSC1_INT */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CAN_EXT_DSC1_INT); 
 8027c1e:	487d      	ldr	r0, [pc, #500]	; (8027e14 <DAVE_Init+0x2f0>)
 8027c20:	f7ff f9bb 	bl	8026f9a <INTERRUPT_Init>
 8027c24:	4603      	mov	r3, r0
 8027c26:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027c28:	79fb      	ldrb	r3, [r7, #7]
 8027c2a:	2b00      	cmp	r3, #0
 8027c2c:	d104      	bne.n	8027c38 <DAVE_Init+0x114>
  {
	 /**  Initialization of INTERRUPT APP instance CAN_EXT_DSC3_INT */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CAN_EXT_DSC3_INT); 
 8027c2e:	487a      	ldr	r0, [pc, #488]	; (8027e18 <DAVE_Init+0x2f4>)
 8027c30:	f7ff f9b3 	bl	8026f9a <INTERRUPT_Init>
 8027c34:	4603      	mov	r3, r0
 8027c36:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027c38:	79fb      	ldrb	r3, [r7, #7]
 8027c3a:	2b00      	cmp	r3, #0
 8027c3c:	d104      	bne.n	8027c48 <DAVE_Init+0x124>
  {
	 /**  Initialization of INTERRUPT APP instance CAN_EXT_DSC2_INT */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CAN_EXT_DSC2_INT); 
 8027c3e:	4877      	ldr	r0, [pc, #476]	; (8027e1c <DAVE_Init+0x2f8>)
 8027c40:	f7ff f9ab 	bl	8026f9a <INTERRUPT_Init>
 8027c44:	4603      	mov	r3, r0
 8027c46:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027c48:	79fb      	ldrb	r3, [r7, #7]
 8027c4a:	2b00      	cmp	r3, #0
 8027c4c:	d104      	bne.n	8027c58 <DAVE_Init+0x134>
  {
	 /**  Initialization of CAN_NODE APP instance CAN_EXT */
	 init_status = (DAVE_STATUS_t)CAN_NODE_Init(&CAN_EXT); 
 8027c4e:	4874      	ldr	r0, [pc, #464]	; (8027e20 <DAVE_Init+0x2fc>)
 8027c50:	f7ff fce2 	bl	8027618 <CAN_NODE_Init>
 8027c54:	4603      	mov	r3, r0
 8027c56:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027c58:	79fb      	ldrb	r3, [r7, #7]
 8027c5a:	2b00      	cmp	r3, #0
 8027c5c:	d104      	bne.n	8027c68 <DAVE_Init+0x144>
  {
	 /**  Initialization of INTERRUPT APP instance CAN_NODE_ALLERT */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CAN_NODE_ALLERT); 
 8027c5e:	4871      	ldr	r0, [pc, #452]	; (8027e24 <DAVE_Init+0x300>)
 8027c60:	f7ff f99b 	bl	8026f9a <INTERRUPT_Init>
 8027c64:	4603      	mov	r3, r0
 8027c66:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027c68:	79fb      	ldrb	r3, [r7, #7]
 8027c6a:	2b00      	cmp	r3, #0
 8027c6c:	d104      	bne.n	8027c78 <DAVE_Init+0x154>
  {
	 /**  Initialization of BUS_IO APP instance DI_NPN */
	 init_status = (DAVE_STATUS_t)BUS_IO_Init(&DI_NPN); 
 8027c6e:	486e      	ldr	r0, [pc, #440]	; (8027e28 <DAVE_Init+0x304>)
 8027c70:	f7ff fd6f 	bl	8027752 <BUS_IO_Init>
 8027c74:	4603      	mov	r3, r0
 8027c76:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027c78:	79fb      	ldrb	r3, [r7, #7]
 8027c7a:	2b00      	cmp	r3, #0
 8027c7c:	d104      	bne.n	8027c88 <DAVE_Init+0x164>
  {
	 /**  Initialization of BUS_IO APP instance DI_PNP */
	 init_status = (DAVE_STATUS_t)BUS_IO_Init(&DI_PNP); 
 8027c7e:	486b      	ldr	r0, [pc, #428]	; (8027e2c <DAVE_Init+0x308>)
 8027c80:	f7ff fd67 	bl	8027752 <BUS_IO_Init>
 8027c84:	4603      	mov	r3, r0
 8027c86:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027c88:	79fb      	ldrb	r3, [r7, #7]
 8027c8a:	2b00      	cmp	r3, #0
 8027c8c:	d104      	bne.n	8027c98 <DAVE_Init+0x174>
  {
	 /**  Initialization of BUS_IO APP instance GROUP_IN */
	 init_status = (DAVE_STATUS_t)BUS_IO_Init(&GROUP_IN); 
 8027c8e:	4868      	ldr	r0, [pc, #416]	; (8027e30 <DAVE_Init+0x30c>)
 8027c90:	f7ff fd5f 	bl	8027752 <BUS_IO_Init>
 8027c94:	4603      	mov	r3, r0
 8027c96:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027c98:	79fb      	ldrb	r3, [r7, #7]
 8027c9a:	2b00      	cmp	r3, #0
 8027c9c:	d104      	bne.n	8027ca8 <DAVE_Init+0x184>
  {
	 /**  Initialization of BUS_IO APP instance GROUP_OUT */
	 init_status = (DAVE_STATUS_t)BUS_IO_Init(&GROUP_OUT); 
 8027c9e:	4865      	ldr	r0, [pc, #404]	; (8027e34 <DAVE_Init+0x310>)
 8027ca0:	f7ff fd57 	bl	8027752 <BUS_IO_Init>
 8027ca4:	4603      	mov	r3, r0
 8027ca6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027ca8:	79fb      	ldrb	r3, [r7, #7]
 8027caa:	2b00      	cmp	r3, #0
 8027cac:	d104      	bne.n	8027cb8 <DAVE_Init+0x194>
  {
	 /**  Initialization of DIGITAL_IO APP instance DI_NPN_EN */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DI_NPN_EN); 
 8027cae:	4862      	ldr	r0, [pc, #392]	; (8027e38 <DAVE_Init+0x314>)
 8027cb0:	f7ff fa51 	bl	8027156 <DIGITAL_IO_Init>
 8027cb4:	4603      	mov	r3, r0
 8027cb6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027cb8:	79fb      	ldrb	r3, [r7, #7]
 8027cba:	2b00      	cmp	r3, #0
 8027cbc:	d104      	bne.n	8027cc8 <DAVE_Init+0x1a4>
  {
	 /**  Initialization of DIGITAL_IO APP instance DI_PNP_EN */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DI_PNP_EN); 
 8027cbe:	485f      	ldr	r0, [pc, #380]	; (8027e3c <DAVE_Init+0x318>)
 8027cc0:	f7ff fa49 	bl	8027156 <DIGITAL_IO_Init>
 8027cc4:	4603      	mov	r3, r0
 8027cc6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027cc8:	79fb      	ldrb	r3, [r7, #7]
 8027cca:	2b00      	cmp	r3, #0
 8027ccc:	d104      	bne.n	8027cd8 <DAVE_Init+0x1b4>
  {
	 /**  Initialization of DIGITAL_IO APP instance GROUP_IN_EN */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&GROUP_IN_EN); 
 8027cce:	485c      	ldr	r0, [pc, #368]	; (8027e40 <DAVE_Init+0x31c>)
 8027cd0:	f7ff fa41 	bl	8027156 <DIGITAL_IO_Init>
 8027cd4:	4603      	mov	r3, r0
 8027cd6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027cd8:	79fb      	ldrb	r3, [r7, #7]
 8027cda:	2b00      	cmp	r3, #0
 8027cdc:	d104      	bne.n	8027ce8 <DAVE_Init+0x1c4>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_1 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_1); 
 8027cde:	4859      	ldr	r0, [pc, #356]	; (8027e44 <DAVE_Init+0x320>)
 8027ce0:	f7ff fa39 	bl	8027156 <DIGITAL_IO_Init>
 8027ce4:	4603      	mov	r3, r0
 8027ce6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027ce8:	79fb      	ldrb	r3, [r7, #7]
 8027cea:	2b00      	cmp	r3, #0
 8027cec:	d104      	bne.n	8027cf8 <DAVE_Init+0x1d4>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_2 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_2); 
 8027cee:	4856      	ldr	r0, [pc, #344]	; (8027e48 <DAVE_Init+0x324>)
 8027cf0:	f7ff fa31 	bl	8027156 <DIGITAL_IO_Init>
 8027cf4:	4603      	mov	r3, r0
 8027cf6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027cf8:	79fb      	ldrb	r3, [r7, #7]
 8027cfa:	2b00      	cmp	r3, #0
 8027cfc:	d104      	bne.n	8027d08 <DAVE_Init+0x1e4>
  {
	 /**  Initialization of DIGITAL_IO APP instance LS_SW_4 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LS_SW_4); 
 8027cfe:	4853      	ldr	r0, [pc, #332]	; (8027e4c <DAVE_Init+0x328>)
 8027d00:	f7ff fa29 	bl	8027156 <DIGITAL_IO_Init>
 8027d04:	4603      	mov	r3, r0
 8027d06:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027d08:	79fb      	ldrb	r3, [r7, #7]
 8027d0a:	2b00      	cmp	r3, #0
 8027d0c:	d104      	bne.n	8027d18 <DAVE_Init+0x1f4>
  {
	 /**  Initialization of DIGITAL_IO APP instance LS_SW_3 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LS_SW_3); 
 8027d0e:	4850      	ldr	r0, [pc, #320]	; (8027e50 <DAVE_Init+0x32c>)
 8027d10:	f7ff fa21 	bl	8027156 <DIGITAL_IO_Init>
 8027d14:	4603      	mov	r3, r0
 8027d16:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027d18:	79fb      	ldrb	r3, [r7, #7]
 8027d1a:	2b00      	cmp	r3, #0
 8027d1c:	d104      	bne.n	8027d28 <DAVE_Init+0x204>
  {
	 /**  Initialization of DIGITAL_IO APP instance LS_SW_2 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LS_SW_2); 
 8027d1e:	484d      	ldr	r0, [pc, #308]	; (8027e54 <DAVE_Init+0x330>)
 8027d20:	f7ff fa19 	bl	8027156 <DIGITAL_IO_Init>
 8027d24:	4603      	mov	r3, r0
 8027d26:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027d28:	79fb      	ldrb	r3, [r7, #7]
 8027d2a:	2b00      	cmp	r3, #0
 8027d2c:	d104      	bne.n	8027d38 <DAVE_Init+0x214>
  {
	 /**  Initialization of DIGITAL_IO APP instance LS_SW_1 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LS_SW_1); 
 8027d2e:	484a      	ldr	r0, [pc, #296]	; (8027e58 <DAVE_Init+0x334>)
 8027d30:	f7ff fa11 	bl	8027156 <DIGITAL_IO_Init>
 8027d34:	4603      	mov	r3, r0
 8027d36:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027d38:	79fb      	ldrb	r3, [r7, #7]
 8027d3a:	2b00      	cmp	r3, #0
 8027d3c:	d104      	bne.n	8027d48 <DAVE_Init+0x224>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_NRES */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_NRES); 
 8027d3e:	4847      	ldr	r0, [pc, #284]	; (8027e5c <DAVE_Init+0x338>)
 8027d40:	f7ff fa09 	bl	8027156 <DIGITAL_IO_Init>
 8027d44:	4603      	mov	r3, r0
 8027d46:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027d48:	79fb      	ldrb	r3, [r7, #7]
 8027d4a:	2b00      	cmp	r3, #0
 8027d4c:	d104      	bne.n	8027d58 <DAVE_Init+0x234>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_8 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_8); 
 8027d4e:	4844      	ldr	r0, [pc, #272]	; (8027e60 <DAVE_Init+0x33c>)
 8027d50:	f7ff fa01 	bl	8027156 <DIGITAL_IO_Init>
 8027d54:	4603      	mov	r3, r0
 8027d56:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027d58:	79fb      	ldrb	r3, [r7, #7]
 8027d5a:	2b00      	cmp	r3, #0
 8027d5c:	d104      	bne.n	8027d68 <DAVE_Init+0x244>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_7 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_7); 
 8027d5e:	4841      	ldr	r0, [pc, #260]	; (8027e64 <DAVE_Init+0x340>)
 8027d60:	f7ff f9f9 	bl	8027156 <DIGITAL_IO_Init>
 8027d64:	4603      	mov	r3, r0
 8027d66:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027d68:	79fb      	ldrb	r3, [r7, #7]
 8027d6a:	2b00      	cmp	r3, #0
 8027d6c:	d104      	bne.n	8027d78 <DAVE_Init+0x254>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_6 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_6); 
 8027d6e:	483e      	ldr	r0, [pc, #248]	; (8027e68 <DAVE_Init+0x344>)
 8027d70:	f7ff f9f1 	bl	8027156 <DIGITAL_IO_Init>
 8027d74:	4603      	mov	r3, r0
 8027d76:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027d78:	79fb      	ldrb	r3, [r7, #7]
 8027d7a:	2b00      	cmp	r3, #0
 8027d7c:	d104      	bne.n	8027d88 <DAVE_Init+0x264>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_5 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_5); 
 8027d7e:	483b      	ldr	r0, [pc, #236]	; (8027e6c <DAVE_Init+0x348>)
 8027d80:	f7ff f9e9 	bl	8027156 <DIGITAL_IO_Init>
 8027d84:	4603      	mov	r3, r0
 8027d86:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027d88:	79fb      	ldrb	r3, [r7, #7]
 8027d8a:	2b00      	cmp	r3, #0
 8027d8c:	d104      	bne.n	8027d98 <DAVE_Init+0x274>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_4 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_4); 
 8027d8e:	4838      	ldr	r0, [pc, #224]	; (8027e70 <DAVE_Init+0x34c>)
 8027d90:	f7ff f9e1 	bl	8027156 <DIGITAL_IO_Init>
 8027d94:	4603      	mov	r3, r0
 8027d96:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027d98:	79fb      	ldrb	r3, [r7, #7]
 8027d9a:	2b00      	cmp	r3, #0
 8027d9c:	d104      	bne.n	8027da8 <DAVE_Init+0x284>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_3 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_3); 
 8027d9e:	4835      	ldr	r0, [pc, #212]	; (8027e74 <DAVE_Init+0x350>)
 8027da0:	f7ff f9d9 	bl	8027156 <DIGITAL_IO_Init>
 8027da4:	4603      	mov	r3, r0
 8027da6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027da8:	79fb      	ldrb	r3, [r7, #7]
 8027daa:	2b00      	cmp	r3, #0
 8027dac:	d104      	bne.n	8027db8 <DAVE_Init+0x294>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_2 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_2); 
 8027dae:	4832      	ldr	r0, [pc, #200]	; (8027e78 <DAVE_Init+0x354>)
 8027db0:	f7ff f9d1 	bl	8027156 <DIGITAL_IO_Init>
 8027db4:	4603      	mov	r3, r0
 8027db6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027db8:	79fb      	ldrb	r3, [r7, #7]
 8027dba:	2b00      	cmp	r3, #0
 8027dbc:	d104      	bne.n	8027dc8 <DAVE_Init+0x2a4>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_SW_1 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_SW_1); 
 8027dbe:	482f      	ldr	r0, [pc, #188]	; (8027e7c <DAVE_Init+0x358>)
 8027dc0:	f7ff f9c9 	bl	8027156 <DIGITAL_IO_Init>
 8027dc4:	4603      	mov	r3, r0
 8027dc6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027dc8:	79fb      	ldrb	r3, [r7, #7]
 8027dca:	2b00      	cmp	r3, #0
 8027dcc:	d15c      	bne.n	8027e88 <DAVE_Init+0x364>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_POWER_EN2 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_POWER_EN2); 
 8027dce:	482c      	ldr	r0, [pc, #176]	; (8027e80 <DAVE_Init+0x35c>)
 8027dd0:	f7ff f9c1 	bl	8027156 <DIGITAL_IO_Init>
 8027dd4:	e056      	b.n	8027e84 <DAVE_Init+0x360>
 8027dd6:	bf00      	nop
 8027dd8:	1ffea2b0 	.word	0x1ffea2b0
 8027ddc:	08028610 	.word	0x08028610
 8027de0:	08028624 	.word	0x08028624
 8027de4:	08028638 	.word	0x08028638
 8027de8:	0802864c 	.word	0x0802864c
 8027dec:	1ffea2ac 	.word	0x1ffea2ac
 8027df0:	08028964 	.word	0x08028964
 8027df4:	0802857c 	.word	0x0802857c
 8027df8:	1ffe98a8 	.word	0x1ffe98a8
 8027dfc:	1ffe9428 	.word	0x1ffe9428
 8027e00:	1ffe9450 	.word	0x1ffe9450
 8027e04:	08028580 	.word	0x08028580
 8027e08:	08028584 	.word	0x08028584
 8027e0c:	08028588 	.word	0x08028588
 8027e10:	0802858c 	.word	0x0802858c
 8027e14:	08028590 	.word	0x08028590
 8027e18:	08028594 	.word	0x08028594
 8027e1c:	08028598 	.word	0x08028598
 8027e20:	08028b04 	.word	0x08028b04
 8027e24:	0802859c 	.word	0x0802859c
 8027e28:	1ffe97e0 	.word	0x1ffe97e0
 8027e2c:	1ffe97f4 	.word	0x1ffe97f4
 8027e30:	1ffe9808 	.word	0x1ffe9808
 8027e34:	1ffe981c 	.word	0x1ffe981c
 8027e38:	08028660 	.word	0x08028660
 8027e3c:	08028674 	.word	0x08028674
 8027e40:	08028688 	.word	0x08028688
 8027e44:	0802869c 	.word	0x0802869c
 8027e48:	080286b0 	.word	0x080286b0
 8027e4c:	080286c4 	.word	0x080286c4
 8027e50:	080286d8 	.word	0x080286d8
 8027e54:	080286ec 	.word	0x080286ec
 8027e58:	08028700 	.word	0x08028700
 8027e5c:	08028714 	.word	0x08028714
 8027e60:	08028728 	.word	0x08028728
 8027e64:	0802873c 	.word	0x0802873c
 8027e68:	08028750 	.word	0x08028750
 8027e6c:	08028764 	.word	0x08028764
 8027e70:	08028778 	.word	0x08028778
 8027e74:	0802878c 	.word	0x0802878c
 8027e78:	080287a0 	.word	0x080287a0
 8027e7c:	080287b4 	.word	0x080287b4
 8027e80:	080287c8 	.word	0x080287c8
 8027e84:	4603      	mov	r3, r0
 8027e86:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027e88:	79fb      	ldrb	r3, [r7, #7]
 8027e8a:	2b00      	cmp	r3, #0
 8027e8c:	d104      	bne.n	8027e98 <DAVE_Init+0x374>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED_POWER_EN1 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED_POWER_EN1); 
 8027e8e:	4835      	ldr	r0, [pc, #212]	; (8027f64 <DAVE_Init+0x440>)
 8027e90:	f7ff f961 	bl	8027156 <DIGITAL_IO_Init>
 8027e94:	4603      	mov	r3, r0
 8027e96:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027e98:	79fb      	ldrb	r3, [r7, #7]
 8027e9a:	2b00      	cmp	r3, #0
 8027e9c:	d104      	bne.n	8027ea8 <DAVE_Init+0x384>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_8 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_8); 
 8027e9e:	4832      	ldr	r0, [pc, #200]	; (8027f68 <DAVE_Init+0x444>)
 8027ea0:	f7ff f959 	bl	8027156 <DIGITAL_IO_Init>
 8027ea4:	4603      	mov	r3, r0
 8027ea6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027ea8:	79fb      	ldrb	r3, [r7, #7]
 8027eaa:	2b00      	cmp	r3, #0
 8027eac:	d104      	bne.n	8027eb8 <DAVE_Init+0x394>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_7 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_7); 
 8027eae:	482f      	ldr	r0, [pc, #188]	; (8027f6c <DAVE_Init+0x448>)
 8027eb0:	f7ff f951 	bl	8027156 <DIGITAL_IO_Init>
 8027eb4:	4603      	mov	r3, r0
 8027eb6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027eb8:	79fb      	ldrb	r3, [r7, #7]
 8027eba:	2b00      	cmp	r3, #0
 8027ebc:	d104      	bne.n	8027ec8 <DAVE_Init+0x3a4>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_6 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_6); 
 8027ebe:	482c      	ldr	r0, [pc, #176]	; (8027f70 <DAVE_Init+0x44c>)
 8027ec0:	f7ff f949 	bl	8027156 <DIGITAL_IO_Init>
 8027ec4:	4603      	mov	r3, r0
 8027ec6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027ec8:	79fb      	ldrb	r3, [r7, #7]
 8027eca:	2b00      	cmp	r3, #0
 8027ecc:	d104      	bne.n	8027ed8 <DAVE_Init+0x3b4>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_5 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_5); 
 8027ece:	4829      	ldr	r0, [pc, #164]	; (8027f74 <DAVE_Init+0x450>)
 8027ed0:	f7ff f941 	bl	8027156 <DIGITAL_IO_Init>
 8027ed4:	4603      	mov	r3, r0
 8027ed6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027ed8:	79fb      	ldrb	r3, [r7, #7]
 8027eda:	2b00      	cmp	r3, #0
 8027edc:	d104      	bne.n	8027ee8 <DAVE_Init+0x3c4>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_4 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_4); 
 8027ede:	4826      	ldr	r0, [pc, #152]	; (8027f78 <DAVE_Init+0x454>)
 8027ee0:	f7ff f939 	bl	8027156 <DIGITAL_IO_Init>
 8027ee4:	4603      	mov	r3, r0
 8027ee6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027ee8:	79fb      	ldrb	r3, [r7, #7]
 8027eea:	2b00      	cmp	r3, #0
 8027eec:	d104      	bne.n	8027ef8 <DAVE_Init+0x3d4>
  {
	 /**  Initialization of DIGITAL_IO APP instance HS_SW_3 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&HS_SW_3); 
 8027eee:	4823      	ldr	r0, [pc, #140]	; (8027f7c <DAVE_Init+0x458>)
 8027ef0:	f7ff f931 	bl	8027156 <DIGITAL_IO_Init>
 8027ef4:	4603      	mov	r3, r0
 8027ef6:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027ef8:	79fb      	ldrb	r3, [r7, #7]
 8027efa:	2b00      	cmp	r3, #0
 8027efc:	d104      	bne.n	8027f08 <DAVE_Init+0x3e4>
  {
	 /**  Initialization of DIGITAL_IO APP instance LS_SW_NRES */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LS_SW_NRES); 
 8027efe:	4820      	ldr	r0, [pc, #128]	; (8027f80 <DAVE_Init+0x45c>)
 8027f00:	f7ff f929 	bl	8027156 <DIGITAL_IO_Init>
 8027f04:	4603      	mov	r3, r0
 8027f06:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027f08:	79fb      	ldrb	r3, [r7, #7]
 8027f0a:	2b00      	cmp	r3, #0
 8027f0c:	d104      	bne.n	8027f18 <DAVE_Init+0x3f4>
  {
	 /**  Initialization of DIGITAL_IO APP instance MOTOR_FAULT */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&MOTOR_FAULT); 
 8027f0e:	481d      	ldr	r0, [pc, #116]	; (8027f84 <DAVE_Init+0x460>)
 8027f10:	f7ff f921 	bl	8027156 <DIGITAL_IO_Init>
 8027f14:	4603      	mov	r3, r0
 8027f16:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027f18:	79fb      	ldrb	r3, [r7, #7]
 8027f1a:	2b00      	cmp	r3, #0
 8027f1c:	d104      	bne.n	8027f28 <DAVE_Init+0x404>
  {
	 /**  Initialization of DIGITAL_IO APP instance POWER_SWITCH */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&POWER_SWITCH); 
 8027f1e:	481a      	ldr	r0, [pc, #104]	; (8027f88 <DAVE_Init+0x464>)
 8027f20:	f7ff f919 	bl	8027156 <DIGITAL_IO_Init>
 8027f24:	4603      	mov	r3, r0
 8027f26:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027f28:	79fb      	ldrb	r3, [r7, #7]
 8027f2a:	2b00      	cmp	r3, #0
 8027f2c:	d104      	bne.n	8027f38 <DAVE_Init+0x414>
  {
	 /**  Initialization of DIGITAL_IO APP instance TRANS_OUT */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&TRANS_OUT); 
 8027f2e:	4817      	ldr	r0, [pc, #92]	; (8027f8c <DAVE_Init+0x468>)
 8027f30:	f7ff f911 	bl	8027156 <DIGITAL_IO_Init>
 8027f34:	4603      	mov	r3, r0
 8027f36:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027f38:	79fb      	ldrb	r3, [r7, #7]
 8027f3a:	2b00      	cmp	r3, #0
 8027f3c:	d104      	bne.n	8027f48 <DAVE_Init+0x424>
  {
	 /**  Initialization of INTERRUPT APP instance CAN_EXT_TD */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CAN_EXT_TD); 
 8027f3e:	4814      	ldr	r0, [pc, #80]	; (8027f90 <DAVE_Init+0x46c>)
 8027f40:	f7ff f82b 	bl	8026f9a <INTERRUPT_Init>
 8027f44:	4603      	mov	r3, r0
 8027f46:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027f48:	79fb      	ldrb	r3, [r7, #7]
 8027f4a:	2b00      	cmp	r3, #0
 8027f4c:	d104      	bne.n	8027f58 <DAVE_Init+0x434>
  {
	 /**  Initialization of INTERRUPT APP instance CAN_EXT_CCVS */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&CAN_EXT_CCVS); 
 8027f4e:	4811      	ldr	r0, [pc, #68]	; (8027f94 <DAVE_Init+0x470>)
 8027f50:	f7ff f823 	bl	8026f9a <INTERRUPT_Init>
 8027f54:	4603      	mov	r3, r0
 8027f56:	71fb      	strb	r3, [r7, #7]
   }  
  return init_status;
 8027f58:	79fb      	ldrb	r3, [r7, #7]
} /**  End of function DAVE_Init */
 8027f5a:	4618      	mov	r0, r3
 8027f5c:	3708      	adds	r7, #8
 8027f5e:	46bd      	mov	sp, r7
 8027f60:	bd80      	pop	{r7, pc}
 8027f62:	bf00      	nop
 8027f64:	080287dc 	.word	0x080287dc
 8027f68:	080287f0 	.word	0x080287f0
 8027f6c:	08028804 	.word	0x08028804
 8027f70:	08028818 	.word	0x08028818
 8027f74:	0802882c 	.word	0x0802882c
 8027f78:	08028840 	.word	0x08028840
 8027f7c:	08028854 	.word	0x08028854
 8027f80:	08028868 	.word	0x08028868
 8027f84:	0802887c 	.word	0x0802887c
 8027f88:	08028890 	.word	0x08028890
 8027f8c:	080288a4 	.word	0x080288a4
 8027f90:	080285a0 	.word	0x080285a0
 8027f94:	080285a4 	.word	0x080285a4

08027f98 <XMC_GPIO_SetOutputHigh>:
{
 8027f98:	b480      	push	{r7}
 8027f9a:	b083      	sub	sp, #12
 8027f9c:	af00      	add	r7, sp, #0
 8027f9e:	6078      	str	r0, [r7, #4]
 8027fa0:	460b      	mov	r3, r1
 8027fa2:	70fb      	strb	r3, [r7, #3]
  port->OMR = (uint32_t)0x1U << pin;
 8027fa4:	78fb      	ldrb	r3, [r7, #3]
 8027fa6:	2201      	movs	r2, #1
 8027fa8:	409a      	lsls	r2, r3
 8027faa:	687b      	ldr	r3, [r7, #4]
 8027fac:	605a      	str	r2, [r3, #4]
}
 8027fae:	bf00      	nop
 8027fb0:	370c      	adds	r7, #12
 8027fb2:	46bd      	mov	sp, r7
 8027fb4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027fb8:	4770      	bx	lr

08027fba <XMC_GPIO_SetOutputLow>:
{
 8027fba:	b480      	push	{r7}
 8027fbc:	b083      	sub	sp, #12
 8027fbe:	af00      	add	r7, sp, #0
 8027fc0:	6078      	str	r0, [r7, #4]
 8027fc2:	460b      	mov	r3, r1
 8027fc4:	70fb      	strb	r3, [r7, #3]
  port->OMR = 0x10000U << pin;
 8027fc6:	78fb      	ldrb	r3, [r7, #3]
 8027fc8:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8027fcc:	409a      	lsls	r2, r3
 8027fce:	687b      	ldr	r3, [r7, #4]
 8027fd0:	605a      	str	r2, [r3, #4]
}
 8027fd2:	bf00      	nop
 8027fd4:	370c      	adds	r7, #12
 8027fd6:	46bd      	mov	sp, r7
 8027fd8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8027fdc:	4770      	bx	lr

08027fde <XMC_GPIO_ToggleOutput>:
{
 8027fde:	b480      	push	{r7}
 8027fe0:	b083      	sub	sp, #12
 8027fe2:	af00      	add	r7, sp, #0
 8027fe4:	6078      	str	r0, [r7, #4]
 8027fe6:	460b      	mov	r3, r1
 8027fe8:	70fb      	strb	r3, [r7, #3]
  port->OMR = 0x10001U << pin;
 8027fea:	78fb      	ldrb	r3, [r7, #3]
 8027fec:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 8027ff0:	409a      	lsls	r2, r3
 8027ff2:	687b      	ldr	r3, [r7, #4]
 8027ff4:	605a      	str	r2, [r3, #4]
}
 8027ff6:	bf00      	nop
 8027ff8:	370c      	adds	r7, #12
 8027ffa:	46bd      	mov	sp, r7
 8027ffc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028000:	4770      	bx	lr

08028002 <DIGITAL_IO_SetOutputHigh>:
{
 8028002:	b580      	push	{r7, lr}
 8028004:	b082      	sub	sp, #8
 8028006:	af00      	add	r7, sp, #0
 8028008:	6078      	str	r0, [r7, #4]
  XMC_GPIO_SetOutputHigh(handler->gpio_port, handler->gpio_pin);
 802800a:	687b      	ldr	r3, [r7, #4]
 802800c:	681a      	ldr	r2, [r3, #0]
 802800e:	687b      	ldr	r3, [r7, #4]
 8028010:	7c1b      	ldrb	r3, [r3, #16]
 8028012:	4619      	mov	r1, r3
 8028014:	4610      	mov	r0, r2
 8028016:	f7ff ffbf 	bl	8027f98 <XMC_GPIO_SetOutputHigh>
}
 802801a:	bf00      	nop
 802801c:	3708      	adds	r7, #8
 802801e:	46bd      	mov	sp, r7
 8028020:	bd80      	pop	{r7, pc}

08028022 <DIGITAL_IO_SetOutputLow>:
{
 8028022:	b580      	push	{r7, lr}
 8028024:	b082      	sub	sp, #8
 8028026:	af00      	add	r7, sp, #0
 8028028:	6078      	str	r0, [r7, #4]
  XMC_GPIO_SetOutputLow(handler->gpio_port,handler->gpio_pin);
 802802a:	687b      	ldr	r3, [r7, #4]
 802802c:	681a      	ldr	r2, [r3, #0]
 802802e:	687b      	ldr	r3, [r7, #4]
 8028030:	7c1b      	ldrb	r3, [r3, #16]
 8028032:	4619      	mov	r1, r3
 8028034:	4610      	mov	r0, r2
 8028036:	f7ff ffc0 	bl	8027fba <XMC_GPIO_SetOutputLow>
}
 802803a:	bf00      	nop
 802803c:	3708      	adds	r7, #8
 802803e:	46bd      	mov	sp, r7
 8028040:	bd80      	pop	{r7, pc}

08028042 <DIGITAL_IO_ToggleOutput>:
* }
*  @endcode
*/

__STATIC_INLINE void DIGITAL_IO_ToggleOutput(const DIGITAL_IO_t *const handler)
{
 8028042:	b580      	push	{r7, lr}
 8028044:	b082      	sub	sp, #8
 8028046:	af00      	add	r7, sp, #0
 8028048:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_ToggleOutput: handler null pointer", handler != NULL);
  XMC_GPIO_ToggleOutput(handler->gpio_port, handler->gpio_pin);
 802804a:	687b      	ldr	r3, [r7, #4]
 802804c:	681a      	ldr	r2, [r3, #0]
 802804e:	687b      	ldr	r3, [r7, #4]
 8028050:	7c1b      	ldrb	r3, [r3, #16]
 8028052:	4619      	mov	r1, r3
 8028054:	4610      	mov	r0, r2
 8028056:	f7ff ffc2 	bl	8027fde <XMC_GPIO_ToggleOutput>
}
 802805a:	bf00      	nop
 802805c:	3708      	adds	r7, #8
 802805e:	46bd      	mov	sp, r7
 8028060:	bd80      	pop	{r7, pc}
	...

08028064 <XMC_SCU_RESET_ClearDeviceResetReason>:
{
 8028064:	b480      	push	{r7}
 8028066:	af00      	add	r7, sp, #0
  SCU_RESET->RSTCLR = (uint32_t)SCU_RESET_RSTCLR_RSCLR_Msk;
 8028068:	4b03      	ldr	r3, [pc, #12]	; (8028078 <XMC_SCU_RESET_ClearDeviceResetReason+0x14>)
 802806a:	2201      	movs	r2, #1
 802806c:	609a      	str	r2, [r3, #8]
}
 802806e:	bf00      	nop
 8028070:	46bd      	mov	sp, r7
 8028072:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028076:	4770      	bx	lr
 8028078:	50004400 	.word	0x50004400

0802807c <CCU43_3_IRQHandler>:
extern uint8_t Can1Rx3Data[8];
//extern int32_t ExtCanOnline;


void ClutchCmpHandler (void)
{
 802807c:	b580      	push	{r7, lr}
 802807e:	af00      	add	r7, sp, #0
	PWM_CCU4_ClearEvent(&CLUTCH_PWM,XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP);
 8028080:	2102      	movs	r1, #2
 8028082:	4805      	ldr	r0, [pc, #20]	; (8028098 <CCU43_3_IRQHandler+0x1c>)
 8028084:	f7fe fee0 	bl	8026e48 <PWM_CCU4_ClearEvent>
	DIGITAL_IO_SetOutputLow(&HS_SW_1);
 8028088:	4804      	ldr	r0, [pc, #16]	; (802809c <CCU43_3_IRQHandler+0x20>)
 802808a:	f7ff ffca 	bl	8028022 <DIGITAL_IO_SetOutputLow>
	DIGITAL_IO_SetOutputLow(&HS_SW_2);
 802808e:	4804      	ldr	r0, [pc, #16]	; (80280a0 <CCU43_3_IRQHandler+0x24>)
 8028090:	f7ff ffc7 	bl	8028022 <DIGITAL_IO_SetOutputLow>
}
 8028094:	bf00      	nop
 8028096:	bd80      	pop	{r7, pc}
 8028098:	1ffe9450 	.word	0x1ffe9450
 802809c:	0802869c 	.word	0x0802869c
 80280a0:	080286b0 	.word	0x080286b0

080280a4 <CCU43_1_IRQHandler>:
void ClutchOvfHandler(void)
{
 80280a4:	b580      	push	{r7, lr}
 80280a6:	af00      	add	r7, sp, #0
	PWM_CCU4_ClearEvent(&CLUTCH_PWM,XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 80280a8:	2100      	movs	r1, #0
 80280aa:	4805      	ldr	r0, [pc, #20]	; (80280c0 <CCU43_1_IRQHandler+0x1c>)
 80280ac:	f7fe fecc 	bl	8026e48 <PWM_CCU4_ClearEvent>
	DIGITAL_IO_SetOutputHigh(&HS_SW_1);
 80280b0:	4804      	ldr	r0, [pc, #16]	; (80280c4 <CCU43_1_IRQHandler+0x20>)
 80280b2:	f7ff ffa6 	bl	8028002 <DIGITAL_IO_SetOutputHigh>
	DIGITAL_IO_SetOutputHigh(&HS_SW_2);
 80280b6:	4804      	ldr	r0, [pc, #16]	; (80280c8 <CCU43_1_IRQHandler+0x24>)
 80280b8:	f7ff ffa3 	bl	8028002 <DIGITAL_IO_SetOutputHigh>
}
 80280bc:	bf00      	nop
 80280be:	bd80      	pop	{r7, pc}
 80280c0:	1ffe9450 	.word	0x1ffe9450
 80280c4:	0802869c 	.word	0x0802869c
 80280c8:	080286b0 	.word	0x080286b0

080280cc <MCU_ProgramReset>:


void MCU_ProgramReset( void )
{
 80280cc:	b580      	push	{r7, lr}
 80280ce:	af00      	add	r7, sp, #0

	// clear the reset cause field for proper reset detection of the ssw
	XMC_SCU_RESET_ClearDeviceResetReason();
 80280d0:	f7ff ffc8 	bl	8028064 <XMC_SCU_RESET_ClearDeviceResetReason>

	// set normal boot as boot mode in SWCON field of STCON register
	XMC_SCU_SetBootMode(XMC_SCU_BOOTMODE_NORMAL);
 80280d4:	2000      	movs	r0, #0
 80280d6:	f7fb fd4b 	bl	8023b70 <XMC_SCU_SetBootMode>

	// trigger power on reset
	PPB->AIRCR = 1 << PPB_AIRCR_SYSRESETREQ_Pos |0x5FA<<PPB_AIRCR_VECTKEY_Pos | 0x1 << PPB_AIRCR_PRIGROUP_Pos;
 80280da:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80280de:	4a02      	ldr	r2, [pc, #8]	; (80280e8 <MCU_ProgramReset+0x1c>)
 80280e0:	f8c3 2d0c 	str.w	r2, [r3, #3340]	; 0xd0c

	while (1) {};
 80280e4:	e7fe      	b.n	80280e4 <MCU_ProgramReset+0x18>
 80280e6:	bf00      	nop
 80280e8:	05fa0104 	.word	0x05fa0104

080280ec <VADC0_C0_2_IRQHandler>:

} //MCU_ProgramReset()

void Adc_Measurement_Handler(void)
{
 80280ec:	b580      	push	{r7, lr}
 80280ee:	b082      	sub	sp, #8
 80280f0:	af00      	add	r7, sp, #0
	float temp = 0;
 80280f2:	f04f 0300 	mov.w	r3, #0
 80280f6:	607b      	str	r3, [r7, #4]

	static volatile int div = 0;

	Inputs.RIN1 = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_Channel_A_handle);
 80280f8:	480c      	ldr	r0, [pc, #48]	; (802812c <VADC0_C0_2_IRQHandler+0x40>)
 80280fa:	f7ff fcfb 	bl	8027af4 <ADC_MEASUREMENT_GetResult>
 80280fe:	4603      	mov	r3, r0
 8028100:	461a      	mov	r2, r3
 8028102:	4b0b      	ldr	r3, [pc, #44]	; (8028130 <VADC0_C0_2_IRQHandler+0x44>)
 8028104:	811a      	strh	r2, [r3, #8]
	else
	{
		ActiveRubberL = 0;
	}
*/
    Inputs.RIN2 = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_Channel_B_handle);
 8028106:	480b      	ldr	r0, [pc, #44]	; (8028134 <VADC0_C0_2_IRQHandler+0x48>)
 8028108:	f7ff fcf4 	bl	8027af4 <ADC_MEASUREMENT_GetResult>
 802810c:	4603      	mov	r3, r0
 802810e:	461a      	mov	r2, r3
 8028110:	4b07      	ldr	r3, [pc, #28]	; (8028130 <VADC0_C0_2_IRQHandler+0x44>)
 8028112:	815a      	strh	r2, [r3, #10]
    else
    {
        ActiveRubberR = 0;
    }
*/
   Inputs.DCIN = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_Channel_C_handle);
 8028114:	4808      	ldr	r0, [pc, #32]	; (8028138 <VADC0_C0_2_IRQHandler+0x4c>)
 8028116:	f7ff fced 	bl	8027af4 <ADC_MEASUREMENT_GetResult>
 802811a:	4603      	mov	r3, r0
 802811c:	461a      	mov	r2, r3
 802811e:	4b04      	ldr	r3, [pc, #16]	; (8028130 <VADC0_C0_2_IRQHandler+0x44>)
 8028120:	819a      	strh	r2, [r3, #12]
		DIGITAL_IO_ToggleOutput(&STATUS_LED_R);
	}
*/

   //Inputs.DriveCurrent = ADC_MEASUREMENT_GetResult(&ADC_MEASUREMENT_Channel_D_handle);
}
 8028122:	bf00      	nop
 8028124:	3708      	adds	r7, #8
 8028126:	46bd      	mov	sp, r7
 8028128:	bd80      	pop	{r7, pc}
 802812a:	bf00      	nop
 802812c:	1ffe9840 	.word	0x1ffe9840
 8028130:	1ffe991c 	.word	0x1ffe991c
 8028134:	1ffe9864 	.word	0x1ffe9864
 8028138:	1ffe9888 	.word	0x1ffe9888

0802813c <CAN0_1_IRQHandler>:
void ResetISRCan2Handler (void)
{
 802813c:	b580      	push	{r7, lr}
 802813e:	b092      	sub	sp, #72	; 0x48
 8028140:	af00      	add	r7, sp, #0
	char tempCanData[8] = {'C','M','D','_','B','O','O','T'};
 8028142:	4a41      	ldr	r2, [pc, #260]	; (8028248 <CAN0_1_IRQHandler+0x10c>)
 8028144:	f107 0308 	add.w	r3, r7, #8
 8028148:	e892 0003 	ldmia.w	r2, {r0, r1}
 802814c:	e883 0003 	stmia.w	r3, {r0, r1}
	char tempCanDataAddress[8] = {'R','E','S','E','T','_','0','0'};
 8028150:	4a3e      	ldr	r2, [pc, #248]	; (802824c <CAN0_1_IRQHandler+0x110>)
 8028152:	463b      	mov	r3, r7
 8028154:	e892 0003 	ldmia.w	r2, {r0, r1}
 8028158:	e883 0003 	stmia.w	r3, {r0, r1}
	uint8_t temp = 0;
 802815c:	2300      	movs	r3, #0
 802815e:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	//uint64_t temp_long = 0;

	DIGITAL_IO_ToggleOutput(&STATUS_LED_Y);
 8028162:	483b      	ldr	r0, [pc, #236]	; (8028250 <CAN0_1_IRQHandler+0x114>)
 8028164:	f7ff ff6d 	bl	8028042 <DIGITAL_IO_ToggleOutput>

	CAN_NODE_MO_Receive(&CAN_INT_LMO_08_Config);
 8028168:	483a      	ldr	r0, [pc, #232]	; (8028254 <CAN0_1_IRQHandler+0x118>)
 802816a:	f7ff fa43 	bl	80275f4 <CAN_NODE_MO_Receive>

	if (CAN_INT_LMO_08_Config.mo_ptr->can_identifier == 0x06)
 802816e:	4b39      	ldr	r3, [pc, #228]	; (8028254 <CAN0_1_IRQHandler+0x118>)
 8028170:	681b      	ldr	r3, [r3, #0]
 8028172:	685b      	ldr	r3, [r3, #4]
 8028174:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 8028178:	2b06      	cmp	r3, #6
 802817a:	d117      	bne.n	80281ac <CAN0_1_IRQHandler+0x70>
	{
		uint64_t ul1 = CAN_INT_LMO_08_Config.mo_ptr->can_data_long;
 802817c:	4b35      	ldr	r3, [pc, #212]	; (8028254 <CAN0_1_IRQHandler+0x118>)
 802817e:	681b      	ldr	r3, [r3, #0]
 8028180:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8028184:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38

		uint64_t * p = (uint64_t *)(tempCanData);
 8028188:	f107 0308 	add.w	r3, r7, #8
 802818c:	637b      	str	r3, [r7, #52]	; 0x34
		uint64_t ul2 = *p;
 802818e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8028190:	e9d3 2300 	ldrd	r2, r3, [r3]
 8028194:	e9c7 230a 	strd	r2, r3, [r7, #40]	; 0x28

		if (ul1 == ul2)
 8028198:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	; 0x38
 802819c:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
 80281a0:	4299      	cmp	r1, r3
 80281a2:	bf08      	it	eq
 80281a4:	4290      	cmpeq	r0, r2
 80281a6:	d101      	bne.n	80281ac <CAN0_1_IRQHandler+0x70>
		{
			MCU_ProgramReset();
 80281a8:	f7ff ff90 	bl	80280cc <MCU_ProgramReset>
		}
	}

	CAN_NODE_MO_Receive(&CAN_EXT_LMO_08_Config);
 80281ac:	482a      	ldr	r0, [pc, #168]	; (8028258 <CAN0_1_IRQHandler+0x11c>)
 80281ae:	f7ff fa21 	bl	80275f4 <CAN_NODE_MO_Receive>

	if (CAN_EXT_LMO_08_Config.mo_ptr->can_identifier == 0x06)
 80281b2:	4b29      	ldr	r3, [pc, #164]	; (8028258 <CAN0_1_IRQHandler+0x11c>)
 80281b4:	681b      	ldr	r3, [r3, #0]
 80281b6:	685b      	ldr	r3, [r3, #4]
 80281b8:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 80281bc:	2b06      	cmp	r3, #6
 80281be:	d13f      	bne.n	8028240 <CAN0_1_IRQHandler+0x104>
	{
		uint64_t ul1 = CAN_EXT_LMO_08_Config.mo_ptr->can_data_long;
 80281c0:	4b25      	ldr	r3, [pc, #148]	; (8028258 <CAN0_1_IRQHandler+0x11c>)
 80281c2:	681b      	ldr	r3, [r3, #0]
 80281c4:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80281c8:	e9c7 2308 	strd	r2, r3, [r7, #32]

		temp = (uint8_t)Presets.DOOR_NUMBER; // calculate address
 80281cc:	4b23      	ldr	r3, [pc, #140]	; (802825c <CAN0_1_IRQHandler+0x120>)
 80281ce:	689b      	ldr	r3, [r3, #8]
 80281d0:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
		temp = temp/10;		// 00 - 90 from address (tens)
 80281d4:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80281d8:	4a21      	ldr	r2, [pc, #132]	; (8028260 <CAN0_1_IRQHandler+0x124>)
 80281da:	fba2 2303 	umull	r2, r3, r2, r3
 80281de:	08db      	lsrs	r3, r3, #3
 80281e0:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
		tempCanDataAddress[6] += temp; // add to string
 80281e4:	79ba      	ldrb	r2, [r7, #6]
 80281e6:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80281ea:	4413      	add	r3, r2
 80281ec:	b2db      	uxtb	r3, r3
 80281ee:	71bb      	strb	r3, [r7, #6]

		temp = (uint8_t)Presets.DOOR_NUMBER;
 80281f0:	4b1a      	ldr	r3, [pc, #104]	; (802825c <CAN0_1_IRQHandler+0x120>)
 80281f2:	689b      	ldr	r3, [r3, #8]
 80281f4:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
		temp = temp%10;	// 0 - 9 from address
 80281f8:	f897 2047 	ldrb.w	r2, [r7, #71]	; 0x47
 80281fc:	4b18      	ldr	r3, [pc, #96]	; (8028260 <CAN0_1_IRQHandler+0x124>)
 80281fe:	fba3 1302 	umull	r1, r3, r3, r2
 8028202:	08d9      	lsrs	r1, r3, #3
 8028204:	460b      	mov	r3, r1
 8028206:	009b      	lsls	r3, r3, #2
 8028208:	440b      	add	r3, r1
 802820a:	005b      	lsls	r3, r3, #1
 802820c:	1ad3      	subs	r3, r2, r3
 802820e:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
		tempCanDataAddress[7] += temp; // add to string
 8028212:	79fa      	ldrb	r2, [r7, #7]
 8028214:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8028218:	4413      	add	r3, r2
 802821a:	b2db      	uxtb	r3, r3
 802821c:	71fb      	strb	r3, [r7, #7]

		uint64_t * p = (uint64_t *)(tempCanDataAddress);
 802821e:	463b      	mov	r3, r7
 8028220:	61fb      	str	r3, [r7, #28]
		uint64_t ul2 = *p;
 8028222:	69fb      	ldr	r3, [r7, #28]
 8028224:	e9d3 2300 	ldrd	r2, r3, [r3]
 8028228:	e9c7 2304 	strd	r2, r3, [r7, #16]

		if (ul1 == ul2)
 802822c:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8028230:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8028234:	4299      	cmp	r1, r3
 8028236:	bf08      	it	eq
 8028238:	4290      	cmpeq	r0, r2
 802823a:	d101      	bne.n	8028240 <CAN0_1_IRQHandler+0x104>
		{
			MCU_ProgramReset();
 802823c:	f7ff ff46 	bl	80280cc <MCU_ProgramReset>
		}
	}

}
 8028240:	bf00      	nop
 8028242:	3748      	adds	r7, #72	; 0x48
 8028244:	46bd      	mov	sp, r7
 8028246:	bd80      	pop	{r7, pc}
 8028248:	08028c78 	.word	0x08028c78
 802824c:	08028c80 	.word	0x08028c80
 8028250:	08028638 	.word	0x08028638
 8028254:	08028958 	.word	0x08028958
 8028258:	08028a98 	.word	0x08028a98
 802825c:	1ffe9930 	.word	0x1ffe9930
 8028260:	cccccccd 	.word	0xcccccccd

08028264 <main>:
		}
	}
}

int main(void)
{
 8028264:	b580      	push	{r7, lr}
 8028266:	b082      	sub	sp, #8
 8028268:	af00      	add	r7, sp, #0
  DAVE_STATUS_t status;

  status = DAVE_Init();           /* Initialization of DAVE APPs  */
 802826a:	f7ff fc5b 	bl	8027b24 <DAVE_Init>
 802826e:	4603      	mov	r3, r0
 8028270:	71fb      	strb	r3, [r7, #7]

  if (status != DAVE_STATUS_SUCCESS)
 8028272:	79fb      	ldrb	r3, [r7, #7]
 8028274:	2b00      	cmp	r3, #0
 8028276:	d000      	beq.n	802827a <main+0x16>
  {
    /* Placeholder for error handler code. The while loop below can be replaced with an user error handler. */
    XMC_DEBUG("DAVE APPs initialization failed\n");

    while(1U)
 8028278:	e7fe      	b.n	8028278 <main+0x14>
    }
  }

  // Init Internal Retain Memory Code:

  E_EEPROM_XMC4_STATUS_t e_status = E_EEPROM_XMC4_Init( &RETAIN );
 802827a:	481a      	ldr	r0, [pc, #104]	; (80282e4 <main+0x80>)
 802827c:	f7fb f85c 	bl	8023338 <E_EEPROM_XMC4_Init>
 8028280:	4603      	mov	r3, r0
 8028282:	71bb      	strb	r3, [r7, #6]
    switch ( e_status ) {
 8028284:	79bb      	ldrb	r3, [r7, #6]
 8028286:	2b04      	cmp	r3, #4
 8028288:	d012      	beq.n	80282b0 <main+0x4c>
 802828a:	2b04      	cmp	r3, #4
 802828c:	dc1c      	bgt.n	80282c8 <main+0x64>
 802828e:	2b00      	cmp	r3, #0
 8028290:	d002      	beq.n	8028298 <main+0x34>
 8028292:	2b01      	cmp	r3, #1
 8028294:	d00c      	beq.n	80282b0 <main+0x4c>
 8028296:	e017      	b.n	80282c8 <main+0x64>
    	case  E_EEPROM_XMC4_STATUS_OK: {
    		  if ( E_EEPROM_XMC4_IsFlashEmpty())
 8028298:	f7fb f964 	bl	8023564 <E_EEPROM_XMC4_IsFlashEmpty>
 802829c:	4603      	mov	r3, r0
 802829e:	2b00      	cmp	r3, #0
 80282a0:	d002      	beq.n	80282a8 <main+0x44>
    		  {
    			  SaveAllPresets(&DefaultPresets);
 80282a2:	4811      	ldr	r0, [pc, #68]	; (80282e8 <main+0x84>)
 80282a4:	f7fa ffe5 	bl	8023272 <SaveAllPresets>
    		  } //if
    		  ReadAllPresets( &Presets );
 80282a8:	4810      	ldr	r0, [pc, #64]	; (80282ec <main+0x88>)
 80282aa:	f7fa ffd5 	bl	8023258 <ReadAllPresets>
    		break;
 80282ae:	e015      	b.n	80282dc <main+0x78>
    	case E_EEPROM_XMC4_STATUS_ERROR_OLD_DATA:
    	case E_EEPROM_XMC4_STATUS_ERASE_ERROR:
    	{
    		/* add here the memory error handler */

    		Presets = DefaultPresets; // for example...
 80282b0:	4a0e      	ldr	r2, [pc, #56]	; (80282ec <main+0x88>)
 80282b2:	4b0d      	ldr	r3, [pc, #52]	; (80282e8 <main+0x84>)
 80282b4:	4610      	mov	r0, r2
 80282b6:	4619      	mov	r1, r3
 80282b8:	234c      	movs	r3, #76	; 0x4c
 80282ba:	461a      	mov	r2, r3
 80282bc:	f000 f852 	bl	8028364 <memcpy>
    		DIGITAL_IO_SetOutputHigh(&STATUS_LED_R);
 80282c0:	480b      	ldr	r0, [pc, #44]	; (80282f0 <main+0x8c>)
 80282c2:	f7ff fe9e 	bl	8028002 <DIGITAL_IO_SetOutputHigh>
    		break;
 80282c6:	e009      	b.n	80282dc <main+0x78>
    	}

    	default :
    		DIGITAL_IO_SetOutputHigh(&STATUS_LED_R);
 80282c8:	4809      	ldr	r0, [pc, #36]	; (80282f0 <main+0x8c>)
 80282ca:	f7ff fe9a 	bl	8028002 <DIGITAL_IO_SetOutputHigh>
    		DIGITAL_IO_SetOutputHigh(&STATUS_LED_G);
 80282ce:	4809      	ldr	r0, [pc, #36]	; (80282f4 <main+0x90>)
 80282d0:	f7ff fe97 	bl	8028002 <DIGITAL_IO_SetOutputHigh>
    		DIGITAL_IO_SetOutputHigh(&STATUS_LED_Y);
 80282d4:	4808      	ldr	r0, [pc, #32]	; (80282f8 <main+0x94>)
 80282d6:	f7ff fe94 	bl	8028002 <DIGITAL_IO_SetOutputHigh>
    		break;
 80282da:	bf00      	nop

    	} //switch

  MainAlgInit();
 80282dc:	f7fa ff8c 	bl	80231f8 <MainAlgInit>

  /* Placeholder for user application code. The while loop below can be replaced with user application code. */
  while(1U)
 80282e0:	e7fe      	b.n	80282e0 <main+0x7c>
 80282e2:	bf00      	nop
 80282e4:	1ffea17c 	.word	0x1ffea17c
 80282e8:	0802844c 	.word	0x0802844c
 80282ec:	1ffe9930 	.word	0x1ffe9930
 80282f0:	0802864c 	.word	0x0802864c
 80282f4:	08028624 	.word	0x08028624
 80282f8:	08028638 	.word	0x08028638

080282fc <__libc_init_array>:
 80282fc:	b570      	push	{r4, r5, r6, lr}
 80282fe:	4d0d      	ldr	r5, [pc, #52]	; (8028334 <__libc_init_array+0x38>)
 8028300:	4c0d      	ldr	r4, [pc, #52]	; (8028338 <__libc_init_array+0x3c>)
 8028302:	1b64      	subs	r4, r4, r5
 8028304:	10a4      	asrs	r4, r4, #2
 8028306:	2600      	movs	r6, #0
 8028308:	42a6      	cmp	r6, r4
 802830a:	d109      	bne.n	8028320 <__libc_init_array+0x24>
 802830c:	4d0b      	ldr	r5, [pc, #44]	; (802833c <__libc_init_array+0x40>)
 802830e:	4c0c      	ldr	r4, [pc, #48]	; (8028340 <__libc_init_array+0x44>)
 8028310:	f7fd fec5 	bl	802609e <_init>
 8028314:	1b64      	subs	r4, r4, r5
 8028316:	10a4      	asrs	r4, r4, #2
 8028318:	2600      	movs	r6, #0
 802831a:	42a6      	cmp	r6, r4
 802831c:	d105      	bne.n	802832a <__libc_init_array+0x2e>
 802831e:	bd70      	pop	{r4, r5, r6, pc}
 8028320:	f855 3b04 	ldr.w	r3, [r5], #4
 8028324:	4798      	blx	r3
 8028326:	3601      	adds	r6, #1
 8028328:	e7ee      	b.n	8028308 <__libc_init_array+0xc>
 802832a:	f855 3b04 	ldr.w	r3, [r5], #4
 802832e:	4798      	blx	r3
 8028330:	3601      	adds	r6, #1
 8028332:	e7f2      	b.n	802831a <__libc_init_array+0x1e>
 8028334:	1ffe98c4 	.word	0x1ffe98c4
 8028338:	1ffe98c4 	.word	0x1ffe98c4
 802833c:	1ffe98c4 	.word	0x1ffe98c4
 8028340:	1ffe98c4 	.word	0x1ffe98c4

08028344 <memcmp>:
 8028344:	b510      	push	{r4, lr}
 8028346:	3901      	subs	r1, #1
 8028348:	4402      	add	r2, r0
 802834a:	4290      	cmp	r0, r2
 802834c:	d101      	bne.n	8028352 <memcmp+0xe>
 802834e:	2000      	movs	r0, #0
 8028350:	e005      	b.n	802835e <memcmp+0x1a>
 8028352:	7803      	ldrb	r3, [r0, #0]
 8028354:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8028358:	42a3      	cmp	r3, r4
 802835a:	d001      	beq.n	8028360 <memcmp+0x1c>
 802835c:	1b18      	subs	r0, r3, r4
 802835e:	bd10      	pop	{r4, pc}
 8028360:	3001      	adds	r0, #1
 8028362:	e7f2      	b.n	802834a <memcmp+0x6>

08028364 <memcpy>:
 8028364:	440a      	add	r2, r1
 8028366:	4291      	cmp	r1, r2
 8028368:	f100 33ff 	add.w	r3, r0, #4294967295
 802836c:	d100      	bne.n	8028370 <memcpy+0xc>
 802836e:	4770      	bx	lr
 8028370:	b510      	push	{r4, lr}
 8028372:	f811 4b01 	ldrb.w	r4, [r1], #1
 8028376:	f803 4f01 	strb.w	r4, [r3, #1]!
 802837a:	4291      	cmp	r1, r2
 802837c:	d1f9      	bne.n	8028372 <memcpy+0xe>
 802837e:	bd10      	pop	{r4, pc}

08028380 <__Motor0_BLDC_SCALAR_Ramp_Linear_veneer>:
 8028380:	f85f f000 	ldr.w	pc, [pc]	; 8028384 <__Motor0_BLDC_SCALAR_Ramp_Linear_veneer+0x4>
 8028384:	1ffe9001 	.word	0x1ffe9001

08028388 <__Motor0_BLDC_SCALAR_MSM_veneer>:
 8028388:	f85f f000 	ldr.w	pc, [pc]	; 802838c <__Motor0_BLDC_SCALAR_MSM_veneer+0x4>
 802838c:	1ffe8ec9 	.word	0x1ffe8ec9

08028390 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation_veneer>:
 8028390:	f85f f000 	ldr.w	pc, [pc]	; 8028394 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation_veneer+0x4>
 8028394:	1ffe8c7d 	.word	0x1ffe8c7d

08028398 <__Motor0_BLDC_SCALAR_PatternInitiator_veneer>:
 8028398:	f85f f000 	ldr.w	pc, [pc]	; 802839c <__Motor0_BLDC_SCALAR_PatternInitiator_veneer+0x4>
 802839c:	1ffe8f3d 	.word	0x1ffe8f3d

080283a0 <Motor0_BLDC_SCALAR_CCU8ExtStartEventConf>:
 80283a0:	00000107                                ....

080283a4 <Motor0_BLDC_SCALAR_CCU8ExtStopEventConf>:
 80283a4:	00000207                                ....

080283a8 <Motor0_BLDC_SCALAR_CCU8CompareConf>:
 80283a8:	02000001 00000003 00000004 00000000     ................

080283b8 <Motor0_BLDC_SCALAR_GPIO_PhU_High_Config>:
 80283b8:	00000098 00010000 00000000              ............

080283c4 <Motor0_BLDC_SCALAR_GPIO_PhU_Low_Config>:
 80283c4:	00000098 00010000 00000000              ............

080283d0 <Motor0_BLDC_SCALAR_GPIO_PhV_High_Config>:
 80283d0:	00000098 00010000 00000000              ............

080283dc <Motor0_BLDC_SCALAR_GPIO_PhV_Low_Config>:
 80283dc:	00000098 00010000 00000000              ............

080283e8 <Motor0_BLDC_SCALAR_GPIO_PhW_High_Config>:
 80283e8:	00000098 00010000 00000000              ............

080283f4 <Motor0_BLDC_SCALAR_GPIO_PhW_Low_Config>:
 80283f4:	00000098 00010000 00000000              ............

08028400 <Motor0_BLDC_SCALAR_GPIO_Hall_Config>:
 8028400:	00000000 00010000 00000000              ............

0802840c <Motor0_BLDC_SCALAR_GPIO_Inverter_Config>:
 802840c:	00000080 00010000 00000001              ............

08028418 <Motor0_BLDC_SCALAR_POSIF_HALL_Config>:
 8028418:	00000010                                ....

0802841c <Motor0_BLDC_SCALAR_POSIF_GLOBAL_Config>:
 802841c:	50000000                                ...P

08028420 <Motor0_BLDC_SCALAR_POSIF_MCM_Config>:
 8028420:	00000000                                ....

08028424 <Motor0_BLDC_SCALAR_VADC_GLOBAL_config>:
	...

0802843c <Motor0_BLDC_SCALAR_VADC_GROUP_class0>:
 802843c:	00000001                                ....

08028440 <Motor0_BLDC_SCALAR_VADC_QUEUE_3_cfg>:
 8028440:	00000000 00004800 00000004              .....H......

0802844c <DefaultPresets>:
 802844c:	00000001 00000001 00000001 00000001     ................
 802845c:	00010005 00100245 00000000 000000c8     ....E...........
 802846c:	00000bb8 00000000 00000500 000000c8     ................
 802847c:	000007d0 00000320 000000a0 00000320     .... ....... ...
 802848c:	00000320 000000a0 00000000               ...........

08028498 <e_eeprom_xmc4_fce>:
 8028498:	50020020 00000700 00000000               ..P........

080284a4 <g_xmc_vadc_group_array>:
 80284a4:	40004400 40004800 40004c00 40005000     .D.@.H.@.L.@.P.@

080284b4 <BUZZ_PWM_timer_handle>:
 80284b4:	00000000 00000006                       ........

080284bc <BUZZ_PWM_event0_config>:
 80284bc:	00010000                                ....

080284c0 <BUZZ_PWM_event1_config>:
 80284c0:	00010000                                ....

080284c4 <BUZZ_PWM_event2_config>:
 80284c4:	00010000                                ....

080284c8 <BUZZ_PWM_config_handle>:
 80284c8:	07520000 010103a9 00000000 02020000     ..R.............
 80284d8:	00000000 080284bc 080284c0 080284c4     ................
	...
 80284f4:	01000000 00000000 10000000 080284b4     ................
	...
 8028514:	1ffe9478                                x...

08028518 <CLUTCH_PWM_timer_handle>:
 8028518:	00000000 00000006                       ........

08028520 <CLUTCH_PWM_event0_config>:
 8028520:	00010000                                ....

08028524 <CLUTCH_PWM_event1_config>:
 8028524:	00010000                                ....

08028528 <CLUTCH_PWM_event2_config>:
 8028528:	00010000                                ....

0802852c <CLUTCH_PWM_config_handle>:
 802852c:	07520000 010103a9 00000000 03030100     ..R.............
 802853c:	00000001 08028520 08028524 08028528     .... ...$...(...
	...
 8028558:	01000000 00000000 20000000 08028518     ........... ....
	...
 8028578:	1ffe9478                                x...

0802857c <CAN_INT_RESET_INT>:
 802857c:	01003f4d                                M?..

08028580 <BUZZ_INT_CMP>:
 8028580:	01003f3a                                :?..

08028584 <BUZZ_INT_OVF>:
 8028584:	01003f38                                8?..

08028588 <CLUTCH_INT_CMP>:
 8028588:	01003f3b                                ;?..

0802858c <CLUTCH_INT_OVF>:
 802858c:	01003f39                                9?..

08028590 <CAN_EXT_DSC1_INT>:
 8028590:	01003f4f                                O?..

08028594 <CAN_EXT_DSC3_INT>:
 8028594:	01003f52                                R?..

08028598 <CAN_EXT_DSC2_INT>:
 8028598:	01003f51                                Q?..

0802859c <CAN_NODE_ALLERT>:
 802859c:	01003f4c                                L?..

080285a0 <CAN_EXT_TD>:
 80285a0:	01003f50                                P?..

080285a4 <CAN_EXT_CCVS>:
 80285a4:	01003f4e                                N?..

080285a8 <group_init_handle0>:
	...

080285bc <group_init_handle1>:
	...

080285d0 <group_init_handle2>:
	...

080285e4 <group_init_handle3>:
	...

080285f8 <global_config>:
 80285f8:	00000000 00000003 00000000 00000000     ................
	...

08028610 <SERVICE_BUT>:
 8028610:	48028f00 00000000 00000000 00000000     ...H............
 8028620:	00000002                                ....

08028624 <STATUS_LED_G>:
 8028624:	48028300 00000080 00010000 00000004     ...H............
 8028634:	00000009                                ....

08028638 <STATUS_LED_Y>:
 8028638:	48028300 00000080 00010000 00000004     ...H............
 8028648:	0000000a                                ....

0802864c <STATUS_LED_R>:
 802864c:	48028300 00000080 00010000 00000004     ...H............
 802865c:	0000000b                                ....

08028660 <DI_NPN_EN>:
 8028660:	48028300 00000080 00010000 00000004     ...H............
 8028670:	00000007                                ....

08028674 <DI_PNP_EN>:
 8028674:	48028300 00000080 00010000 00000004     ...H............
 8028684:	00000008                                ....

08028688 <GROUP_IN_EN>:
 8028688:	48028200 00000080 00010000 00000004     ...H............
 8028698:	00000000                                ....

0802869c <HS_SW_1>:
 802869c:	48028100 00000080 00010000 00000004     ...H............
 80286ac:	0000000a                                ....

080286b0 <HS_SW_2>:
 80286b0:	48028100 00000080 00010000 00000004     ...H............
 80286c0:	0000000b                                ....

080286c4 <LS_SW_4>:
 80286c4:	48028300 00000080 00010000 00000004     ...H............
 80286d4:	00000002                                ....

080286d8 <LS_SW_3>:
 80286d8:	48028000 00000080 00010000 00000004     ...H............
 80286e8:	00000009                                ....

080286ec <LS_SW_2>:
 80286ec:	48028000 00000080 00010000 00000004     ...H............
 80286fc:	0000000a                                ....

08028700 <LS_SW_1>:
 8028700:	48028000 00000080 00010000 00000004     ...H............
 8028710:	00000000                                ....

08028714 <LED_SW_NRES>:
 8028714:	48028000 00000080 00010000 00000004     ...H............
 8028724:	0000000e                                ....

08028728 <LED_SW_8>:
 8028728:	48028400 00000080 00010000 00000004     ...H............
 8028738:	00000007                                ....

0802873c <LED_SW_7>:
 802873c:	48028400 00000080 00010000 00000004     ...H............
 802874c:	00000006                                ....

08028750 <LED_SW_6>:
 8028750:	48028400 00000080 00010000 00000004     ...H............
 8028760:	00000005                                ....

08028764 <LED_SW_5>:
 8028764:	48028400 00000080 00010000 00000004     ...H............
 8028774:	00000004                                ....

08028778 <LED_SW_4>:
 8028778:	48028400 00000080 00010000 00000004     ...H............
 8028788:	00000003                                ....

0802878c <LED_SW_3>:
 802878c:	48028400 00000080 00010000 00000004     ...H............
 802879c:	00000002                                ....

080287a0 <LED_SW_2>:
 80287a0:	48028400 00000080 00010000 00000004     ...H............
 80287b0:	00000001                                ....

080287b4 <LED_SW_1>:
 80287b4:	48028400 00000080 00010000 00000004     ...H............
 80287c4:	00000000                                ....

080287c8 <LED_POWER_EN2>:
 80287c8:	48028000 00000080 00010000 00000004     ...H............
 80287d8:	00000007                                ....

080287dc <LED_POWER_EN1>:
 80287dc:	48028000 00000080 00010000 00000004     ...H............
 80287ec:	00000006                                ....

080287f0 <HS_SW_8>:
 80287f0:	48028600 00000080 00010000 00000004     ...H............
 8028800:	00000002                                ....

08028804 <HS_SW_7>:
 8028804:	48028600 00000080 00010000 00000004     ...H............
 8028814:	00000001                                ....

08028818 <HS_SW_6>:
 8028818:	48028600 00000080 00010000 00000004     ...H............
 8028828:	00000000                                ....

0802882c <HS_SW_5>:
 802882c:	48028100 00000080 00010000 00000004     ...H............
 802883c:	0000000e                                ....

08028840 <HS_SW_4>:
 8028840:	48028100 00000080 00010000 00000004     ...H............
 8028850:	0000000d                                ....

08028854 <HS_SW_3>:
 8028854:	48028100 00000080 00010000 00000004     ...H............
 8028864:	0000000c                                ....

08028868 <LS_SW_NRES>:
 8028868:	48028000 00000080 00010000 00000004     ...H............
 8028878:	0000000f                                ....

0802887c <MOTOR_FAULT>:
 802887c:	48028f00 00000000 00000000 00000000     ...H............
 802888c:	0000000e                                ....

08028890 <POWER_SWITCH>:
 8028890:	48028100 00000080 00010000 00000004     ...H............
 80288a0:	00000006                                ....

080288a4 <TRANS_OUT>:
 80288a4:	48028100 00000080 00010000 00000004     ...H............
 80288b4:	0000000f 01020278 00010000 00000000     ....x...........
 80288c4:	00010000 01010102                       ........

080288cc <CAN_INT_gpio_out>:
 80288cc:	48028100 00000004                       ...H....

080288d4 <CAN_INT_gpio_out_config>:
 80288d4:	00000090 00000001 00000002              ............

080288e0 <CAN_INT_gpio_in>:
 80288e0:	48028100 00000005                       ...H....

080288e8 <CAN_INT_gpio_in_config>:
	...

080288f4 <CAN_INT_BitTimeConfig>:
 80288f4:	07270e00 0001e848 00011f40              ..'.H...@...

08028900 <CAN_INT_sr>:
 8028900:	00000000                                ....

08028904 <CAN_INT_LMO_01_Config>:
 8028904:	1ffe94e0 00000015 00000000              ............

08028910 <CAN_INT_LMO_02_Config>:
 8028910:	1ffe9500 00000018 00000000              ............

0802891c <CAN_INT_LMO_03_Config>:
 802891c:	1ffe9520 00000017 00000000               ...........

08028928 <CAN_INT_LMO_04_Config>:
 8028928:	1ffe9540 00000014 00000000              @...........

08028934 <CAN_INT_LMO_05_Config>:
 8028934:	1ffe9560 0000001d 00000000              `...........

08028940 <CAN_INT_LMO_06_Config>:
 8028940:	1ffe9580 0000003d 00000000              ....=.......

0802894c <CAN_INT_LMO_07_Config>:
 802894c:	1ffe95a0 0000001a 00000000              ............

08028958 <CAN_INT_LMO_08_Config>:
 8028958:	1ffe95c0 00010027 00000001              ....'.......

08028964 <CAN_INT>:
 8028964:	1ffe9488 48014200 080288f4 08028904     .....B.H........
 8028974:	08028910 0802891c 08028928 08028934     ........(...4...
 8028984:	08028940 0802894c 08028958 00000000     @...L...X.......
	...
 80289f0:	08028900 080288cc 080288d4 080288e0     ................
 8028a00:	080288e8 00080000 00000000              ............

08028a0c <CAN_EXT_gpio_out>:
 8028a0c:	48028100 00000009                       ...H....

08028a14 <CAN_EXT_gpio_out_config>:
 8028a14:	00000090 00000001 00000002              ............

08028a20 <CAN_EXT_gpio_in>:
 8028a20:	48028100 00000008                       ...H....

08028a28 <CAN_EXT_gpio_in_config>:
	...

08028a34 <CAN_EXT_BitTimeConfig>:
 8028a34:	07270e00 0003d090 00011f40              ..'.....@...

08028a40 <CAN_EXT_sr>:
 8028a40:	00000000                                ....

08028a44 <CAN_EXT_LMO_01_Config>:
 8028a44:	1ffe95e0 0003001e 00000001              ............

08028a50 <CAN_EXT_LMO_02_Config>:
 8028a50:	1ffe9600 0005001f 00000001              ............

08028a5c <CAN_EXT_LMO_03_Config>:
 8028a5c:	1ffe9620 00060020 00000001               ... .......

08028a68 <CAN_EXT_LMO_04_Config>:
 8028a68:	1ffe9640 00020021 00000001              @...!.......

08028a74 <CAN_EXT_LMO_05_Config>:
 8028a74:	1ffe9660 00040022 00000001              `...".......

08028a80 <CAN_EXT_LMO_06_Config>:
 8028a80:	1ffe9680 00000016 00000000              ............

08028a8c <CAN_EXT_LMO_07_Config>:
 8028a8c:	1ffe96a0 00000006 00000000              ............

08028a98 <CAN_EXT_LMO_08_Config>:
 8028a98:	1ffe96c0 00010023 00000001              ....#.......

08028aa4 <CAN_EXT_LMO_09_Config>:
 8028aa4:	1ffe96e0 00000005 00000000              ............

08028ab0 <CAN_EXT_LMO_10_Config>:
 8028ab0:	1ffe9700 00000008 00000000              ............

08028abc <CAN_EXT_LMO_11_Config>:
 8028abc:	1ffe9720 00000007 00000000               ...........

08028ac8 <CAN_EXT_LMO_12_Config>:
 8028ac8:	1ffe9740 0000003c 00000000              @...<.......

08028ad4 <CAN_EXT_LMO_13_Config>:
 8028ad4:	1ffe9760 00000009 00000000              `...........

08028ae0 <CAN_EXT_LMO_14_Config>:
 8028ae0:	1ffe9780 00000024 00000000              ....$.......

08028aec <CAN_EXT_LMO_15_Config>:
 8028aec:	1ffe97a0 00000025 00000000              ....%.......

08028af8 <CAN_EXT_LMO_16_Config>:
 8028af8:	1ffe97c0 00000026 00000000              ....&.......

08028b04 <CAN_EXT>:
 8028b04:	1ffe9488 48014400 08028a34 08028a44     .....D.H4...D...
 8028b14:	08028a50 08028a5c 08028a68 08028a74     P...\...h...t...
 8028b24:	08028a80 08028a8c 08028a98 08028aa4     ................
 8028b34:	08028ab0 08028abc 08028ac8 08028ad4     ................
 8028b44:	08028ae0 08028aec 08028af8 00000000     ................
	...
 8028b90:	08028a40 08028a0c 08028a14 08028a20     @........... ...
 8028ba0:	08028a28 00100200 00010100              (...........

08028bac <DI_NPN_pin_list>:
 8028bac:	48028f00 00000007 48028f00 00000006     ...H.......H....
 8028bbc:	48028f00 00000005 48028f00 00000004     ...H.......H....

08028bcc <DI_PNP_pin_list>:
 8028bcc:	48028e00 0000000f 48028e00 0000000e     ...H.......H....
 8028bdc:	48028e00 0000000d 48028e00 0000000c     ...H.......H....

08028bec <GROUP_IN_pin_list>:
 8028bec:	48028500 00000000 48028500 00000001     ...H.......H....
 8028bfc:	48028500 00000002 48028500 00000003     ...H.......H....

08028c0c <GROUP_OUT_pin_list>:
 8028c0c:	48028500 00000004 48028500 00000005     ...H.......H....
 8028c1c:	48028500 00000006 48028500 00000007     ...H.......H....

08028c2c <DC_INPUT>:
 8028c2c:	00000000 1ffea2b1 48028f00 0000000f     ...........H....

08028c3c <RES_IN1>:
 8028c3c:	00000000 1ffea2b2 48028f00 00000003     ...........H....

08028c4c <RES_IN2>:
 8028c4c:	00000000 1ffea2b3 48028e00 00000007     ...........H....

08028c5c <global_iclass_config>:
 8028c5c:	00000000                                ....

08028c60 <backgnd_rs_intr_handle>:
 8028c60:	00000010 0000003f 00000000              ....?.......

08028c6c <backgnd_config>:
 8028c6c:	00000005 00000000 00000008 5f444d43     ............CMD_
 8028c7c:	544f4f42 45534552 30305f54              BOOTRESET_00

Disassembly of section .ram_code:

1ffe8800 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect>:
/*
 * This function check the actual MCM register and modulate high side PWM output and
 * complementary PWM output for same leg. And keep other low side output is either high or low.
 */
void Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect(uint16_t mcm_val)
{
1ffe8800:	b580      	push	{r7, lr}
1ffe8802:	b084      	sub	sp, #16
1ffe8804:	af00      	add	r7, sp, #0
1ffe8806:	4603      	mov	r3, r0
1ffe8808:	80fb      	strh	r3, [r7, #6]
  uint8_t count;

  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
1ffe880a:	2300      	movs	r3, #0
1ffe880c:	73fb      	strb	r3, [r7, #15]
1ffe880e:	e040      	b.n	1ffe8892 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0x92>
  {
    /* If high side switch is ON */
    if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] == (mcm_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count]))
1ffe8810:	7bfb      	ldrb	r3, [r7, #15]
1ffe8812:	4a24      	ldr	r2, [pc, #144]	; (1ffe88a4 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa4>)
1ffe8814:	3308      	adds	r3, #8
1ffe8816:	005b      	lsls	r3, r3, #1
1ffe8818:	4413      	add	r3, r2
1ffe881a:	885a      	ldrh	r2, [r3, #2]
1ffe881c:	7bfb      	ldrb	r3, [r7, #15]
1ffe881e:	4921      	ldr	r1, [pc, #132]	; (1ffe88a4 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa4>)
1ffe8820:	3308      	adds	r3, #8
1ffe8822:	005b      	lsls	r3, r3, #1
1ffe8824:	440b      	add	r3, r1
1ffe8826:	8859      	ldrh	r1, [r3, #2]
1ffe8828:	88fb      	ldrh	r3, [r7, #6]
1ffe882a:	400b      	ands	r3, r1
1ffe882c:	b29b      	uxth	r3, r3
1ffe882e:	429a      	cmp	r2, r3
1ffe8830:	d10d      	bne.n	1ffe884e <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0x4e>
      /*
       * Dead Time Enable for Channel 1
       * Dead Time Enable for CC8yST1
       * Dead Time Enable for inverted CC8yST1
       */
      Motor0_BLDC_SCALAR_CCU8_EnableDeadTime(Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[count],(uint8_t)BLDC_SCALAR_PWM_BC_CH_MASK);
1ffe8832:	7bfb      	ldrb	r3, [r7, #15]
1ffe8834:	4a1c      	ldr	r2, [pc, #112]	; (1ffe88a8 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa8>)
1ffe8836:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1ffe883a:	210d      	movs	r1, #13
1ffe883c:	4618      	mov	r0, r3
1ffe883e:	f000 fc8f 	bl	1ffe9160 <__Motor0_BLDC_SCALAR_CCU8_EnableDeadTime_veneer>

      /*Set the compare flag to set the inverse duty*/
       Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_INVERSE_DUTY;
1ffe8842:	7bfb      	ldrb	r3, [r7, #15]
1ffe8844:	4a17      	ldr	r2, [pc, #92]	; (1ffe88a4 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa4>)
1ffe8846:	4413      	add	r3, r2
1ffe8848:	2203      	movs	r2, #3
1ffe884a:	739a      	strb	r2, [r3, #14]
1ffe884c:	e01e      	b.n	1ffe888c <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0x8c>
    } /* End of high side switch is ON */

    /* if low side switch is ON */
    else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
1ffe884e:	7bfb      	ldrb	r3, [r7, #15]
1ffe8850:	4a14      	ldr	r2, [pc, #80]	; (1ffe88a4 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa4>)
1ffe8852:	3308      	adds	r3, #8
1ffe8854:	005b      	lsls	r3, r3, #1
1ffe8856:	4413      	add	r3, r2
1ffe8858:	885b      	ldrh	r3, [r3, #2]
1ffe885a:	005a      	lsls	r2, r3, #1
                (mcm_val & ((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1)))
1ffe885c:	88f9      	ldrh	r1, [r7, #6]
1ffe885e:	7bfb      	ldrb	r3, [r7, #15]
1ffe8860:	4810      	ldr	r0, [pc, #64]	; (1ffe88a4 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa4>)
1ffe8862:	3308      	adds	r3, #8
1ffe8864:	005b      	lsls	r3, r3, #1
1ffe8866:	4403      	add	r3, r0
1ffe8868:	885b      	ldrh	r3, [r3, #2]
1ffe886a:	005b      	lsls	r3, r3, #1
1ffe886c:	400b      	ands	r3, r1
    else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
1ffe886e:	429a      	cmp	r2, r3
1ffe8870:	d10c      	bne.n	1ffe888c <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0x8c>
    {
      /* Disable dead time */
      Motor0_BLDC_SCALAR_CCU8_DisableDeadTime(Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[count],(uint8_t)BLDC_SCALAR_PWM_BC_CH_MASK);
1ffe8872:	7bfb      	ldrb	r3, [r7, #15]
1ffe8874:	4a0c      	ldr	r2, [pc, #48]	; (1ffe88a8 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa8>)
1ffe8876:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1ffe887a:	210d      	movs	r1, #13
1ffe887c:	4618      	mov	r0, r3
1ffe887e:	f000 fc8f 	bl	1ffe91a0 <__Motor0_BLDC_SCALAR_CCU8_DisableDeadTime_veneer>

      /*Set the compare flag to switch on completely*/
      Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_PERIOD;
1ffe8882:	7bfb      	ldrb	r3, [r7, #15]
1ffe8884:	4a07      	ldr	r2, [pc, #28]	; (1ffe88a4 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0xa4>)
1ffe8886:	4413      	add	r3, r2
1ffe8888:	2201      	movs	r2, #1
1ffe888a:	739a      	strb	r2, [r3, #14]
  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
1ffe888c:	7bfb      	ldrb	r3, [r7, #15]
1ffe888e:	3301      	adds	r3, #1
1ffe8890:	73fb      	strb	r3, [r7, #15]
1ffe8892:	7bfb      	ldrb	r3, [r7, #15]
1ffe8894:	2b02      	cmp	r3, #2
1ffe8896:	d9bb      	bls.n	1ffe8810 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod_SyncRect+0x10>
    {
      /*do nothing*/
    }
  }

}
1ffe8898:	bf00      	nop
1ffe889a:	bf00      	nop
1ffe889c:	3710      	adds	r7, #16
1ffe889e:	46bd      	mov	sp, r7
1ffe88a0:	bd80      	pop	{r7, pc}
1ffe88a2:	bf00      	nop
1ffe88a4:	1ffe9294 	.word	0x1ffe9294
1ffe88a8:	1ffe9228 	.word	0x1ffe9228

1ffe88ac <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod>:
/*
 * This function check the actual MCM register and modulate high
 * side PWM output and keep low side output either high or low.
 */
void Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod(uint16_t mcm_val)
{
1ffe88ac:	b480      	push	{r7}
1ffe88ae:	b085      	sub	sp, #20
1ffe88b0:	af00      	add	r7, sp, #0
1ffe88b2:	4603      	mov	r3, r0
1ffe88b4:	80fb      	strh	r3, [r7, #6]
  uint8_t count;

  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
1ffe88b6:	2300      	movs	r3, #0
1ffe88b8:	73fb      	strb	r3, [r7, #15]
1ffe88ba:	e030      	b.n	1ffe891e <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x72>
  {
    /* If high side switch is ON */
    if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] == (mcm_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count]))
1ffe88bc:	7bfb      	ldrb	r3, [r7, #15]
1ffe88be:	4a1d      	ldr	r2, [pc, #116]	; (1ffe8934 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x88>)
1ffe88c0:	3308      	adds	r3, #8
1ffe88c2:	005b      	lsls	r3, r3, #1
1ffe88c4:	4413      	add	r3, r2
1ffe88c6:	885a      	ldrh	r2, [r3, #2]
1ffe88c8:	7bfb      	ldrb	r3, [r7, #15]
1ffe88ca:	491a      	ldr	r1, [pc, #104]	; (1ffe8934 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x88>)
1ffe88cc:	3308      	adds	r3, #8
1ffe88ce:	005b      	lsls	r3, r3, #1
1ffe88d0:	440b      	add	r3, r1
1ffe88d2:	8859      	ldrh	r1, [r3, #2]
1ffe88d4:	88fb      	ldrh	r3, [r7, #6]
1ffe88d6:	400b      	ands	r3, r1
1ffe88d8:	b29b      	uxth	r3, r3
1ffe88da:	429a      	cmp	r2, r3
1ffe88dc:	d105      	bne.n	1ffe88ea <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x3e>
    {
      /*Set the compare flag to set the inverse duty*/
      Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_INVERSE_DUTY;
1ffe88de:	7bfb      	ldrb	r3, [r7, #15]
1ffe88e0:	4a14      	ldr	r2, [pc, #80]	; (1ffe8934 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x88>)
1ffe88e2:	4413      	add	r3, r2
1ffe88e4:	2203      	movs	r2, #3
1ffe88e6:	739a      	strb	r2, [r3, #14]
1ffe88e8:	e016      	b.n	1ffe8918 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x6c>

    } /* End of high side switch is ON */
    /* if low side switch is ON */
    else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
1ffe88ea:	7bfb      	ldrb	r3, [r7, #15]
1ffe88ec:	4a11      	ldr	r2, [pc, #68]	; (1ffe8934 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x88>)
1ffe88ee:	3308      	adds	r3, #8
1ffe88f0:	005b      	lsls	r3, r3, #1
1ffe88f2:	4413      	add	r3, r2
1ffe88f4:	885b      	ldrh	r3, [r3, #2]
1ffe88f6:	005a      	lsls	r2, r3, #1
                (mcm_val & ((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1)))
1ffe88f8:	88f9      	ldrh	r1, [r7, #6]
1ffe88fa:	7bfb      	ldrb	r3, [r7, #15]
1ffe88fc:	480d      	ldr	r0, [pc, #52]	; (1ffe8934 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x88>)
1ffe88fe:	3308      	adds	r3, #8
1ffe8900:	005b      	lsls	r3, r3, #1
1ffe8902:	4403      	add	r3, r0
1ffe8904:	885b      	ldrh	r3, [r3, #2]
1ffe8906:	005b      	lsls	r3, r3, #1
1ffe8908:	400b      	ands	r3, r1
    else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
1ffe890a:	429a      	cmp	r2, r3
1ffe890c:	d104      	bne.n	1ffe8918 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x6c>
    {
      /*Set the compare flag to switch on completely*/
      Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_PERIOD;
1ffe890e:	7bfb      	ldrb	r3, [r7, #15]
1ffe8910:	4a08      	ldr	r2, [pc, #32]	; (1ffe8934 <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x88>)
1ffe8912:	4413      	add	r3, r2
1ffe8914:	2201      	movs	r2, #1
1ffe8916:	739a      	strb	r2, [r3, #14]
  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
1ffe8918:	7bfb      	ldrb	r3, [r7, #15]
1ffe891a:	3301      	adds	r3, #1
1ffe891c:	73fb      	strb	r3, [r7, #15]
1ffe891e:	7bfb      	ldrb	r3, [r7, #15]
1ffe8920:	2b02      	cmp	r3, #2
1ffe8922:	d9cb      	bls.n	1ffe88bc <Motor0_BLDC_SCALAR_PWM_BC_HsImmediateMod+0x10>
    else
    {
      /*do nothing*/
    }
  }
}
1ffe8924:	bf00      	nop
1ffe8926:	bf00      	nop
1ffe8928:	3714      	adds	r7, #20
1ffe892a:	46bd      	mov	sp, r7
1ffe892c:	f85d 7b04 	ldr.w	r7, [sp], #4
1ffe8930:	4770      	bx	lr
1ffe8932:	bf00      	nop
1ffe8934:	1ffe9294 	.word	0x1ffe9294

1ffe8938 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod>:
/*
 * This function check the actual MCM register and modulate low side PWM output
 * and keep high side output either high or low.
 */
void Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod(uint16_t mcm_val)
{
1ffe8938:	b480      	push	{r7}
1ffe893a:	b085      	sub	sp, #20
1ffe893c:	af00      	add	r7, sp, #0
1ffe893e:	4603      	mov	r3, r0
1ffe8940:	80fb      	strh	r3, [r7, #6]
  uint8_t count;

  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
1ffe8942:	2300      	movs	r3, #0
1ffe8944:	73fb      	strb	r3, [r7, #15]
1ffe8946:	e030      	b.n	1ffe89aa <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x72>
  {
    /* If high side switch is ON */
    if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] == (mcm_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count]))
1ffe8948:	7bfb      	ldrb	r3, [r7, #15]
1ffe894a:	4a1d      	ldr	r2, [pc, #116]	; (1ffe89c0 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x88>)
1ffe894c:	3308      	adds	r3, #8
1ffe894e:	005b      	lsls	r3, r3, #1
1ffe8950:	4413      	add	r3, r2
1ffe8952:	885a      	ldrh	r2, [r3, #2]
1ffe8954:	7bfb      	ldrb	r3, [r7, #15]
1ffe8956:	491a      	ldr	r1, [pc, #104]	; (1ffe89c0 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x88>)
1ffe8958:	3308      	adds	r3, #8
1ffe895a:	005b      	lsls	r3, r3, #1
1ffe895c:	440b      	add	r3, r1
1ffe895e:	8859      	ldrh	r1, [r3, #2]
1ffe8960:	88fb      	ldrh	r3, [r7, #6]
1ffe8962:	400b      	ands	r3, r1
1ffe8964:	b29b      	uxth	r3, r3
1ffe8966:	429a      	cmp	r2, r3
1ffe8968:	d105      	bne.n	1ffe8976 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x3e>
    {
      /*Set the compare flag to switch off completely*/
      Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_ZERO;
1ffe896a:	7bfb      	ldrb	r3, [r7, #15]
1ffe896c:	4a14      	ldr	r2, [pc, #80]	; (1ffe89c0 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x88>)
1ffe896e:	4413      	add	r3, r2
1ffe8970:	2200      	movs	r2, #0
1ffe8972:	739a      	strb	r2, [r3, #14]
1ffe8974:	e016      	b.n	1ffe89a4 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x6c>

    } /* End of high side switch is ON */
    /* if low side switch is ON */
    else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
1ffe8976:	7bfb      	ldrb	r3, [r7, #15]
1ffe8978:	4a11      	ldr	r2, [pc, #68]	; (1ffe89c0 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x88>)
1ffe897a:	3308      	adds	r3, #8
1ffe897c:	005b      	lsls	r3, r3, #1
1ffe897e:	4413      	add	r3, r2
1ffe8980:	885b      	ldrh	r3, [r3, #2]
1ffe8982:	005a      	lsls	r2, r3, #1
                (mcm_val & ((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1)))
1ffe8984:	88f9      	ldrh	r1, [r7, #6]
1ffe8986:	7bfb      	ldrb	r3, [r7, #15]
1ffe8988:	480d      	ldr	r0, [pc, #52]	; (1ffe89c0 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x88>)
1ffe898a:	3308      	adds	r3, #8
1ffe898c:	005b      	lsls	r3, r3, #1
1ffe898e:	4403      	add	r3, r0
1ffe8990:	885b      	ldrh	r3, [r3, #2]
1ffe8992:	005b      	lsls	r3, r3, #1
1ffe8994:	400b      	ands	r3, r1
    else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
1ffe8996:	429a      	cmp	r2, r3
1ffe8998:	d104      	bne.n	1ffe89a4 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x6c>
    {
     /*Set the compare flag to set the duty*/
      Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_DUTY;
1ffe899a:	7bfb      	ldrb	r3, [r7, #15]
1ffe899c:	4a08      	ldr	r2, [pc, #32]	; (1ffe89c0 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x88>)
1ffe899e:	4413      	add	r3, r2
1ffe89a0:	2202      	movs	r2, #2
1ffe89a2:	739a      	strb	r2, [r3, #14]
  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
1ffe89a4:	7bfb      	ldrb	r3, [r7, #15]
1ffe89a6:	3301      	adds	r3, #1
1ffe89a8:	73fb      	strb	r3, [r7, #15]
1ffe89aa:	7bfb      	ldrb	r3, [r7, #15]
1ffe89ac:	2b02      	cmp	r3, #2
1ffe89ae:	d9cb      	bls.n	1ffe8948 <Motor0_BLDC_SCALAR_PWM_BC_LsImmediateMod+0x10>
    {
      /*do nothing*/
    }
  }

}
1ffe89b0:	bf00      	nop
1ffe89b2:	bf00      	nop
1ffe89b4:	3714      	adds	r7, #20
1ffe89b6:	46bd      	mov	sp, r7
1ffe89b8:	f85d 7b04 	ldr.w	r7, [sp], #4
1ffe89bc:	4770      	bx	lr
1ffe89be:	bf00      	nop
1ffe89c0:	1ffe9294 	.word	0x1ffe9294

1ffe89c4 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect>:
 * This function check the non conducting phase and modulate high side PWM output and complementary
 * PWM output for same leg based on the MCMS shadow register.
 * And keep other low side output is either high or low.
 */
void Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect(uint16_t mcm_val, uint16_t mcms_val)
{
1ffe89c4:	b580      	push	{r7, lr}
1ffe89c6:	b084      	sub	sp, #16
1ffe89c8:	af00      	add	r7, sp, #0
1ffe89ca:	4603      	mov	r3, r0
1ffe89cc:	460a      	mov	r2, r1
1ffe89ce:	80fb      	strh	r3, [r7, #6]
1ffe89d0:	4613      	mov	r3, r2
1ffe89d2:	80bb      	strh	r3, [r7, #4]
  uint8_t count;

  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
1ffe89d4:	2300      	movs	r3, #0
1ffe89d6:	73fb      	strb	r3, [r7, #15]
1ffe89d8:	e038      	b.n	1ffe8a4c <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x88>
  {
    /* if phase is not conducting in current cycle */
    if ((uint32_t)0 ==
          (mcm_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_bothside_compmask[count]))
1ffe89da:	7bfb      	ldrb	r3, [r7, #15]
1ffe89dc:	4a1f      	ldr	r2, [pc, #124]	; (1ffe8a5c <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x98>)
1ffe89de:	330c      	adds	r3, #12
1ffe89e0:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
    if ((uint32_t)0 ==
1ffe89e4:	88fb      	ldrh	r3, [r7, #6]
1ffe89e6:	4013      	ands	r3, r2
1ffe89e8:	b29b      	uxth	r3, r3
1ffe89ea:	2b00      	cmp	r3, #0
1ffe89ec:	d12b      	bne.n	1ffe8a46 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x82>
    {
      /* If high side switch is ON */
      if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] ==
1ffe89ee:	7bfb      	ldrb	r3, [r7, #15]
1ffe89f0:	4a1a      	ldr	r2, [pc, #104]	; (1ffe8a5c <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x98>)
1ffe89f2:	3308      	adds	r3, #8
1ffe89f4:	005b      	lsls	r3, r3, #1
1ffe89f6:	4413      	add	r3, r2
1ffe89f8:	885a      	ldrh	r2, [r3, #2]
            (mcms_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count]))
1ffe89fa:	7bfb      	ldrb	r3, [r7, #15]
1ffe89fc:	4917      	ldr	r1, [pc, #92]	; (1ffe8a5c <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x98>)
1ffe89fe:	3308      	adds	r3, #8
1ffe8a00:	005b      	lsls	r3, r3, #1
1ffe8a02:	440b      	add	r3, r1
1ffe8a04:	8859      	ldrh	r1, [r3, #2]
      if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] ==
1ffe8a06:	88bb      	ldrh	r3, [r7, #4]
1ffe8a08:	400b      	ands	r3, r1
1ffe8a0a:	b29b      	uxth	r3, r3
1ffe8a0c:	429a      	cmp	r2, r3
1ffe8a0e:	d10d      	bne.n	1ffe8a2c <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x68>
        /*
         * Dead Time Enable for Channel 1
         * Dead Time Enable for CC8yST1
         * Dead Time Enable for inverted CC8yST1
         */
        Motor0_BLDC_SCALAR_CCU8_EnableDeadTime(Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[count],(uint8_t)BLDC_SCALAR_PWM_BC_CH_MASK);
1ffe8a10:	7bfb      	ldrb	r3, [r7, #15]
1ffe8a12:	4a13      	ldr	r2, [pc, #76]	; (1ffe8a60 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x9c>)
1ffe8a14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1ffe8a18:	210d      	movs	r1, #13
1ffe8a1a:	4618      	mov	r0, r3
1ffe8a1c:	f000 fba0 	bl	1ffe9160 <__Motor0_BLDC_SCALAR_CCU8_EnableDeadTime_veneer>

        /*Set the compare flag to set the inverse duty*/
        Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_INVERSE_DUTY;
1ffe8a20:	7bfb      	ldrb	r3, [r7, #15]
1ffe8a22:	4a0e      	ldr	r2, [pc, #56]	; (1ffe8a5c <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x98>)
1ffe8a24:	4413      	add	r3, r2
1ffe8a26:	2203      	movs	r2, #3
1ffe8a28:	739a      	strb	r2, [r3, #14]
1ffe8a2a:	e00c      	b.n	1ffe8a46 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x82>
      }
      /* if low side switch is ON*/
      else
      {
        /* Disable dead time */
        Motor0_BLDC_SCALAR_CCU8_DisableDeadTime(Motor0_BLDC_SCALAR_CCU8_PWM_Config.phase_ptr[count],(uint8_t)BLDC_SCALAR_PWM_BC_CH_MASK);
1ffe8a2c:	7bfb      	ldrb	r3, [r7, #15]
1ffe8a2e:	4a0c      	ldr	r2, [pc, #48]	; (1ffe8a60 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x9c>)
1ffe8a30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
1ffe8a34:	210d      	movs	r1, #13
1ffe8a36:	4618      	mov	r0, r3
1ffe8a38:	f000 fbb2 	bl	1ffe91a0 <__Motor0_BLDC_SCALAR_CCU8_DisableDeadTime_veneer>

        /*Set the compare flag to switch on completely*/
        Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_PERIOD;
1ffe8a3c:	7bfb      	ldrb	r3, [r7, #15]
1ffe8a3e:	4a07      	ldr	r2, [pc, #28]	; (1ffe8a5c <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x98>)
1ffe8a40:	4413      	add	r3, r2
1ffe8a42:	2201      	movs	r2, #1
1ffe8a44:	739a      	strb	r2, [r3, #14]
  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
1ffe8a46:	7bfb      	ldrb	r3, [r7, #15]
1ffe8a48:	3301      	adds	r3, #1
1ffe8a4a:	73fb      	strb	r3, [r7, #15]
1ffe8a4c:	7bfb      	ldrb	r3, [r7, #15]
1ffe8a4e:	2b02      	cmp	r3, #2
1ffe8a50:	d9c3      	bls.n	1ffe89da <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod_SyncRect+0x16>
      }
    }
  }
}
1ffe8a52:	bf00      	nop
1ffe8a54:	bf00      	nop
1ffe8a56:	3710      	adds	r7, #16
1ffe8a58:	46bd      	mov	sp, r7
1ffe8a5a:	bd80      	pop	{r7, pc}
1ffe8a5c:	1ffe9294 	.word	0x1ffe9294
1ffe8a60:	1ffe9228 	.word	0x1ffe9228

1ffe8a64 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod>:
/*
 * This function check the non conducting phase and modulate high side PWM output and keep low side
 * output either high or low based on the MCMS shadow register.
 */
void Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod(uint16_t mcm_val, uint16_t mcms_val)
{
1ffe8a64:	b480      	push	{r7}
1ffe8a66:	b085      	sub	sp, #20
1ffe8a68:	af00      	add	r7, sp, #0
1ffe8a6a:	4603      	mov	r3, r0
1ffe8a6c:	460a      	mov	r2, r1
1ffe8a6e:	80fb      	strh	r3, [r7, #6]
1ffe8a70:	4613      	mov	r3, r2
1ffe8a72:	80bb      	strh	r3, [r7, #4]
  uint8_t count;

  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
1ffe8a74:	2300      	movs	r3, #0
1ffe8a76:	73fb      	strb	r3, [r7, #15]
1ffe8a78:	e028      	b.n	1ffe8acc <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x68>
  {
    /* if phase is not conducting */
    if ((uint32_t)0 ==
          (mcm_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_bothside_compmask[count]))
1ffe8a7a:	7bfb      	ldrb	r3, [r7, #15]
1ffe8a7c:	4a18      	ldr	r2, [pc, #96]	; (1ffe8ae0 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x7c>)
1ffe8a7e:	330c      	adds	r3, #12
1ffe8a80:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
    if ((uint32_t)0 ==
1ffe8a84:	88fb      	ldrh	r3, [r7, #6]
1ffe8a86:	4013      	ands	r3, r2
1ffe8a88:	b29b      	uxth	r3, r3
1ffe8a8a:	2b00      	cmp	r3, #0
1ffe8a8c:	d11b      	bne.n	1ffe8ac6 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x62>
    {
      /* If high side switch is ON */
      if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] ==
1ffe8a8e:	7bfb      	ldrb	r3, [r7, #15]
1ffe8a90:	4a13      	ldr	r2, [pc, #76]	; (1ffe8ae0 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x7c>)
1ffe8a92:	3308      	adds	r3, #8
1ffe8a94:	005b      	lsls	r3, r3, #1
1ffe8a96:	4413      	add	r3, r2
1ffe8a98:	885a      	ldrh	r2, [r3, #2]
            (mcms_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count]))
1ffe8a9a:	7bfb      	ldrb	r3, [r7, #15]
1ffe8a9c:	4910      	ldr	r1, [pc, #64]	; (1ffe8ae0 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x7c>)
1ffe8a9e:	3308      	adds	r3, #8
1ffe8aa0:	005b      	lsls	r3, r3, #1
1ffe8aa2:	440b      	add	r3, r1
1ffe8aa4:	8859      	ldrh	r1, [r3, #2]
      if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] ==
1ffe8aa6:	88bb      	ldrh	r3, [r7, #4]
1ffe8aa8:	400b      	ands	r3, r1
1ffe8aaa:	b29b      	uxth	r3, r3
1ffe8aac:	429a      	cmp	r2, r3
1ffe8aae:	d105      	bne.n	1ffe8abc <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x58>
      {
        Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_INVERSE_DUTY;
1ffe8ab0:	7bfb      	ldrb	r3, [r7, #15]
1ffe8ab2:	4a0b      	ldr	r2, [pc, #44]	; (1ffe8ae0 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x7c>)
1ffe8ab4:	4413      	add	r3, r2
1ffe8ab6:	2203      	movs	r2, #3
1ffe8ab8:	739a      	strb	r2, [r3, #14]
1ffe8aba:	e004      	b.n	1ffe8ac6 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x62>
      }
      /* if low side switch is ON */
      else
      {
        Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_PERIOD;
1ffe8abc:	7bfb      	ldrb	r3, [r7, #15]
1ffe8abe:	4a08      	ldr	r2, [pc, #32]	; (1ffe8ae0 <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x7c>)
1ffe8ac0:	4413      	add	r3, r2
1ffe8ac2:	2201      	movs	r2, #1
1ffe8ac4:	739a      	strb	r2, [r3, #14]
  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
1ffe8ac6:	7bfb      	ldrb	r3, [r7, #15]
1ffe8ac8:	3301      	adds	r3, #1
1ffe8aca:	73fb      	strb	r3, [r7, #15]
1ffe8acc:	7bfb      	ldrb	r3, [r7, #15]
1ffe8ace:	2b02      	cmp	r3, #2
1ffe8ad0:	d9d3      	bls.n	1ffe8a7a <Motor0_BLDC_SCALAR_PWM_BC_HsShadowMod+0x16>
      }
    }
  }
}
1ffe8ad2:	bf00      	nop
1ffe8ad4:	bf00      	nop
1ffe8ad6:	3714      	adds	r7, #20
1ffe8ad8:	46bd      	mov	sp, r7
1ffe8ada:	f85d 7b04 	ldr.w	r7, [sp], #4
1ffe8ade:	4770      	bx	lr
1ffe8ae0:	1ffe9294 	.word	0x1ffe9294

1ffe8ae4 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod>:
/*
 * This function check the non conducting phase and modulate low side PWM output and keep high side
 * output either high or low based on the MCMS shadow register.
 */
void Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod(uint16_t mcm_val, uint16_t mcms_val)
{
1ffe8ae4:	b480      	push	{r7}
1ffe8ae6:	b085      	sub	sp, #20
1ffe8ae8:	af00      	add	r7, sp, #0
1ffe8aea:	4603      	mov	r3, r0
1ffe8aec:	460a      	mov	r2, r1
1ffe8aee:	80fb      	strh	r3, [r7, #6]
1ffe8af0:	4613      	mov	r3, r2
1ffe8af2:	80bb      	strh	r3, [r7, #4]
  uint8_t count;

  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
1ffe8af4:	2300      	movs	r3, #0
1ffe8af6:	73fb      	strb	r3, [r7, #15]
1ffe8af8:	e03a      	b.n	1ffe8b70 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0x8c>
  {
    /* if phase is not conducting */
    if ((uint32_t)0 ==
          (mcm_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_bothside_compmask[count]))
1ffe8afa:	7bfb      	ldrb	r3, [r7, #15]
1ffe8afc:	4a21      	ldr	r2, [pc, #132]	; (1ffe8b84 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0xa0>)
1ffe8afe:	330c      	adds	r3, #12
1ffe8b00:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
    if ((uint32_t)0 ==
1ffe8b04:	88fb      	ldrh	r3, [r7, #6]
1ffe8b06:	4013      	ands	r3, r2
1ffe8b08:	b29b      	uxth	r3, r3
1ffe8b0a:	2b00      	cmp	r3, #0
1ffe8b0c:	d12d      	bne.n	1ffe8b6a <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0x86>
    {
      /* If high side switch is ON */
      if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] ==
1ffe8b0e:	7bfb      	ldrb	r3, [r7, #15]
1ffe8b10:	4a1c      	ldr	r2, [pc, #112]	; (1ffe8b84 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0xa0>)
1ffe8b12:	3308      	adds	r3, #8
1ffe8b14:	005b      	lsls	r3, r3, #1
1ffe8b16:	4413      	add	r3, r2
1ffe8b18:	885a      	ldrh	r2, [r3, #2]
            (mcms_val & (uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count]))
1ffe8b1a:	7bfb      	ldrb	r3, [r7, #15]
1ffe8b1c:	4919      	ldr	r1, [pc, #100]	; (1ffe8b84 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0xa0>)
1ffe8b1e:	3308      	adds	r3, #8
1ffe8b20:	005b      	lsls	r3, r3, #1
1ffe8b22:	440b      	add	r3, r1
1ffe8b24:	8859      	ldrh	r1, [r3, #2]
      if (Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] ==
1ffe8b26:	88bb      	ldrh	r3, [r7, #4]
1ffe8b28:	400b      	ands	r3, r1
1ffe8b2a:	b29b      	uxth	r3, r3
1ffe8b2c:	429a      	cmp	r2, r3
1ffe8b2e:	d105      	bne.n	1ffe8b3c <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0x58>
      {
        Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_ZERO;
1ffe8b30:	7bfb      	ldrb	r3, [r7, #15]
1ffe8b32:	4a14      	ldr	r2, [pc, #80]	; (1ffe8b84 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0xa0>)
1ffe8b34:	4413      	add	r3, r2
1ffe8b36:	2200      	movs	r2, #0
1ffe8b38:	739a      	strb	r2, [r3, #14]
1ffe8b3a:	e016      	b.n	1ffe8b6a <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0x86>
      }
      /* if low side switch is ON */
      else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
1ffe8b3c:	7bfb      	ldrb	r3, [r7, #15]
1ffe8b3e:	4a11      	ldr	r2, [pc, #68]	; (1ffe8b84 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0xa0>)
1ffe8b40:	3308      	adds	r3, #8
1ffe8b42:	005b      	lsls	r3, r3, #1
1ffe8b44:	4413      	add	r3, r2
1ffe8b46:	885b      	ldrh	r3, [r3, #2]
1ffe8b48:	005a      	lsls	r2, r3, #1
            (mcms_val & ((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1)))
1ffe8b4a:	88b9      	ldrh	r1, [r7, #4]
1ffe8b4c:	7bfb      	ldrb	r3, [r7, #15]
1ffe8b4e:	480d      	ldr	r0, [pc, #52]	; (1ffe8b84 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0xa0>)
1ffe8b50:	3308      	adds	r3, #8
1ffe8b52:	005b      	lsls	r3, r3, #1
1ffe8b54:	4403      	add	r3, r0
1ffe8b56:	885b      	ldrh	r3, [r3, #2]
1ffe8b58:	005b      	lsls	r3, r3, #1
1ffe8b5a:	400b      	ands	r3, r1
      else if (((uint32_t)Motor0_BLDC_SCALAR_PWM_BC.ph_mcpatt_compmask[count] << (uint32_t)1) ==
1ffe8b5c:	429a      	cmp	r2, r3
1ffe8b5e:	d104      	bne.n	1ffe8b6a <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0x86>
      {
        Motor0_BLDC_SCALAR_PWM_BC.ph_cmpflag[count] = PWM_BC_COMPARE_DUTY;
1ffe8b60:	7bfb      	ldrb	r3, [r7, #15]
1ffe8b62:	4a08      	ldr	r2, [pc, #32]	; (1ffe8b84 <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0xa0>)
1ffe8b64:	4413      	add	r3, r2
1ffe8b66:	2202      	movs	r2, #2
1ffe8b68:	739a      	strb	r2, [r3, #14]
  for (count = (uint8_t)0; count < CCU8_MAXPHASE_COUNT; count++)
1ffe8b6a:	7bfb      	ldrb	r3, [r7, #15]
1ffe8b6c:	3301      	adds	r3, #1
1ffe8b6e:	73fb      	strb	r3, [r7, #15]
1ffe8b70:	7bfb      	ldrb	r3, [r7, #15]
1ffe8b72:	2b02      	cmp	r3, #2
1ffe8b74:	d9c1      	bls.n	1ffe8afa <Motor0_BLDC_SCALAR_PWM_BC_LsShadowMod+0x16>
      {

      }
    }
  }
}
1ffe8b76:	bf00      	nop
1ffe8b78:	bf00      	nop
1ffe8b7a:	3714      	adds	r7, #20
1ffe8b7c:	46bd      	mov	sp, r7
1ffe8b7e:	f85d 7b04 	ldr.w	r7, [sp], #4
1ffe8b82:	4770      	bx	lr
1ffe8b84:	1ffe9294 	.word	0x1ffe9294

1ffe8b88 <CCU80_0_IRQHandler>:
 * Control loop interrupt is based on the PWM frequency.\n
 * This ISR executes the control scheme (PI), direction control, current and voltage reading,
 * voltage compensation and updates the duty cycle of the PWM.
 */
RAM_ATTRIBUTE void Motor0_BLDC_SCALAR_ControlLoop_ISR(void)
{
1ffe8b88:	b580      	push	{r7, lr}
1ffe8b8a:	b084      	sub	sp, #16
1ffe8b8c:	af00      	add	r7, sp, #0
  int32_t voltage_output = 0;  /* output of the control scheme */
1ffe8b8e:	2300      	movs	r3, #0
1ffe8b90:	60fb      	str	r3, [r7, #12]
#endif /* end of #if ((MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_AVERAGE_MEASUREMENT == 1U) || (MOTOR0_BLDC_SCALAR_ENABLE_AVERAGE_CURRENT_USING_IDC_LINK == 1U)) */

  /***************** Current Reading ***************************************/
  #if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U)
  /* Get the IDC Link instantaneous current value */
  Motor0_BLDC_SCALAR_GetCurrentValue(&direct_current);
1ffe8b92:	1d3b      	adds	r3, r7, #4
1ffe8b94:	4618      	mov	r0, r3
1ffe8b96:	f000 faf7 	bl	1ffe9188 <__Motor0_BLDC_SCALAR_GetCurrentValue_veneer>
  Motor0_BLDC_SCALAR.motor_current = Motor0_BLDC_SCALAR.motor_set_direction * direct_current;
1ffe8b9a:	4b36      	ldr	r3, [pc, #216]	; (1ffe8c74 <CCU80_0_IRQHandler+0xec>)
1ffe8b9c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
1ffe8b9e:	687a      	ldr	r2, [r7, #4]
1ffe8ba0:	fb02 f303 	mul.w	r3, r2, r3
1ffe8ba4:	4a33      	ldr	r2, [pc, #204]	; (1ffe8c74 <CCU80_0_IRQHandler+0xec>)
1ffe8ba6:	6713      	str	r3, [r2, #112]	; 0x70
  #endif  /* end of #if(MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U) */

  #if ((MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_AVERAGE_MEASUREMENT == 1U) || (MOTOR0_BLDC_SCALAR_ENABLE_AVERAGE_CURRENT_USING_IDC_LINK == 1U))
  /* Get the IDC Link average current value */
  Motor0_BLDC_SCALAR_GetAverageCurrentValue(&avg_current);
1ffe8ba8:	463b      	mov	r3, r7
1ffe8baa:	4618      	mov	r0, r3
1ffe8bac:	f000 fad4 	bl	1ffe9158 <__Motor0_BLDC_SCALAR_GetAverageCurrentValue_veneer>
  Motor0_BLDC_SCALAR.motor_average_current = Motor0_BLDC_SCALAR.motor_set_direction * avg_current;
1ffe8bb0:	4b30      	ldr	r3, [pc, #192]	; (1ffe8c74 <CCU80_0_IRQHandler+0xec>)
1ffe8bb2:	6f9b      	ldr	r3, [r3, #120]	; 0x78
1ffe8bb4:	683a      	ldr	r2, [r7, #0]
1ffe8bb6:	fb02 f303 	mul.w	r3, r2, r3
1ffe8bba:	4a2e      	ldr	r2, [pc, #184]	; (1ffe8c74 <CCU80_0_IRQHandler+0xec>)
1ffe8bbc:	6753      	str	r3, [r2, #116]	; 0x74
  #endif /* end of #if ((MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_AVERAGE_MEASUREMENT == 1U) || (MOTOR0_BLDC_SCALAR_ENABLE_AVERAGE_CURRENT_USING_IDC_LINK == 1U))*/

  #if (MOTOR0_BLDC_SCALAR_ENABLE_OVER_CURRENT == 1U)
  /* Over-current detection timing */
  if (Motor0_BLDC_SCALAR.overcurrent_counter != 0U)
1ffe8bbe:	4b2d      	ldr	r3, [pc, #180]	; (1ffe8c74 <CCU80_0_IRQHandler+0xec>)
1ffe8bc0:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
1ffe8bc4:	2b00      	cmp	r3, #0
1ffe8bc6:	d006      	beq.n	1ffe8bd6 <CCU80_0_IRQHandler+0x4e>
  {
    Motor0_BLDC_SCALAR.overcurrent_counter--;
1ffe8bc8:	4b2a      	ldr	r3, [pc, #168]	; (1ffe8c74 <CCU80_0_IRQHandler+0xec>)
1ffe8bca:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
1ffe8bce:	3b01      	subs	r3, #1
1ffe8bd0:	4a28      	ldr	r2, [pc, #160]	; (1ffe8c74 <CCU80_0_IRQHandler+0xec>)
1ffe8bd2:	f8c2 30ac 	str.w	r3, [r2, #172]	; 0xac
#if (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_VOLTAGE_CTRL)
  /* Voltage control */
  Motor0_BLDC_SCALAR_VoltageControlScheme(&voltage_output);
#elif (MOTOR0_BLDC_SCALAR_CTRL_SCHEME == BLDC_SCALAR_SPEED_CTRL)
  /* Speed control */
  Motor0_BLDC_SCALAR.speedcontrol_rate_counter++;
1ffe8bd6:	4b27      	ldr	r3, [pc, #156]	; (1ffe8c74 <CCU80_0_IRQHandler+0xec>)
1ffe8bd8:	f893 30c3 	ldrb.w	r3, [r3, #195]	; 0xc3
1ffe8bdc:	3301      	adds	r3, #1
1ffe8bde:	b2da      	uxtb	r2, r3
1ffe8be0:	4b24      	ldr	r3, [pc, #144]	; (1ffe8c74 <CCU80_0_IRQHandler+0xec>)
1ffe8be2:	f883 20c3 	strb.w	r2, [r3, #195]	; 0xc3
  if (Motor0_BLDC_SCALAR.speedcontrol_rate_counter >= Motor0_BLDC_SCALAR.speedcontrol_rate)
1ffe8be6:	4b23      	ldr	r3, [pc, #140]	; (1ffe8c74 <CCU80_0_IRQHandler+0xec>)
1ffe8be8:	f893 20c3 	ldrb.w	r2, [r3, #195]	; 0xc3
1ffe8bec:	4b21      	ldr	r3, [pc, #132]	; (1ffe8c74 <CCU80_0_IRQHandler+0xec>)
1ffe8bee:	f893 30c2 	ldrb.w	r3, [r3, #194]	; 0xc2
1ffe8bf2:	429a      	cmp	r2, r3
1ffe8bf4:	d309      	bcc.n	1ffe8c0a <CCU80_0_IRQHandler+0x82>
  {
    Motor0_BLDC_SCALAR_SpeedControlScheme(&voltage_output);
1ffe8bf6:	f107 030c 	add.w	r3, r7, #12
1ffe8bfa:	4618      	mov	r0, r3
1ffe8bfc:	f000 faa4 	bl	1ffe9148 <__Motor0_BLDC_SCALAR_SpeedControlScheme_veneer>
    Motor0_BLDC_SCALAR.speedcontrol_rate_counter = 0U;
1ffe8c00:	4b1c      	ldr	r3, [pc, #112]	; (1ffe8c74 <CCU80_0_IRQHandler+0xec>)
1ffe8c02:	2200      	movs	r2, #0
1ffe8c04:	f883 20c3 	strb.w	r2, [r3, #195]	; 0xc3
1ffe8c08:	e002      	b.n	1ffe8c10 <CCU80_0_IRQHandler+0x88>
  }
  else
  {
    voltage_output = Motor0_BLDC_SCALAR_SpeedControl_PI.uk;
1ffe8c0a:	4b1b      	ldr	r3, [pc, #108]	; (1ffe8c78 <CCU80_0_IRQHandler+0xf0>)
1ffe8c0c:	681b      	ldr	r3, [r3, #0]
1ffe8c0e:	60fb      	str	r3, [r7, #12]

  /*
   * Calculate absolute value of amplitude and
   * if seamless bi-directional control is enabled, change the direction of the rotation at the appropriate time.
   */
  Motor0_BLDC_SCALAR_DirectionControl(voltage_output, &duty_cycle);
1ffe8c10:	68fb      	ldr	r3, [r7, #12]
1ffe8c12:	f107 0208 	add.w	r2, r7, #8
1ffe8c16:	4611      	mov	r1, r2
1ffe8c18:	4618      	mov	r0, r3
1ffe8c1a:	f000 fa6d 	bl	1ffe90f8 <__Motor0_BLDC_SCALAR_DirectionControl_veneer>
#if ((MOTOR0_BLDC_SCALAR_MODULATION == BLDC_SCALAR_PWM_HIGHSIDE_SYNCHRECTI) || (MOTOR0_BLDC_SCALAR_MODULATION == BLDC_SCALAR_PWM_HIGHSIDE))
  /*
   * To avoid discharging of the bootstrap capacitor in high side modulation,
   * apply 100% voltage if voltage amplitude is greater than amplitude threshold limit
   */
  if (duty_cycle > Motor0_BLDC_SCALAR.amplitude_high_threshold)
1ffe8c1e:	4b15      	ldr	r3, [pc, #84]	; (1ffe8c74 <CCU80_0_IRQHandler+0xec>)
1ffe8c20:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
1ffe8c24:	68bb      	ldr	r3, [r7, #8]
1ffe8c26:	429a      	cmp	r2, r3
1ffe8c28:	d203      	bcs.n	1ffe8c32 <CCU80_0_IRQHandler+0xaa>
  {
    duty_cycle = Motor0_BLDC_SCALAR.max_amplitude;
1ffe8c2a:	4b12      	ldr	r3, [pc, #72]	; (1ffe8c74 <CCU80_0_IRQHandler+0xec>)
1ffe8c2c:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
1ffe8c30:	60bb      	str	r3, [r7, #8]
  }
#endif  /* end of #if ((MOTOR0_BLDC_SCALAR_MODULATION == BLDC_SCALAR_PWM_HIGHSIDE_SYNCHRECTI) || (MOTOR0_BLDC_SCALAR_MODULATION == BLDC_SCALAR_PWM_HIGHSIDE)) */

  /* max_amplitude is decided by MOTOR0_BLDC_SCALAR_MAX_AMPLITUDE */
  if (duty_cycle > Motor0_BLDC_SCALAR.max_amplitude)
1ffe8c32:	4b10      	ldr	r3, [pc, #64]	; (1ffe8c74 <CCU80_0_IRQHandler+0xec>)
1ffe8c34:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
1ffe8c38:	68bb      	ldr	r3, [r7, #8]
1ffe8c3a:	429a      	cmp	r2, r3
1ffe8c3c:	d203      	bcs.n	1ffe8c46 <CCU80_0_IRQHandler+0xbe>
  {
    duty_cycle = Motor0_BLDC_SCALAR.max_amplitude;
1ffe8c3e:	4b0d      	ldr	r3, [pc, #52]	; (1ffe8c74 <CCU80_0_IRQHandler+0xec>)
1ffe8c40:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
1ffe8c44:	60bb      	str	r3, [r7, #8]
  }
  /* min_amplitude is decided by MOTOR0_BLDC_SCALAR_MIN_AMPLITUDE */
  if (duty_cycle < Motor0_BLDC_SCALAR.min_amplitude)
1ffe8c46:	4b0b      	ldr	r3, [pc, #44]	; (1ffe8c74 <CCU80_0_IRQHandler+0xec>)
1ffe8c48:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
1ffe8c4c:	68bb      	ldr	r3, [r7, #8]
1ffe8c4e:	429a      	cmp	r2, r3
1ffe8c50:	d901      	bls.n	1ffe8c56 <CCU80_0_IRQHandler+0xce>
  {
    duty_cycle = 0U;
1ffe8c52:	2300      	movs	r3, #0
1ffe8c54:	60bb      	str	r3, [r7, #8]
  }
  Motor0_BLDC_SCALAR.amplitude = duty_cycle;
1ffe8c56:	68bb      	ldr	r3, [r7, #8]
1ffe8c58:	4a06      	ldr	r2, [pc, #24]	; (1ffe8c74 <CCU80_0_IRQHandler+0xec>)
1ffe8c5a:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  /* Update the CCU8 compare values */
  Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate((uint16_t)Motor0_BLDC_SCALAR.amplitude);
1ffe8c5e:	4b05      	ldr	r3, [pc, #20]	; (1ffe8c74 <CCU80_0_IRQHandler+0xec>)
1ffe8c60:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
1ffe8c64:	b29b      	uxth	r3, r3
1ffe8c66:	4618      	mov	r0, r3
1ffe8c68:	f000 fa4e 	bl	1ffe9108 <__Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate_veneer>

}
1ffe8c6c:	bf00      	nop
1ffe8c6e:	3710      	adds	r7, #16
1ffe8c70:	46bd      	mov	sp, r7
1ffe8c72:	bd80      	pop	{r7, pc}
1ffe8c74:	1ffe9350 	.word	0x1ffe9350
1ffe8c78:	1ffe9250 	.word	0x1ffe9250

1ffe8c7c <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation>:
{
1ffe8c7c:	b480      	push	{r7}
1ffe8c7e:	b083      	sub	sp, #12
1ffe8c80:	af00      	add	r7, sp, #0
1ffe8c82:	6078      	str	r0, [r7, #4]
1ffe8c84:	6039      	str	r1, [r7, #0]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum -= Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex];
1ffe8c86:	4b27      	ldr	r3, [pc, #156]	; (1ffe8d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8c88:	6a1a      	ldr	r2, [r3, #32]
1ffe8c8a:	4b26      	ldr	r3, [pc, #152]	; (1ffe8d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8c8c:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
1ffe8c90:	4619      	mov	r1, r3
1ffe8c92:	4b24      	ldr	r3, [pc, #144]	; (1ffe8d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8c94:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
1ffe8c98:	1ad3      	subs	r3, r2, r3
1ffe8c9a:	4a22      	ldr	r2, [pc, #136]	; (1ffe8d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8c9c:	6213      	str	r3, [r2, #32]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex] = capval;
1ffe8c9e:	4b21      	ldr	r3, [pc, #132]	; (1ffe8d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8ca0:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
1ffe8ca4:	4619      	mov	r1, r3
1ffe8ca6:	4a1f      	ldr	r2, [pc, #124]	; (1ffe8d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8ca8:	687b      	ldr	r3, [r7, #4]
1ffe8caa:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum += Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex];
1ffe8cae:	4b1d      	ldr	r3, [pc, #116]	; (1ffe8d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8cb0:	6a1a      	ldr	r2, [r3, #32]
1ffe8cb2:	4b1c      	ldr	r3, [pc, #112]	; (1ffe8d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8cb4:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
1ffe8cb8:	4619      	mov	r1, r3
1ffe8cba:	4b1a      	ldr	r3, [pc, #104]	; (1ffe8d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8cbc:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
1ffe8cc0:	4413      	add	r3, r2
1ffe8cc2:	4a18      	ldr	r2, [pc, #96]	; (1ffe8d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8cc4:	6213      	str	r3, [r2, #32]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex++;
1ffe8cc6:	4b17      	ldr	r3, [pc, #92]	; (1ffe8d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8cc8:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
1ffe8ccc:	3301      	adds	r3, #1
1ffe8cce:	b2da      	uxtb	r2, r3
1ffe8cd0:	4b14      	ldr	r3, [pc, #80]	; (1ffe8d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8cd2:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  if (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex > BLDC_SCALAR_SPEED_POS_HALL_SPEEDACCUMLIMITCHECK)
1ffe8cd6:	4b13      	ldr	r3, [pc, #76]	; (1ffe8d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8cd8:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
1ffe8cdc:	2b05      	cmp	r3, #5
1ffe8cde:	d906      	bls.n	1ffe8cee <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x72>
    Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex = 0U;
1ffe8ce0:	4b10      	ldr	r3, [pc, #64]	; (1ffe8d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8ce2:	2200      	movs	r2, #0
1ffe8ce4:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
    Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedcheck = 1U;
1ffe8ce8:	4b0e      	ldr	r3, [pc, #56]	; (1ffe8d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8cea:	2201      	movs	r2, #1
1ffe8cec:	61da      	str	r2, [r3, #28]
  if (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedcheck == 1U)
1ffe8cee:	4b0d      	ldr	r3, [pc, #52]	; (1ffe8d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8cf0:	69db      	ldr	r3, [r3, #28]
1ffe8cf2:	2b01      	cmp	r3, #1
1ffe8cf4:	d10c      	bne.n	1ffe8d10 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x94>
    if (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum > 0U)
1ffe8cf6:	4b0b      	ldr	r3, [pc, #44]	; (1ffe8d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8cf8:	6a1b      	ldr	r3, [r3, #32]
1ffe8cfa:	2b00      	cmp	r3, #0
1ffe8cfc:	d00b      	beq.n	1ffe8d16 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x9a>
      *speed = (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speed_constant) / (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum);
1ffe8cfe:	4b09      	ldr	r3, [pc, #36]	; (1ffe8d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8d00:	6a5a      	ldr	r2, [r3, #36]	; 0x24
1ffe8d02:	4b08      	ldr	r3, [pc, #32]	; (1ffe8d24 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8d04:	6a1b      	ldr	r3, [r3, #32]
1ffe8d06:	fbb2 f2f3 	udiv	r2, r2, r3
1ffe8d0a:	683b      	ldr	r3, [r7, #0]
1ffe8d0c:	601a      	str	r2, [r3, #0]
}
1ffe8d0e:	e002      	b.n	1ffe8d16 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x9a>
    *speed = 0U;
1ffe8d10:	683b      	ldr	r3, [r7, #0]
1ffe8d12:	2200      	movs	r2, #0
1ffe8d14:	601a      	str	r2, [r3, #0]
}
1ffe8d16:	bf00      	nop
1ffe8d18:	370c      	adds	r7, #12
1ffe8d1a:	46bd      	mov	sp, r7
1ffe8d1c:	f85d 7b04 	ldr.w	r7, [sp], #4
1ffe8d20:	4770      	bx	lr
1ffe8d22:	bf00      	nop
1ffe8d24:	1ffe92bc 	.word	0x1ffe92bc

1ffe8d28 <POSIF0_0_IRQHandler>:
{
1ffe8d28:	b580      	push	{r7, lr}
1ffe8d2a:	af00      	add	r7, sp, #0
  if (Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetEventStatus(XMC_POSIF_IRQ_EVENT_WHE) == (uint8_t)1)
1ffe8d2c:	2001      	movs	r0, #1
1ffe8d2e:	f000 fa03 	bl	1ffe9138 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetEventStatus_veneer>
1ffe8d32:	4603      	mov	r3, r0
1ffe8d34:	2b01      	cmp	r3, #1
1ffe8d36:	d102      	bne.n	1ffe8d3e <POSIF0_0_IRQHandler+0x16>
    Motor0_BLDC_SCALAR_WrongHallEvent();
1ffe8d38:	f000 f9e2 	bl	1ffe9100 <__Motor0_BLDC_SCALAR_WrongHallEvent_veneer>
}
1ffe8d3c:	e001      	b.n	1ffe8d42 <POSIF0_0_IRQHandler+0x1a>
    Motor0_BLDC_SCALAR_CorrectHallEvent();
1ffe8d3e:	f000 f9f7 	bl	1ffe9130 <__Motor0_BLDC_SCALAR_CorrectHallEvent_veneer>
}
1ffe8d42:	bf00      	nop
1ffe8d44:	bd80      	pop	{r7, pc}
1ffe8d46:	bf00      	nop

1ffe8d48 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation>:
{
1ffe8d48:	b480      	push	{r7}
1ffe8d4a:	b083      	sub	sp, #12
1ffe8d4c:	af00      	add	r7, sp, #0
1ffe8d4e:	6078      	str	r0, [r7, #4]
1ffe8d50:	6039      	str	r1, [r7, #0]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum -= Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex];
1ffe8d52:	4b27      	ldr	r3, [pc, #156]	; (1ffe8df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8d54:	6a1a      	ldr	r2, [r3, #32]
1ffe8d56:	4b26      	ldr	r3, [pc, #152]	; (1ffe8df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8d58:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
1ffe8d5c:	4619      	mov	r1, r3
1ffe8d5e:	4b24      	ldr	r3, [pc, #144]	; (1ffe8df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8d60:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
1ffe8d64:	1ad3      	subs	r3, r2, r3
1ffe8d66:	4a22      	ldr	r2, [pc, #136]	; (1ffe8df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8d68:	6213      	str	r3, [r2, #32]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex] = capval;
1ffe8d6a:	4b21      	ldr	r3, [pc, #132]	; (1ffe8df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8d6c:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
1ffe8d70:	4619      	mov	r1, r3
1ffe8d72:	4a1f      	ldr	r2, [pc, #124]	; (1ffe8df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8d74:	687b      	ldr	r3, [r7, #4]
1ffe8d76:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum += Motor0_BLDC_SCALAR_SPEED_POS_HALL.captureval[Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex];
1ffe8d7a:	4b1d      	ldr	r3, [pc, #116]	; (1ffe8df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8d7c:	6a1a      	ldr	r2, [r3, #32]
1ffe8d7e:	4b1c      	ldr	r3, [pc, #112]	; (1ffe8df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8d80:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
1ffe8d84:	4619      	mov	r1, r3
1ffe8d86:	4b1a      	ldr	r3, [pc, #104]	; (1ffe8df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8d88:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
1ffe8d8c:	4413      	add	r3, r2
1ffe8d8e:	4a18      	ldr	r2, [pc, #96]	; (1ffe8df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8d90:	6213      	str	r3, [r2, #32]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex++;
1ffe8d92:	4b17      	ldr	r3, [pc, #92]	; (1ffe8df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8d94:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
1ffe8d98:	3301      	adds	r3, #1
1ffe8d9a:	b2da      	uxtb	r2, r3
1ffe8d9c:	4b14      	ldr	r3, [pc, #80]	; (1ffe8df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8d9e:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  if (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex > BLDC_SCALAR_SPEED_POS_HALL_SPEEDACCUMLIMITCHECK)
1ffe8da2:	4b13      	ldr	r3, [pc, #76]	; (1ffe8df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8da4:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
1ffe8da8:	2b05      	cmp	r3, #5
1ffe8daa:	d906      	bls.n	1ffe8dba <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x72>
    Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedindex = 0U;
1ffe8dac:	4b10      	ldr	r3, [pc, #64]	; (1ffe8df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8dae:	2200      	movs	r2, #0
1ffe8db0:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
    Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedcheck = 1U;
1ffe8db4:	4b0e      	ldr	r3, [pc, #56]	; (1ffe8df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8db6:	2201      	movs	r2, #1
1ffe8db8:	61da      	str	r2, [r3, #28]
  if (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedcheck == 1U)
1ffe8dba:	4b0d      	ldr	r3, [pc, #52]	; (1ffe8df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8dbc:	69db      	ldr	r3, [r3, #28]
1ffe8dbe:	2b01      	cmp	r3, #1
1ffe8dc0:	d10c      	bne.n	1ffe8ddc <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x94>
    if (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum > 0U)
1ffe8dc2:	4b0b      	ldr	r3, [pc, #44]	; (1ffe8df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8dc4:	6a1b      	ldr	r3, [r3, #32]
1ffe8dc6:	2b00      	cmp	r3, #0
1ffe8dc8:	d00b      	beq.n	1ffe8de2 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x9a>
      *speed = (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speed_constant) / (Motor0_BLDC_SCALAR_SPEED_POS_HALL.speedaccum);
1ffe8dca:	4b09      	ldr	r3, [pc, #36]	; (1ffe8df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8dcc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
1ffe8dce:	4b08      	ldr	r3, [pc, #32]	; (1ffe8df0 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0xa8>)
1ffe8dd0:	6a1b      	ldr	r3, [r3, #32]
1ffe8dd2:	fbb2 f2f3 	udiv	r2, r2, r3
1ffe8dd6:	683b      	ldr	r3, [r7, #0]
1ffe8dd8:	601a      	str	r2, [r3, #0]
}
1ffe8dda:	e002      	b.n	1ffe8de2 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation+0x9a>
    *speed = 0U;
1ffe8ddc:	683b      	ldr	r3, [r7, #0]
1ffe8dde:	2200      	movs	r2, #0
1ffe8de0:	601a      	str	r2, [r3, #0]
}
1ffe8de2:	bf00      	nop
1ffe8de4:	370c      	adds	r7, #12
1ffe8de6:	46bd      	mov	sp, r7
1ffe8de8:	f85d 7b04 	ldr.w	r7, [sp], #4
1ffe8dec:	4770      	bx	lr
1ffe8dee:	bf00      	nop
1ffe8df0:	1ffe92bc 	.word	0x1ffe92bc

1ffe8df4 <POSIF0_1_IRQHandler>:
 * Prepare hall and multi-channel pattern for the next commutation.
 * Calculate the Speed based on captured value in CCU4 capture slice.
 */

RAM_ATTRIBUTE void Motor0_BLDC_SCALAR_PatternShadowTx_ISR(void)
{
1ffe8df4:	b580      	push	{r7, lr}
1ffe8df6:	b084      	sub	sp, #16
1ffe8df8:	af00      	add	r7, sp, #0
  uint8_t pos;            /* array index variable */
  uint16_t mcmval;  /*current multi-channel pattern */
  uint16_t mcmvals; /*shadow multi-channel pattern */
  uint32_t capval;  /* calculated time between last two hall events */
  uint8_t status;   /* return status of the API to read the captured value from capture register */
  uint32_t speed = 0U; /* electrical speed in RPM */
1ffe8dfa:	2300      	movs	r3, #0
1ffe8dfc:	603b      	str	r3, [r7, #0]
  uint8_t direction = (uint8_t)Motor0_BLDC_SCALAR.motor_set_direction & BLDC_SCALAR_HALL_MOTOR_DIR_INDEX;  /* intended direction */
1ffe8dfe:	4b2e      	ldr	r3, [pc, #184]	; (1ffe8eb8 <POSIF0_1_IRQHandler+0xc4>)
1ffe8e00:	6f9b      	ldr	r3, [r3, #120]	; 0x78
1ffe8e02:	b2db      	uxtb	r3, r3
1ffe8e04:	f003 0308 	and.w	r3, r3, #8
1ffe8e08:	73fb      	strb	r3, [r7, #15]

  /* store the sampled pattern */
  Motor0_BLDC_SCALAR_Hall.prev_hall_pos = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern();
1ffe8e0a:	f000 f9a1 	bl	1ffe9150 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern_veneer>
1ffe8e0e:	4603      	mov	r3, r0
1ffe8e10:	461a      	mov	r2, r3
1ffe8e12:	4b2a      	ldr	r3, [pc, #168]	; (1ffe8ebc <POSIF0_1_IRQHandler+0xc8>)
1ffe8e14:	745a      	strb	r2, [r3, #17]
#if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U)
#if (MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING == 1U)
  /* To blank the direct DC link current measurement at the commutation point */
  Motor0_BLDC_SCALAR_CurrentMeasurement.demagnetization_blanking_enable = 1U;
1ffe8e16:	4b2a      	ldr	r3, [pc, #168]	; (1ffe8ec0 <POSIF0_1_IRQHandler+0xcc>)
1ffe8e18:	2201      	movs	r2, #1
1ffe8e1a:	f883 2020 	strb.w	r2, [r3, #32]
#endif  /* end of #if (MOTOR0_BLDC_SCALAR_ENABLE_DEMAGNET_BLANKING == 1U) */
#endif /* end of #if (MOTOR0_BLDC_SCALAR_VADC_ENABLE_IDC_LINK_MEASUREMENT == 1U) */

  /*Get the expected hall pattern.*/
  pos = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern();
1ffe8e1e:	f000 f9a7 	bl	1ffe9170 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern_veneer>
1ffe8e22:	4603      	mov	r3, r0
1ffe8e24:	73bb      	strb	r3, [r7, #14]
  /*Set next hall pattern and MCM pattern based on the expected hall pattern.*/
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
          (uint8_t)(Motor0_BLDC_SCALAR_Hall.hall_pattern[(uint8_t) pos + (uint32_t) direction]));
1ffe8e26:	7bba      	ldrb	r2, [r7, #14]
1ffe8e28:	7bfb      	ldrb	r3, [r7, #15]
1ffe8e2a:	4413      	add	r3, r2
1ffe8e2c:	4a23      	ldr	r2, [pc, #140]	; (1ffe8ebc <POSIF0_1_IRQHandler+0xc8>)
1ffe8e2e:	5cd3      	ldrb	r3, [r2, r3]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
1ffe8e30:	4618      	mov	r0, r3
1ffe8e32:	f000 f951 	bl	1ffe90d8 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern_veneer>
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern(
      (uint16_t)Motor0_BLDC_SCALAR.mc_pattern[Motor0_BLDC_SCALAR_PWM_BC.modulation_type][(pos) +
1ffe8e36:	4b23      	ldr	r3, [pc, #140]	; (1ffe8ec4 <POSIF0_1_IRQHandler+0xd0>)
1ffe8e38:	7b1b      	ldrb	r3, [r3, #12]
1ffe8e3a:	4618      	mov	r0, r3
1ffe8e3c:	7bba      	ldrb	r2, [r7, #14]
                                          (uint8_t)direction]);
1ffe8e3e:	7bfb      	ldrb	r3, [r7, #15]
      (uint16_t)Motor0_BLDC_SCALAR.mc_pattern[Motor0_BLDC_SCALAR_PWM_BC.modulation_type][(pos) +
1ffe8e40:	4413      	add	r3, r2
1ffe8e42:	491d      	ldr	r1, [pc, #116]	; (1ffe8eb8 <POSIF0_1_IRQHandler+0xc4>)
1ffe8e44:	0102      	lsls	r2, r0, #4
1ffe8e46:	4413      	add	r3, r2
1ffe8e48:	005b      	lsls	r3, r3, #1
1ffe8e4a:	440b      	add	r3, r1
1ffe8e4c:	889b      	ldrh	r3, [r3, #4]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern(
1ffe8e4e:	4618      	mov	r0, r3
1ffe8e50:	f000 f9b2 	bl	1ffe91b8 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern_veneer>

  /*Get the shadow multi-channel pattern value and apply the PWM modulation.*/
  mcmval = (uint16_t)Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern();
1ffe8e54:	f000 f964 	bl	1ffe9120 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern_veneer>
1ffe8e58:	4603      	mov	r3, r0
1ffe8e5a:	81bb      	strh	r3, [r7, #12]
  mcmvals = (uint16_t)Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern();
1ffe8e5c:	f000 f940 	bl	1ffe90e0 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern_veneer>
1ffe8e60:	4603      	mov	r3, r0
1ffe8e62:	817b      	strh	r3, [r7, #10]
  Motor0_BLDC_SCALAR_PWM_BC.shadow_modulation_ptr(mcmval,mcmvals);
1ffe8e64:	4b17      	ldr	r3, [pc, #92]	; (1ffe8ec4 <POSIF0_1_IRQHandler+0xd0>)
1ffe8e66:	685b      	ldr	r3, [r3, #4]
1ffe8e68:	8979      	ldrh	r1, [r7, #10]
1ffe8e6a:	89ba      	ldrh	r2, [r7, #12]
1ffe8e6c:	4610      	mov	r0, r2
1ffe8e6e:	4798      	blx	r3

    /*Get the captured value from capture timer */
  status = (uint8_t)Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue(&capval);
1ffe8e70:	1d3b      	adds	r3, r7, #4
1ffe8e72:	4618      	mov	r0, r3
1ffe8e74:	f000 f984 	bl	1ffe9180 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue_veneer>
1ffe8e78:	4603      	mov	r3, r0
1ffe8e7a:	727b      	strb	r3, [r7, #9]
#if (MOTOR0_BLDC_SCALAR_ENABLE_STALL_DETECTION == 1U)
  /* Reset the stall detection count as hall event is detected for timeout*/
  Motor0_BLDC_SCALAR.stall_detection_counter = 0U;
#endif
  /* if valid speed capture value */
  if (status == (uint8_t)BLDC_SCALAR_SPEED_POS_HALL_STATUS_SUCCESS)
1ffe8e7c:	7a7b      	ldrb	r3, [r7, #9]
1ffe8e7e:	2b00      	cmp	r3, #0
1ffe8e80:	d116      	bne.n	1ffe8eb0 <POSIF0_1_IRQHandler+0xbc>
  {
    /* speed calculation */
    Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation(capval, &speed);
1ffe8e82:	687b      	ldr	r3, [r7, #4]
1ffe8e84:	463a      	mov	r2, r7
1ffe8e86:	4611      	mov	r1, r2
1ffe8e88:	4618      	mov	r0, r3
1ffe8e8a:	f7ff ff5d 	bl	1ffe8d48 <Motor0_BLDC_SCALAR_SPEED_POS_HALL_SpeedCalculation>

    Motor0_BLDC_SCALAR.actual_motor_direction = Motor0_BLDC_SCALAR.motor_set_direction;
1ffe8e8e:	4b0a      	ldr	r3, [pc, #40]	; (1ffe8eb8 <POSIF0_1_IRQHandler+0xc4>)
1ffe8e90:	6f9b      	ldr	r3, [r3, #120]	; 0x78
1ffe8e92:	4a09      	ldr	r2, [pc, #36]	; (1ffe8eb8 <POSIF0_1_IRQHandler+0xc4>)
1ffe8e94:	67d3      	str	r3, [r2, #124]	; 0x7c
    Motor0_BLDC_SCALAR.motor_speed = ((Motor0_BLDC_SCALAR.actual_motor_direction * (int32_t)speed *
1ffe8e96:	4b08      	ldr	r3, [pc, #32]	; (1ffe8eb8 <POSIF0_1_IRQHandler+0xc4>)
1ffe8e98:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
1ffe8e9a:	683a      	ldr	r2, [r7, #0]
1ffe8e9c:	fb02 f303 	mul.w	r3, r2, r3
                                     (int32_t)Motor0_BLDC_SCALAR.speed_mech_scale) >> BLDC_SCALAR_SPEED_SCALE_RES);
1ffe8ea0:	4a05      	ldr	r2, [pc, #20]	; (1ffe8eb8 <POSIF0_1_IRQHandler+0xc4>)
1ffe8ea2:	f8d2 20bc 	ldr.w	r2, [r2, #188]	; 0xbc
    Motor0_BLDC_SCALAR.motor_speed = ((Motor0_BLDC_SCALAR.actual_motor_direction * (int32_t)speed *
1ffe8ea6:	fb02 f303 	mul.w	r3, r2, r3
                                     (int32_t)Motor0_BLDC_SCALAR.speed_mech_scale) >> BLDC_SCALAR_SPEED_SCALE_RES);
1ffe8eaa:	129b      	asrs	r3, r3, #10
    Motor0_BLDC_SCALAR.motor_speed = ((Motor0_BLDC_SCALAR.actual_motor_direction * (int32_t)speed *
1ffe8eac:	4a02      	ldr	r2, [pc, #8]	; (1ffe8eb8 <POSIF0_1_IRQHandler+0xc4>)
1ffe8eae:	66d3      	str	r3, [r2, #108]	; 0x6c
      }
    }
#endif
  }

}
1ffe8eb0:	bf00      	nop
1ffe8eb2:	3710      	adds	r7, #16
1ffe8eb4:	46bd      	mov	sp, r7
1ffe8eb6:	bd80      	pop	{r7, pc}
1ffe8eb8:	1ffe9350 	.word	0x1ffe9350
1ffe8ebc:	1ffe931c 	.word	0x1ffe931c
1ffe8ec0:	1ffe92e8 	.word	0x1ffe92e8
1ffe8ec4:	1ffe9294 	.word	0x1ffe9294

1ffe8ec8 <Motor0_BLDC_SCALAR_MSM>:
{
1ffe8ec8:	b580      	push	{r7, lr}
1ffe8eca:	af00      	add	r7, sp, #0
  switch (Motor0_BLDC_SCALAR.msm_state)
1ffe8ecc:	4b1a      	ldr	r3, [pc, #104]	; (1ffe8f38 <Motor0_BLDC_SCALAR_MSM+0x70>)
1ffe8ece:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
1ffe8ed2:	b2db      	uxtb	r3, r3
1ffe8ed4:	2b08      	cmp	r3, #8
1ffe8ed6:	d824      	bhi.n	1ffe8f22 <Motor0_BLDC_SCALAR_MSM+0x5a>
1ffe8ed8:	a201      	add	r2, pc, #4	; (adr r2, 1ffe8ee0 <Motor0_BLDC_SCALAR_MSM+0x18>)
1ffe8eda:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
1ffe8ede:	bf00      	nop
1ffe8ee0:	1ffe8f1d 	.word	0x1ffe8f1d
1ffe8ee4:	1ffe8f17 	.word	0x1ffe8f17
1ffe8ee8:	1ffe8f0b 	.word	0x1ffe8f0b
1ffe8eec:	1ffe8f23 	.word	0x1ffe8f23
1ffe8ef0:	1ffe8f23 	.word	0x1ffe8f23
1ffe8ef4:	1ffe8f23 	.word	0x1ffe8f23
1ffe8ef8:	1ffe8f23 	.word	0x1ffe8f23
1ffe8efc:	1ffe8f05 	.word	0x1ffe8f05
1ffe8f00:	1ffe8f11 	.word	0x1ffe8f11
      Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func();
1ffe8f04:	f000 f8f0 	bl	1ffe90e8 <__Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func_veneer>
      break;
1ffe8f08:	e00c      	b.n	1ffe8f24 <Motor0_BLDC_SCALAR_MSM+0x5c>
      Motor0_BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION_Func();
1ffe8f0a:	f000 f941 	bl	1ffe9190 <__Motor0_BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION_Func_veneer>
      break;
1ffe8f0e:	e009      	b.n	1ffe8f24 <Motor0_BLDC_SCALAR_MSM+0x5c>
      Motor0_BLDC_SCALAR_MSM_ERROR_Func();
1ffe8f10:	f000 f94a 	bl	1ffe91a8 <__Motor0_BLDC_SCALAR_MSM_ERROR_Func_veneer>
      break;
1ffe8f14:	e006      	b.n	1ffe8f24 <Motor0_BLDC_SCALAR_MSM+0x5c>
      Motor0_BLDC_SCALAR_MSM_START_Func();
1ffe8f16:	f000 f93f 	bl	1ffe9198 <__Motor0_BLDC_SCALAR_MSM_START_Func_veneer>
      break;
1ffe8f1a:	e003      	b.n	1ffe8f24 <Motor0_BLDC_SCALAR_MSM+0x5c>
      Motor0_BLDC_SCALAR_MotorStop();
1ffe8f1c:	f000 f924 	bl	1ffe9168 <__Motor0_BLDC_SCALAR_MotorStop_veneer>
      break;
1ffe8f20:	e000      	b.n	1ffe8f24 <Motor0_BLDC_SCALAR_MSM+0x5c>
      break;
1ffe8f22:	bf00      	nop
  if (Motor0_BLDC_SCALAR.error_status != 0U)
1ffe8f24:	4b04      	ldr	r3, [pc, #16]	; (1ffe8f38 <Motor0_BLDC_SCALAR_MSM+0x70>)
1ffe8f26:	6e9b      	ldr	r3, [r3, #104]	; 0x68
1ffe8f28:	2b00      	cmp	r3, #0
1ffe8f2a:	d003      	beq.n	1ffe8f34 <Motor0_BLDC_SCALAR_MSM+0x6c>
    Motor0_BLDC_SCALAR.msm_state = BLDC_SCALAR_MSM_ERROR;
1ffe8f2c:	4b02      	ldr	r3, [pc, #8]	; (1ffe8f38 <Motor0_BLDC_SCALAR_MSM+0x70>)
1ffe8f2e:	2208      	movs	r2, #8
1ffe8f30:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
}
1ffe8f34:	bf00      	nop
1ffe8f36:	bd80      	pop	{r7, pc}
1ffe8f38:	1ffe9350 	.word	0x1ffe9350

1ffe8f3c <Motor0_BLDC_SCALAR_PatternInitiator>:
{
1ffe8f3c:	b580      	push	{r7, lr}
1ffe8f3e:	b084      	sub	sp, #16
1ffe8f40:	af00      	add	r7, sp, #0
1ffe8f42:	4603      	mov	r3, r0
1ffe8f44:	71fb      	strb	r3, [r7, #7]
  uint8_t direction = (uint8_t) Motor0_BLDC_SCALAR.motor_set_direction & BLDC_SCALAR_HALL_DIRECTION_INDEX;   /* Intended direction */
1ffe8f46:	4b2b      	ldr	r3, [pc, #172]	; (1ffe8ff4 <Motor0_BLDC_SCALAR_PatternInitiator+0xb8>)
1ffe8f48:	6f9b      	ldr	r3, [r3, #120]	; 0x78
1ffe8f4a:	b2db      	uxtb	r3, r3
1ffe8f4c:	f003 0308 	and.w	r3, r3, #8
1ffe8f50:	73fb      	strb	r3, [r7, #15]
      (uint8_t) (Motor0_BLDC_SCALAR_Hall.hall_pattern[curpos + (uint32_t) direction]));
1ffe8f52:	79fa      	ldrb	r2, [r7, #7]
1ffe8f54:	7bfb      	ldrb	r3, [r7, #15]
1ffe8f56:	4413      	add	r3, r2
1ffe8f58:	4a27      	ldr	r2, [pc, #156]	; (1ffe8ff8 <Motor0_BLDC_SCALAR_PatternInitiator+0xbc>)
1ffe8f5a:	5cd3      	ldrb	r3, [r2, r3]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
1ffe8f5c:	4618      	mov	r0, r3
1ffe8f5e:	f000 f8e3 	bl	1ffe9128 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern_veneer>
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern();
1ffe8f62:	f000 f909 	bl	1ffe9178 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern_veneer>
      (uint16_t) Motor0_BLDC_SCALAR.mc_pattern[Motor0_BLDC_SCALAR_PWM_BC.modulation_type][(curpos) + (uint8_t) direction]);
1ffe8f66:	4b25      	ldr	r3, [pc, #148]	; (1ffe8ffc <Motor0_BLDC_SCALAR_PatternInitiator+0xc0>)
1ffe8f68:	7b1b      	ldrb	r3, [r3, #12]
1ffe8f6a:	4618      	mov	r0, r3
1ffe8f6c:	79fa      	ldrb	r2, [r7, #7]
1ffe8f6e:	7bfb      	ldrb	r3, [r7, #15]
1ffe8f70:	4413      	add	r3, r2
1ffe8f72:	4920      	ldr	r1, [pc, #128]	; (1ffe8ff4 <Motor0_BLDC_SCALAR_PatternInitiator+0xb8>)
1ffe8f74:	0102      	lsls	r2, r0, #4
1ffe8f76:	4413      	add	r3, r2
1ffe8f78:	005b      	lsls	r3, r3, #1
1ffe8f7a:	440b      	add	r3, r1
1ffe8f7c:	889b      	ldrh	r3, [r3, #4]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern(
1ffe8f7e:	4618      	mov	r0, r3
1ffe8f80:	f000 f8ca 	bl	1ffe9118 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern_veneer>
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateMultiChannelPattern();
1ffe8f84:	f000 f8b4 	bl	1ffe90f0 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateMultiChannelPattern_veneer>
  pattern_index = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern();
1ffe8f88:	f000 f8da 	bl	1ffe9140 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern_veneer>
1ffe8f8c:	4603      	mov	r3, r0
1ffe8f8e:	73bb      	strb	r3, [r7, #14]
  mcmval = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern();
1ffe8f90:	f000 f8be 	bl	1ffe9110 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern_veneer>
1ffe8f94:	4603      	mov	r3, r0
1ffe8f96:	81bb      	strh	r3, [r7, #12]
  Motor0_BLDC_SCALAR_PWM_BC.immediate_modulation_ptr(mcmval);
1ffe8f98:	4b18      	ldr	r3, [pc, #96]	; (1ffe8ffc <Motor0_BLDC_SCALAR_PatternInitiator+0xc0>)
1ffe8f9a:	689b      	ldr	r3, [r3, #8]
1ffe8f9c:	89ba      	ldrh	r2, [r7, #12]
1ffe8f9e:	4610      	mov	r0, r2
1ffe8fa0:	4798      	blx	r3
      (uint8_t) (Motor0_BLDC_SCALAR_Hall.hall_pattern[(uint8_t) pattern_index + (uint32_t) direction]));
1ffe8fa2:	7bba      	ldrb	r2, [r7, #14]
1ffe8fa4:	7bfb      	ldrb	r3, [r7, #15]
1ffe8fa6:	4413      	add	r3, r2
1ffe8fa8:	4a13      	ldr	r2, [pc, #76]	; (1ffe8ff8 <Motor0_BLDC_SCALAR_PatternInitiator+0xbc>)
1ffe8faa:	5cd3      	ldrb	r3, [r2, r3]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern(
1ffe8fac:	4618      	mov	r0, r3
1ffe8fae:	f000 f8bb 	bl	1ffe9128 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern_veneer>
      (uint16_t) Motor0_BLDC_SCALAR.mc_pattern[Motor0_BLDC_SCALAR_PWM_BC.modulation_type][(pattern_index) + (uint8_t) direction]);
1ffe8fb2:	4b12      	ldr	r3, [pc, #72]	; (1ffe8ffc <Motor0_BLDC_SCALAR_PatternInitiator+0xc0>)
1ffe8fb4:	7b1b      	ldrb	r3, [r3, #12]
1ffe8fb6:	4618      	mov	r0, r3
1ffe8fb8:	7bba      	ldrb	r2, [r7, #14]
1ffe8fba:	7bfb      	ldrb	r3, [r7, #15]
1ffe8fbc:	4413      	add	r3, r2
1ffe8fbe:	490d      	ldr	r1, [pc, #52]	; (1ffe8ff4 <Motor0_BLDC_SCALAR_PatternInitiator+0xb8>)
1ffe8fc0:	0102      	lsls	r2, r0, #4
1ffe8fc2:	4413      	add	r3, r2
1ffe8fc4:	005b      	lsls	r3, r3, #1
1ffe8fc6:	440b      	add	r3, r1
1ffe8fc8:	889b      	ldrh	r3, [r3, #4]
  Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern(
1ffe8fca:	4618      	mov	r0, r3
1ffe8fcc:	f000 f8a4 	bl	1ffe9118 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern_veneer>
  mcmval = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern();
1ffe8fd0:	f000 f89e 	bl	1ffe9110 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern_veneer>
1ffe8fd4:	4603      	mov	r3, r0
1ffe8fd6:	81bb      	strh	r3, [r7, #12]
  mcmshadow = Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern();
1ffe8fd8:	f000 f8ea 	bl	1ffe91b0 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern_veneer>
1ffe8fdc:	4603      	mov	r3, r0
1ffe8fde:	817b      	strh	r3, [r7, #10]
  Motor0_BLDC_SCALAR_PWM_BC.shadow_modulation_ptr(mcmval, mcmshadow);
1ffe8fe0:	4b06      	ldr	r3, [pc, #24]	; (1ffe8ffc <Motor0_BLDC_SCALAR_PatternInitiator+0xc0>)
1ffe8fe2:	685b      	ldr	r3, [r3, #4]
1ffe8fe4:	8979      	ldrh	r1, [r7, #10]
1ffe8fe6:	89ba      	ldrh	r2, [r7, #12]
1ffe8fe8:	4610      	mov	r0, r2
1ffe8fea:	4798      	blx	r3
}
1ffe8fec:	bf00      	nop
1ffe8fee:	3710      	adds	r7, #16
1ffe8ff0:	46bd      	mov	sp, r7
1ffe8ff2:	bd80      	pop	{r7, pc}
1ffe8ff4:	1ffe9350 	.word	0x1ffe9350
1ffe8ff8:	1ffe931c 	.word	0x1ffe931c
1ffe8ffc:	1ffe9294 	.word	0x1ffe9294

1ffe9000 <Motor0_BLDC_SCALAR_Ramp_Linear>:
 * API IMPLEMENTATION
 **********************************************************************************************************************/
#if (MOTOR0_BLDC_SCALAR_ENABLE_RAMP == 1U)
/* This generates the linear ramp as per configured slew rate */
RAM_ATTRIBUTE void Motor0_BLDC_SCALAR_Ramp_Linear(void)
{
1ffe9000:	b480      	push	{r7}
1ffe9002:	b083      	sub	sp, #12
1ffe9004:	af00      	add	r7, sp, #0
  static int32_t sum;     /* to find the increment/decrement value */
  int32_t setval_diff;   /* difference between ramp input and output value */
  int32_t ramp_val;      /* value by which set value is incremented or decremented */

  /* ramp up - if target end value is greater than the ramp output set_value */
  if ((Motor0_BLDC_SCALAR_Ramp.input_value) >= Motor0_BLDC_SCALAR_Ramp.set_value)
1ffe9006:	4b32      	ldr	r3, [pc, #200]	; (1ffe90d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1ffe9008:	685a      	ldr	r2, [r3, #4]
1ffe900a:	4b31      	ldr	r3, [pc, #196]	; (1ffe90d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1ffe900c:	681b      	ldr	r3, [r3, #0]
1ffe900e:	429a      	cmp	r2, r3
1ffe9010:	db29      	blt.n	1ffe9066 <Motor0_BLDC_SCALAR_Ramp_Linear+0x66>
  {
    /* Find increment value using fixed point representation */
    setval_diff = (Motor0_BLDC_SCALAR_Ramp.input_value) - Motor0_BLDC_SCALAR_Ramp.set_value;
1ffe9012:	4b2f      	ldr	r3, [pc, #188]	; (1ffe90d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1ffe9014:	685a      	ldr	r2, [r3, #4]
1ffe9016:	4b2e      	ldr	r3, [pc, #184]	; (1ffe90d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1ffe9018:	681b      	ldr	r3, [r3, #0]
1ffe901a:	1ad3      	subs	r3, r2, r3
1ffe901c:	607b      	str	r3, [r7, #4]
    sum = (int32_t)(sum + (int32_t)Motor0_BLDC_SCALAR_Ramp.ramp_rate);
1ffe901e:	4b2c      	ldr	r3, [pc, #176]	; (1ffe90d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1ffe9020:	689b      	ldr	r3, [r3, #8]
1ffe9022:	461a      	mov	r2, r3
1ffe9024:	4b2b      	ldr	r3, [pc, #172]	; (1ffe90d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
1ffe9026:	681b      	ldr	r3, [r3, #0]
1ffe9028:	4413      	add	r3, r2
1ffe902a:	4a2a      	ldr	r2, [pc, #168]	; (1ffe90d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
1ffe902c:	6013      	str	r3, [r2, #0]
    ramp_val = (int32_t)(sum >> BLDC_SCALAR_RAMP_SHIFT_16);
1ffe902e:	4b29      	ldr	r3, [pc, #164]	; (1ffe90d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
1ffe9030:	681b      	ldr	r3, [r3, #0]
1ffe9032:	141b      	asrs	r3, r3, #16
1ffe9034:	603b      	str	r3, [r7, #0]
    sum = (int32_t)(sum & BLDC_SCALAR_RAMP_POW_16);
1ffe9036:	4b27      	ldr	r3, [pc, #156]	; (1ffe90d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
1ffe9038:	681b      	ldr	r3, [r3, #0]
1ffe903a:	b29b      	uxth	r3, r3
1ffe903c:	4a25      	ldr	r2, [pc, #148]	; (1ffe90d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
1ffe903e:	6013      	str	r3, [r2, #0]

    /* Set value reached the end point */
    if (setval_diff <= ramp_val)
1ffe9040:	687a      	ldr	r2, [r7, #4]
1ffe9042:	683b      	ldr	r3, [r7, #0]
1ffe9044:	429a      	cmp	r2, r3
1ffe9046:	dc07      	bgt.n	1ffe9058 <Motor0_BLDC_SCALAR_Ramp_Linear+0x58>
    {
      Motor0_BLDC_SCALAR_Ramp.set_value = (Motor0_BLDC_SCALAR_Ramp.input_value);
1ffe9048:	4b21      	ldr	r3, [pc, #132]	; (1ffe90d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1ffe904a:	685b      	ldr	r3, [r3, #4]
1ffe904c:	4a20      	ldr	r2, [pc, #128]	; (1ffe90d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1ffe904e:	6013      	str	r3, [r2, #0]
      sum = 0;
1ffe9050:	4b20      	ldr	r3, [pc, #128]	; (1ffe90d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
1ffe9052:	2200      	movs	r2, #0
1ffe9054:	601a      	str	r2, [r3, #0]
  }
  else
  {

  }
}
1ffe9056:	e035      	b.n	1ffe90c4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xc4>
      Motor0_BLDC_SCALAR_Ramp.set_value += ramp_val;
1ffe9058:	4b1d      	ldr	r3, [pc, #116]	; (1ffe90d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1ffe905a:	681a      	ldr	r2, [r3, #0]
1ffe905c:	683b      	ldr	r3, [r7, #0]
1ffe905e:	4413      	add	r3, r2
1ffe9060:	4a1b      	ldr	r2, [pc, #108]	; (1ffe90d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1ffe9062:	6013      	str	r3, [r2, #0]
}
1ffe9064:	e02e      	b.n	1ffe90c4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xc4>
  else if ((Motor0_BLDC_SCALAR_Ramp.input_value) < Motor0_BLDC_SCALAR_Ramp.set_value)
1ffe9066:	4b1a      	ldr	r3, [pc, #104]	; (1ffe90d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1ffe9068:	685a      	ldr	r2, [r3, #4]
1ffe906a:	4b19      	ldr	r3, [pc, #100]	; (1ffe90d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1ffe906c:	681b      	ldr	r3, [r3, #0]
1ffe906e:	429a      	cmp	r2, r3
1ffe9070:	da28      	bge.n	1ffe90c4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xc4>
    setval_diff =  Motor0_BLDC_SCALAR_Ramp.set_value - (Motor0_BLDC_SCALAR_Ramp.input_value);
1ffe9072:	4b17      	ldr	r3, [pc, #92]	; (1ffe90d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1ffe9074:	681a      	ldr	r2, [r3, #0]
1ffe9076:	4b16      	ldr	r3, [pc, #88]	; (1ffe90d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1ffe9078:	685b      	ldr	r3, [r3, #4]
1ffe907a:	1ad3      	subs	r3, r2, r3
1ffe907c:	607b      	str	r3, [r7, #4]
    sum = (int32_t)(sum + (int32_t)Motor0_BLDC_SCALAR_Ramp.ramp_rate);
1ffe907e:	4b14      	ldr	r3, [pc, #80]	; (1ffe90d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1ffe9080:	689b      	ldr	r3, [r3, #8]
1ffe9082:	461a      	mov	r2, r3
1ffe9084:	4b13      	ldr	r3, [pc, #76]	; (1ffe90d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
1ffe9086:	681b      	ldr	r3, [r3, #0]
1ffe9088:	4413      	add	r3, r2
1ffe908a:	4a12      	ldr	r2, [pc, #72]	; (1ffe90d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
1ffe908c:	6013      	str	r3, [r2, #0]
    ramp_val = (int32_t)(sum >> BLDC_SCALAR_RAMP_SHIFT_16);
1ffe908e:	4b11      	ldr	r3, [pc, #68]	; (1ffe90d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
1ffe9090:	681b      	ldr	r3, [r3, #0]
1ffe9092:	141b      	asrs	r3, r3, #16
1ffe9094:	603b      	str	r3, [r7, #0]
    sum = (int32_t)(sum & BLDC_SCALAR_RAMP_POW_16);
1ffe9096:	4b0f      	ldr	r3, [pc, #60]	; (1ffe90d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
1ffe9098:	681b      	ldr	r3, [r3, #0]
1ffe909a:	b29b      	uxth	r3, r3
1ffe909c:	4a0d      	ldr	r2, [pc, #52]	; (1ffe90d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
1ffe909e:	6013      	str	r3, [r2, #0]
    if (setval_diff <= ramp_val)
1ffe90a0:	687a      	ldr	r2, [r7, #4]
1ffe90a2:	683b      	ldr	r3, [r7, #0]
1ffe90a4:	429a      	cmp	r2, r3
1ffe90a6:	dc07      	bgt.n	1ffe90b8 <Motor0_BLDC_SCALAR_Ramp_Linear+0xb8>
      Motor0_BLDC_SCALAR_Ramp.set_value = (Motor0_BLDC_SCALAR_Ramp.input_value);
1ffe90a8:	4b09      	ldr	r3, [pc, #36]	; (1ffe90d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1ffe90aa:	685b      	ldr	r3, [r3, #4]
1ffe90ac:	4a08      	ldr	r2, [pc, #32]	; (1ffe90d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1ffe90ae:	6013      	str	r3, [r2, #0]
      sum = 0;
1ffe90b0:	4b08      	ldr	r3, [pc, #32]	; (1ffe90d4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd4>)
1ffe90b2:	2200      	movs	r2, #0
1ffe90b4:	601a      	str	r2, [r3, #0]
}
1ffe90b6:	e005      	b.n	1ffe90c4 <Motor0_BLDC_SCALAR_Ramp_Linear+0xc4>
      Motor0_BLDC_SCALAR_Ramp.set_value -= ramp_val;
1ffe90b8:	4b05      	ldr	r3, [pc, #20]	; (1ffe90d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1ffe90ba:	681a      	ldr	r2, [r3, #0]
1ffe90bc:	683b      	ldr	r3, [r7, #0]
1ffe90be:	1ad3      	subs	r3, r2, r3
1ffe90c0:	4a03      	ldr	r2, [pc, #12]	; (1ffe90d0 <Motor0_BLDC_SCALAR_Ramp_Linear+0xd0>)
1ffe90c2:	6013      	str	r3, [r2, #0]
}
1ffe90c4:	bf00      	nop
1ffe90c6:	370c      	adds	r7, #12
1ffe90c8:	46bd      	mov	sp, r7
1ffe90ca:	f85d 7b04 	ldr.w	r7, [sp], #4
1ffe90ce:	4770      	bx	lr
1ffe90d0:	1ffe9280 	.word	0x1ffe9280
1ffe90d4:	1ffe98c8 	.word	0x1ffe98c8

1ffe90d8 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern_veneer>:
1ffe90d8:	f85f f000 	ldr.w	pc, [pc]	; 1ffe90dc <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern_veneer+0x4>
1ffe90dc:	08021e55 	.word	0x08021e55

1ffe90e0 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern_veneer>:
1ffe90e0:	f85f f000 	ldr.w	pc, [pc]	; 1ffe90e4 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern_veneer+0x4>
1ffe90e4:	08021e35 	.word	0x08021e35

1ffe90e8 <__Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func_veneer>:
1ffe90e8:	f85f f000 	ldr.w	pc, [pc]	; 1ffe90ec <__Motor0_BLDC_SCALAR_MSM_NORMAL_OPERATION_Func_veneer+0x4>
1ffe90ec:	08022325 	.word	0x08022325

1ffe90f0 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateMultiChannelPattern_veneer>:
1ffe90f0:	f85f f000 	ldr.w	pc, [pc]	; 1ffe90f4 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateMultiChannelPattern_veneer+0x4>
1ffe90f4:	0802260d 	.word	0x0802260d

1ffe90f8 <__Motor0_BLDC_SCALAR_DirectionControl_veneer>:
1ffe90f8:	f85f f000 	ldr.w	pc, [pc]	; 1ffe90fc <__Motor0_BLDC_SCALAR_DirectionControl_veneer+0x4>
1ffe90fc:	080216f9 	.word	0x080216f9

1ffe9100 <__Motor0_BLDC_SCALAR_WrongHallEvent_veneer>:
1ffe9100:	f85f f000 	ldr.w	pc, [pc]	; 1ffe9104 <__Motor0_BLDC_SCALAR_WrongHallEvent_veneer+0x4>
1ffe9104:	08021a55 	.word	0x08021a55

1ffe9108 <__Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate_veneer>:
1ffe9108:	f85f f000 	ldr.w	pc, [pc]	; 1ffe910c <__Motor0_BLDC_SCALAR_PWM_BC_DutyCycleUpdate_veneer+0x4>
1ffe910c:	08021349 	.word	0x08021349

1ffe9110 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern_veneer>:
1ffe9110:	f85f f000 	ldr.w	pc, [pc]	; 1ffe9114 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern_veneer+0x4>
1ffe9114:	08022621 	.word	0x08022621

1ffe9118 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern_veneer>:
1ffe9118:	f85f f000 	ldr.w	pc, [pc]	; 1ffe911c <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern_veneer+0x4>
1ffe911c:	080225ed 	.word	0x080225ed

1ffe9120 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern_veneer>:
1ffe9120:	f85f f000 	ldr.w	pc, [pc]	; 1ffe9124 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetMultiChannelPattern_veneer+0x4>
1ffe9124:	08021e15 	.word	0x08021e15

1ffe9128 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern_veneer>:
1ffe9128:	f85f f000 	ldr.w	pc, [pc]	; 1ffe912c <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetHallPattern_veneer+0x4>
1ffe912c:	08022661 	.word	0x08022661

1ffe9130 <__Motor0_BLDC_SCALAR_CorrectHallEvent_veneer>:
1ffe9130:	f85f f000 	ldr.w	pc, [pc]	; 1ffe9134 <__Motor0_BLDC_SCALAR_CorrectHallEvent_veneer+0x4>
1ffe9134:	08021bdd 	.word	0x08021bdd

1ffe9138 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetEventStatus_veneer>:
1ffe9138:	f85f f000 	ldr.w	pc, [pc]	; 1ffe913c <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetEventStatus_veneer+0x4>
1ffe913c:	08021a11 	.word	0x08021a11

1ffe9140 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern_veneer>:
1ffe9140:	f85f f000 	ldr.w	pc, [pc]	; 1ffe9144 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern_veneer+0x4>
1ffe9144:	08022695 	.word	0x08022695

1ffe9148 <__Motor0_BLDC_SCALAR_SpeedControlScheme_veneer>:
1ffe9148:	f85f f000 	ldr.w	pc, [pc]	; 1ffe914c <__Motor0_BLDC_SCALAR_SpeedControlScheme_veneer+0x4>
1ffe914c:	080216ad 	.word	0x080216ad

1ffe9150 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern_veneer>:
1ffe9150:	f85f f000 	ldr.w	pc, [pc]	; 1ffe9154 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetLastHallPattern_veneer+0x4>
1ffe9154:	08021e95 	.word	0x08021e95

1ffe9158 <__Motor0_BLDC_SCALAR_GetAverageCurrentValue_veneer>:
1ffe9158:	f85f f000 	ldr.w	pc, [pc]	; 1ffe915c <__Motor0_BLDC_SCALAR_GetAverageCurrentValue_veneer+0x4>
1ffe915c:	08021589 	.word	0x08021589

1ffe9160 <__Motor0_BLDC_SCALAR_CCU8_EnableDeadTime_veneer>:
1ffe9160:	f85f f000 	ldr.w	pc, [pc]	; 1ffe9164 <__Motor0_BLDC_SCALAR_CCU8_EnableDeadTime_veneer+0x4>
1ffe9164:	0802097b 	.word	0x0802097b

1ffe9168 <__Motor0_BLDC_SCALAR_MotorStop_veneer>:
1ffe9168:	f85f f000 	ldr.w	pc, [pc]	; 1ffe916c <__Motor0_BLDC_SCALAR_MotorStop_veneer+0x4>
1ffe916c:	0802295d 	.word	0x0802295d

1ffe9170 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern_veneer>:
1ffe9170:	f85f f000 	ldr.w	pc, [pc]	; 1ffe9174 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetExpectedPattern_veneer+0x4>
1ffe9174:	08021e75 	.word	0x08021e75

1ffe9178 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern_veneer>:
1ffe9178:	f85f f000 	ldr.w	pc, [pc]	; 1ffe917c <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_UpdateHallPattern_veneer+0x4>
1ffe917c:	08022681 	.word	0x08022681

1ffe9180 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue_veneer>:
1ffe9180:	f85f f000 	ldr.w	pc, [pc]	; 1ffe9184 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_ReadCaptureValue_veneer+0x4>
1ffe9184:	08021d81 	.word	0x08021d81

1ffe9188 <__Motor0_BLDC_SCALAR_GetCurrentValue_veneer>:
1ffe9188:	f85f f000 	ldr.w	pc, [pc]	; 1ffe918c <__Motor0_BLDC_SCALAR_GetCurrentValue_veneer+0x4>
1ffe918c:	080214ed 	.word	0x080214ed

1ffe9190 <__Motor0_BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION_Func_veneer>:
1ffe9190:	f85f f000 	ldr.w	pc, [pc]	; 1ffe9194 <__Motor0_BLDC_SCALAR_MSM_MOTOR_STATE_IDENTIFICATION_Func_veneer+0x4>
1ffe9194:	0802241d 	.word	0x0802241d

1ffe9198 <__Motor0_BLDC_SCALAR_MSM_START_Func_veneer>:
1ffe9198:	f85f f000 	ldr.w	pc, [pc]	; 1ffe919c <__Motor0_BLDC_SCALAR_MSM_START_Func_veneer+0x4>
1ffe919c:	08022275 	.word	0x08022275

1ffe91a0 <__Motor0_BLDC_SCALAR_CCU8_DisableDeadTime_veneer>:
1ffe91a0:	f85f f000 	ldr.w	pc, [pc]	; 1ffe91a4 <__Motor0_BLDC_SCALAR_CCU8_DisableDeadTime_veneer+0x4>
1ffe91a4:	0802099f 	.word	0x0802099f

1ffe91a8 <__Motor0_BLDC_SCALAR_MSM_ERROR_Func_veneer>:
1ffe91a8:	f85f f000 	ldr.w	pc, [pc]	; 1ffe91ac <__Motor0_BLDC_SCALAR_MSM_ERROR_Func_veneer+0x4>
1ffe91ac:	080224cd 	.word	0x080224cd

1ffe91b0 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern_veneer>:
1ffe91b0:	f85f f000 	ldr.w	pc, [pc]	; 1ffe91b4 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_GetShadowMultiChannelPattern_veneer+0x4>
1ffe91b4:	08022641 	.word	0x08022641

1ffe91b8 <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern_veneer>:
1ffe91b8:	f85f f000 	ldr.w	pc, [pc]	; 1ffe91bc <__Motor0_BLDC_SCALAR_SPEED_POS_HALL_SetMultiChannelPattern_veneer+0x4>
1ffe91bc:	08021df5 	.word	0x08021df5
